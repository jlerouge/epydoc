#
# epydoc.py: epydoc HTML output generator
# Edward Loper
#
# Created [01/30/01 05:18 PM]
# $Id$
#

"""
Documentation to HTML converter.
"""
__docformat__ = 'epytext en'

##################################################
## Implementation Notes
##################################################

# Index:
#     1. Constants
#     2. Imports
#     3. HTML Formatter
#       - Constructor
#       - Write
#       - HTML page generation
#       - Navigation bar
#       - Base class trees
#       - Class hierarchy trees
#       - Module hierarchy trees
#       - Class tables
#       - Function tables
#       - Variable tables
#       - Term index generation
#       - Identifier index generation
#       - Table of contents (frames)
#       - Docstring->HTML Conversion
#       - Helper functions
#

# I chose to implement the formatter as a class (rather than as a
# group of functions) because it lets me use instance variables to
# remember all the configuration variables.  Passing these around
# manually would be a pain.  Also, I don't have to explicitly pass
# around the docmap, which is used almost everywhere.

##################################################
## Constants
##################################################

# Expects: name
HEADER = '''<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>%s</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
</head>
<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
'''
# Expects: (version, date)
FOOTER = '''
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left"><font size="-2">Generated by Epydoc %s on %s</font></td>
    <td align="right"><a href="http://epydoc.sourceforge.net"
                      ><font size="-2">http://epydoc.sf.net</font></a></td>
  </tr>
</table>
</body>
</html>
'''
# Expects: (name, mainFrame_src)
FRAMES_INDEX = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
  <title> %s </title>
</head>
<frameset cols="20%%,80%%">
  <frameset rows="30%%,70%%">
    <frame src="toc.html" name="moduleListFrame">
    <frame src="toc-everything.html" name="moduleFrame">
  </frameset>
  <frame src="%s" name="mainFrame">
</frameset>
</html>
'''
# Expects (url, url, name)
REDIRECT_INDEX = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
  <title> Redirect </title>
  <meta http-equiv="refresh" content="1;url=%s">
  <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
</head>
<body>
  Redirecting to the API documentation for <a href="%s">%s</a>...
</body>
</html>
'''

# Names for the __special__ methods.
SPECIAL_METHODS ={
    '__init__': 'Constructor',
    '__del__': 'Destructor',
    '__add__': 'Addition operator',
    '__sub__': 'Subtraction operator',
    '__and__': 'And operator',
    '__or__': 'Or operator',
    '__repr__': 'Representation operator',
    '__call__': 'Call operator',
    '__getattr__': 'Qualification operator',
    '__getitem__': 'Indexing operator',
    '__setitem__': 'Index assignment operator',
    '__delitem__': 'Index deletion operator',
    '__delslice__': 'Slice deletion operator',
    '__setslice__': 'Slice assignment operator',
    '__getslice__': 'Slicling operator',
    '__len__': 'Length operator',
    '__cmp__': 'Comparison operator',
    '__eq__': 'Equality operator',
    '__in__': 'Containership operator',
    '__gt__': 'Greater-than operator',
    '__lt__': 'Less-than operator',
    '__ge__': 'Greater-than-or-equals operator',
    '__le__': 'Less-than-or-equals operator',
    '__radd__': 'Right-side addition operator',
    '__hash__': 'Hashing function',
    '__contains__': 'In operator',
    '__nonzero__': 'Boolean test operator',
    '__str__': 'Informal representation operator',
    }

##################################################
## Imports
##################################################

# system imports
import re, sys, os.path, time, pprint
import xml.dom.minidom

# epydoc imports
import epydoc
import epydoc.epytext as epytext
from epydoc.uid import UID, Link, findUID, make_uid
from epydoc.imports import import_module
from epydoc.objdoc import DocMap, ModuleDoc, FuncDoc
from epydoc.objdoc import ClassDoc, Var, Raise, ObjDoc
from epydoc.css import STYLESHEETS
from epydoc.help import HTML_HELP
from epydoc.colorize import colorize_re, colorize_doctestblock

##################################################
## Documentation -> HTML Conversion
##################################################

class HTMLFormatter:
    """
    Documentation to HTML converter.  The API documentation produced
    C{HTMLFormatter} consists of a set of HTML files.  Two
    subdirectories are created for the public and private
    documentation.  Within each subdirectories, every class and module
    is documented in its own file.  An index file, a trees file, a
    help file, and a frames-based table of contents are also created.
    In particular, C{HTMLFormatter} generates the following files:

      - X{index.html}: The standard entry point for the documentation.
        Normally, index.html is a frame index file, which defines
        three frames: two frames on the left side of the browser
        contain a table of contents, and the main frame on the right
        side of the window contains documentation pages.  But if the
        --no-frames option is used, then index.html will redirect the
        user to the project's top page.
      - X{I{module}-module.html}: The API documentation for a module.  module
        is the complete dotted name of the module, such as sys or
        epydoc.epytext.
      - X{I{class}-class.html}: The API documentation for a class, exception,
        or type.  class is the complete dotted name of the class, such
        as epydoc.epytext.Token or array.ArrayType.
      - X{trees.html}: The module and class hierarchies.
      - X{indices.html} The term and identifier indices.  
      - X{help.html}: The help page for the project.  This page
        explains how to use and navigate the webpage produced by
        epydoc.
      - X{toc.html}: The top-level table of contents page.  This page
        is displayed in the upper-left frame, and provides links to
        toc-everything.html and the toc-I{module}-module.html files.  toc.html
        is not generated if the --no-frames option is used.
      - X{toc-everything.html}: The table of contents for the entire
        project.  This page is displayed in the lower-left frame, and
        provides links to every class, type, exception, function,
        and variable defined by the project.  toc-everything.html is
        not generated if the --no-frames option is used.
      - X{toc-I{module}-module.html}: The table of contents for a module.
        This page is displayed in the lower-left frame, and provides
        links to every class, type, exception, function, and variable
        defined by the module.  module is the complete dotted name of
        the module, such as sys or epydoc.epytext.  toc-m-module.html
        is not generated if the --no-frames option is used.
      - X{epydoc.css}: The CSS stylesheet used to display all HTML
        pages.

    @type docmap: L{DocMap}
    @ivar docmap: The documentation object, encoding the objects that
        should be documented.
    @type _prj_name: C{string}
    @ivar _prj_name: A name for the documentation (for the navbar).
    @type _prj_url: C{string}
    @ivar _prj_url: A URL for the documentation (for the navpar).
    @ivar _module: The UID of the top-level module, if there is one. 
        If there is more than one top-level module, then C{_module} is
        C{'multiple'}; if there is no top-level module, then
        C{_module} is C{None}.
    @ivar _package: The UID of the top-level package, if there is
        one. If there is more than one top-level package, then
        C{_package} is C{'multiple'}; if there is no top-level
        package, then C{_package} is C{None}.
    @ivar _show_private: Whether we are currently writing files that
        show private objects.
    @ivar _css: The name of a file containing a CSS stylesheet; or the
        name of a CSS stylesheet.
    @ivar _cssfile: The name of the CSS stylesheet file.  This should
        be C{'epydoc.css'} when C{_show_private==0} and
        C{'../epydoc.css'} when C{_show_private==1}.
    @ivar _variable_linelen:  The maximum line length used for
        displaying the values of variables in the variable
        details sections.
    @ivar _variable_maxlines: The maximum number of lines that
         should be displayed for the value of a variable in the
         variable details section.
    """

    #////////////////////////////////////////////////////////////
    # Constructor
    #////////////////////////////////////////////////////////////
    
    def __init__(self, docmap, **kwargs):
        """
        Construct a new HTML outputter, using the given
        L{DocMap} object.
        
        @param docmap: The documentation to output.
        @type docmap: L{DocMap}
        @param kwargs: Keyword arguments:
            - C{prj_name}: The name of the project.  Defaults to
              none.  (type=C{string})
            - C{prj_url}: The target for the project hopeage link on
              the navigation bar.  If C{prj_url} is not specified,
              then no hyperlink is created.  (type=C{string})
            - C{prj_link}: The label for the project link on the
              navigation bar.  This link can contain arbitrary HTML
              code (e.g. images).  By default, a label is constructed
              from C{prj_name}.  (type=C{string})
            - C{top}: The top page for the documentation.  This
              is the default page shown main frame, when frames are
              enabled.  C{top} can be a URL, the name of a
              module, the name of a class, or one of the special
              strings C{"trees.html"}, C{"indices.html"}, or
              C{"help.html"}.  By default, the top-level package or
              module is used, if there is one; otherwise, C{"trees"}
              is used.  (type=C{string})
            - C{css}: The CSS stylesheet file.  If C{css} is a file
              name, then the specified file's conents will be used.
              Otherwise, if C{css} is the name of a CSS stylesheet in
              L{epydoc.css}, then that stylesheet will be used.
              Otherwise, an error is reported.  If no stylesheet is
              specified, then the default stylesheet is used.
              (type=C{string})
            - C{private_css}: The CSS stylesheet file for the private
              API documentation.  If C{css} is a file name, then the
              specified file's conents will be used.  Otherwise, if
              C{css} is the name of a CSS stylesheet in L{epydoc.css},
              then that stylesheet will be used.  Otherwise, an error
              is reported.  If no stylesheet is specified, then the
              private API documentation will use the same stylesheet
              as the public API documentation.  (type=C{string})
            - C{help}: The name of the help file.  If no help file is
              specified, then the default help file will be used.
              (type=C{string})
            - C{private}: Whether to create documentation for private
              objects.  By default, private objects are documented.
              (type=C{boolean})
            - C{frames}: Whether to create a frames-based table of
              contents.  By default, it is produced.
              (type=C{boolean}) 
            - C{show_imports}: Whether or not to display lists of
              imported functions and classes.  By default, they are
              not shown.  (type=C{boolean})
            - C{index_parameters}: Whether or not to include function
              parameters in the identifier index.  By default, they
              are not included.  (type=C{boolean})
            - C{variable_maxlines}: The maximum number of lines that
              should be displayed for the value of a variable in the
              variable details section.  By default, 8 lines are
              displayed.  (type=C{int})
            - C{variable_linelength}: The maximum line length used for
              displaying the values of variables in the variable
              details sections.  If a line is longer than this length,
              then it will be wrapped to the next line.  The default
              line length is 70 characters.  (type=C{int})
        """
        self._docmap = docmap

        # Process keyword arguments.
        self._prj_name = kwargs.get('prj_name', None)
        self._prj_url = kwargs.get('prj_url', None)
        self._prj_link = kwargs.get('prj_link', None)
        self._top_page = self._find_top_page(kwargs.get('top', None))
        self._css = kwargs.get('css')
        self._private_css = kwargs.get('private_css') or self._css
        self._helpfile = kwargs.get('help', None)
        self._create_private_docs = kwargs.get('private', 1)
        self._frames_index = kwargs.get('frames', 1)
        self._show_imports = kwargs.get('show_imports', 0)
        self._index_parameters = kwargs.get('index_parameters', 0)
        self._variable_maxlines = kwargs.get('variable_maxlines', 8)
        self._variable_linelen = kwargs.get('variable_linelength', 70)

        # Create the project homepage link, if it was not specified.
        if (self._prj_name or self._prj_url) and not self._prj_link:
            name = self._prj_name or 'Project Homepage'
            name = name.replace('&', '&amp;')
            name = name.replace('<', '&lt;')
            name = name.replace('>', '&gt;')
            name = name.replace(' ', '&nbsp;')
            self._prj_link = name

        # Add a hyperlink to _prj_url, if _prj_link doesn't already
        # contain any hyperlinks.
        if (self._prj_link and self._prj_url and
            not re.search(r'<a[^>]*\shref', self._prj_link)):
            self._prj_link = ('<a class="navbar" target="_top" href="'+
                              self._prj_url+'">'+self._prj_link+'</a>')

    def num_files(self):
        """
        @return: The number of files that this C{HTMLFormatter} will
            generate.
        @rtype: C{int}
        """
        # Basic files (index.html, tree, indices, help, css, toc,
        # toc-everything, frames, base directory index.html, base
        # directory css)
        if self._create_private_docs: n = 18
        else: n = 8

        for uid in self._docmap.keys():
            # Module and class API files
            if not (uid.is_module() or uid.is_class()): continue
            if not uid.is_private(): n += 1
            if self._create_private_docs: n += 1

            # Module TOC files.
            if not uid.is_module(): continue
            if not uid.is_private(): n += 1
            if self._create_private_docs: n += 1
        return n

    #////////////////////////////////////////////////////////////
    # Write (and its helpers)
    #////////////////////////////////////////////////////////////
    
    def write(self, directory=None, progress_callback=None):
        """
        Write the documentation to the given directory.

        @type directory: C{string}
        @param directory: The directory to which output should be
            written.  If no directory is specified, output will be
            written to the current directory.  If the directory does
            not exist, it will be created.
        @type progress_callback: C{function}
        @param progress_callback: A callback function that is called
            before each file is written, with two arguments: the name
            of the created file (C{string}); and the object documented
            by the file, if any (L{ObjDoc}).
        @rtype: C{None}
        @raise OSError: If C{directory} cannot be created, or if any
            file cannot be created or written to. 
        """
        if directory in ('', None): directory = './'
        if directory[-1] != '/': directory = directory + '/'
        self._show_private = 0
        
        # Create dest directories, if necessary
        if not os.path.isdir(directory):
            if os.path.exists(directory):
                raise OSError('%r is not a directory' % directory)
            os.mkdir(directory)
        if self._create_private_docs:
            if not os.path.isdir(os.path.join(directory, 'private/')):
                if os.path.exists(os.path.join(directory, 'private/')):
                    raise OSError('%r is not a directory' %
                                  os.path.join(directory, 'private/'))
                os.mkdir(os.path.join(directory, 'private/'))
            if not os.path.isdir(os.path.join(directory, 'public/')):
                if os.path.exists(os.path.join(directory, 'public/')):
                    raise OSError('%r is not a directory' %
                                  os.path.join(directory, 'public/'))
                os.mkdir(os.path.join(directory, 'public/'))

        if self._create_private_docs:
            # Create the public version of the API docs
            self._epytext_cache = {}
            self._show_private = 0
            self._write(os.path.join(directory, 'public/'),
                        progress_callback)

            # Create the private version of the API docs.
            self._epytext_cache = {}
            self._show_private = 1
            self._write(os.path.join(directory, 'private/'),
                        progress_callback)

            # Create the base directory index.html file.
            self._write_index(directory, progress_callback, 1)
            filename = os.path.join(directory, 'epydoc.css')
            if progress_callback: progress_callback(filename, None)
            self._show_private = 0
            self._write_css(filename)
        else:
            self._epytext_cache = {}
            self._show_private = 0
            self._write(directory, progress_callback)

    def _write(self, directory, progress_callback):
        """
        A helper for L{write} that writes all documentation to a given
        directory.  This is typically called once for the public
        API documentation, and once for the private API documentation. 
        """
        # Write the object documentation.
        self._write_docs(directory, progress_callback)
        
        # Write the tree file (package & class hierarchies)
        filename = os.path.join(directory, 'trees.html')
        if progress_callback: progress_callback(filename, None)
        self._write_trees(filename)

        # Write the index file.
        filename = os.path.join(directory, 'indices.html')
        if progress_callback: progress_callback(filename, None)
        self._write_indices_to_stream(open(filename, 'w'))

        # Write the help file.
        filename = os.path.join(directory, 'help.html')
        if progress_callback: progress_callback(filename, None)
        self._write_help(filename)
        
        # Write the frames-based table of contents
        self._write_frames(directory, progress_callback)
        
        # Write the index.html file.
        self._write_index(directory, progress_callback, 0)
        
        # Write the CSS file.
        filename = os.path.join(directory, 'epydoc.css')
        if progress_callback: progress_callback(filename, None)
        self._write_css(filename)

    def _write_docs(self, directory, progress_callback):
        """
        Write the object documentation to the given directory.  The
        object documentation consists of one file for each module and
        class.

        @rtype: C{None}
        """
        for uid in self._filtersort_uids(self._docmap.keys()):
            doc = self._docmap[uid]
            filename = os.path.join(directory, self._uid_to_uri(uid))
            if isinstance(doc, ModuleDoc):
                if progress_callback: progress_callback(filename, doc)
                str = self._module_to_html(uid)
                open(filename, 'w').write(str)
            elif isinstance(doc, ClassDoc):
                if progress_callback: progress_callback(filename, doc)
                str = self._class_to_html(uid)
                open(filename, 'w').write(str)

    def _write_frames(self, directory, progress_callback):
        """
        Write the frames-driven contents files for the project to the
        given directory.

          - C{frames.html}
          - C{toc.html}
          - C{toc-everything.html}
          - C{toc-I{module}-module.html}

        @rtype: C{None}
        """
        # Write the frames index file
        filename = os.path.join(directory, 'frames.html')
        if progress_callback: progress_callback(filename, None)
        prj_name = self._prj_name or "API Documentation"
        open(filename, 'w').write(FRAMES_INDEX % (prj_name, self._top_page))

        # Write the top-level table of contents.
        filename = os.path.join(directory, 'toc.html')
        if progress_callback: progress_callback(filename, None)
        open(filename, 'w').write(self._toc_to_html())

        # Classes table of contents
        filename = os.path.join(directory, 'toc-everything.html')
        if progress_callback: progress_callback(filename, None)
        str = self._project_toc_to_html()
        open(filename, 'w').write(str)

        # Write the table of contents for each module.
        for uid in self._filtersort_uids(self._docmap.keys()):
            if uid.is_module():
                doc = self._docmap[uid]
                filename = os.path.join(directory, 'toc-%s' %
                                        self._uid_to_uri(uid))
                str = self._module_toc_to_html(uid)
                if progress_callback: progress_callback(filename, doc)
                open(filename, 'w').write(str)

    def _write_frames_index(self, directory, progress_callback, frombase=0):
        # !! OBSOLETE !!
        raise ValueError('obsolete')
        top = self._top_page
        if frombase and not top.startswith('http:') and not '/' in top:
            top = 'public/%s' % top
        filename = os.path.join(directory, 'index.html')
        if progress_callback: progress_callback(filename, None)
        prj_name = self._prj_name or "API Documentation"
        frames = FRAMES_INDEX % (prj_name, top)
        if frombase: frames = re.sub('src="toc', 'src="public/toc', frames)
        open(filename, 'w').write(frames)
        
    def _write_index(self, directory, progress_callback, frombase):
        """
        Write the C{index.html} file to the given file.
        
        @param frombase: True if this is the index file for the base
            directory when we are generating both public and private
            documentation.  In this case, all hyperlinks should be
            changed to point into the C{public} subdirectory.
        @type frombase: C{boolean}
        """
        filename = os.path.join(directory, 'index.html')
        if progress_callback: progress_callback(filename, None)
        if self._frames_index: top = 'frames.html'
        else: top = self._top_page

        ## Write a frames index file.  This is basically the same as
        ## frames.html, but we have to do some redirection if
        ## frombase=1.
        #if self._frames_index:
        #    prj_name = self._prj_name or "API Documentation"
        #    if frombase and top[:5] != 'http:' and '/' not in top:
        #        top = 'public/%s' % top
        #    frames = FRAMES_INDEX % (prj_name, top)
        #    if frombase:
        #        frames = re.sub('src="toc', 'src="public/toc', frames)
        #    open(filename, 'w').write(frames)
        #    return

        # Copy the non-frames index file from top, if it's internal.
        if top[:5] != 'http:' and '/' not in top:
            try:
                # Read top into str.
                if frombase:
                    pubdir = os.path.join(directory, 'public')
                    topfile = os.path.join(pubdir, top)
                else:
                    topfile = os.path.join(directory, top)
                str = open(topfile, 'r').read()

                # Redirect links, if appropriate.
                if frombase:
                    INTERNAL_LINK = r'(<a[^>]+href=")([^:">]+"[^>]*>)'
                    FRAME_LINK = r'(<frame[^>]+src=")([^:">]+"[^>]*>)'
                    str = re.sub(INTERNAL_LINK, r'\1public/\2', str)
                    str = re.sub(FRAME_LINK, r'\1public/\2', str)

                # Write the output file.
                open(filename, 'w').write(str)
                return
            except:
                if sys.stderr.softspace: print >>sys.stderr
                estr = 'Warning: error copying index; using a redirect page'
                print >>sys.stderr, estr
                if frombase: top = 'public/%s' % top

        # Use a redirect if top is external, or if we faild to copy.
        name = self._prj_name or 'this project'
        open(filename, 'w').write(REDIRECT_INDEX % (top, top, name))

    def _write_help(self, filename):
        """
        Write the help file to the given file.  If C{self._helpfile}
        contains a help file, then use it; otherwise, use the default
        helpfile.

        @rtype: C{None}
        """
        # Get the contents of the help file.
        if self._helpfile:
            if os.path.exists(self._helpfile):
                try: help = open(self._helpfile).read()
                except: raise IOError("Can't open help file: %r" %
                                      self._helpfile)
            else:
                raise IOError("Can't find help file: %r" % self._helpfile)
        else:
            if self._prj_name: thisprj = self._prj_name
            else: thisprj = 'this project'
            help = HTML_HELP % {'this_project':thisprj}
        
        # Write the help file.
        helpfile = open(filename, 'w')
        helpfile.write(self._header('Help')+self._navbar('help', 1)+
                       help+self._navbar('help', 0)+self._footer())
        helpfile.close()

    def _write_trees(self, filename):
        """
        Write the trees file to the given file.
        """
        open(filename, 'w').write(self._trees_to_html())
        
    def _write_css(self, filename):
        """
        Write the CSS stylesheet to the given file.  If
        C{self._css} contains a stylesheet file or name (from
        L{epydoc.css}), then use that stylesheet; otherwise, if a
        stylesheet file already exists, use that stylesheet.
        Otherwise, use the default stylesheet.

        @rtype: C{None}
        """
        if self._show_private: cssname = self._private_css
        else: cssname = self._css
        
        # Get the contents for the stylesheet file.  If none was
        # specified, and a stylesheet is already present, then don't
        # do anything.
        if cssname is None:
            if os.path.exists(filename):
                return
            else: css = STYLESHEETS['default'][0]
        else:
            if os.path.exists(cssname):
                try: css = open(cssname).read()
                except: raise IOError("Can't open CSS file: %r" % cssname)
            elif STYLESHEETS.has_key(cssname):
                css = STYLESHEETS[cssname][0]
            else:
                raise IOError("Can't find CSS file: %r" % cssname)

        # Write the stylesheet.
        cssfile = open(filename, 'w')
        cssfile.write(css)
        cssfile.close()
                       
    #////////////////////////////////////////////////////////////
    # HTML page generation
    #////////////////////////////////////////////////////////////
    # Each of these functions creates a single HTML file, and returns
    # it as a string.
    
    def _module_to_html(self, uid):
        """
        @return: An HTML page describing the module identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the module that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation.
        doc = self._docmap[uid]

        # Write the header & navigation bar.
        str = self._header(uid.name())
        str += self._navbar(uid, 1)
        if uid.is_package(): str += self._start_of('Package Description')
        else: str += self._start_of('Module Description')
            
        # The breadcrumbs & module  name
        #str += '<h3 class="module">%s</h3>' % self._breadcrumbs(uid)
        if uid.is_package():
            str += '<h2 class="package">Package '+uid.name()+'</h2>\n\n'
        else:
            str += '<h2 class="module">Module '+uid.name()+'</h2>\n\n'

        # Write the module's description.
        if doc.descr():
            str += self._dom_to_html(doc.descr(), uid) + '<hr/>\n'

        # Add the version, if available
        if doc.version():
            str += self._version(doc.version(), uid)

        # Add any author links.
        if doc.authors():
            str += self._author(doc.authors(), uid)

        # Add any requirements
        if doc.requires():
            str += self._requires(doc.requires(), uid)

        # Add any warnings
        if doc.warnings():
            str += self._warnings(doc.warnings(), uid)

        # Add any see-also links.
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # If it's a package, add a list of sub-modules.
        if doc.ispackage():
            str += self._module_list(doc.modules(), doc.sortorder())

        # Show the summaries for classes, exceptions, functions, and
        # variables contained in the module.
        (classes,excepts) = self._split_classes(doc.classes())
        (iclasses,iexcepts) = self._split_classes(doc.imported_classes())
        str += self._class_summary(classes, doc.sortorder(), 'Classes')
        str += self._class_summary(excepts, doc.sortorder(), 'Exceptions')
        str += self._func_summary(doc.functions(), doc.sortorder(), None)
        str += self._var_summary(doc.variables(), doc.sortorder(), uid)
        str += self._imports(iclasses, iexcepts, doc.imported_functions(),
                             doc.sortorder())

        # Show details for the functions and variables.
        str += self._func_details(doc.functions(), None)
        str += self._var_details(doc.variables(), uid)

        # Add another navigation bar and the footer.
        str += self._navbar(uid) + self._footer()
        
        return str

    def _class_to_html(self, uid):
        """
        @return: An HTML page describing the class identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the class that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation
        doc = self._docmap[uid]
        
        # Write the header & navigation bar.
        str = self._header(uid.name())
        str += self._navbar(uid, 1)
        str += self._start_of('Class Description')

        # The breadcrumbs & class name
        #str += '<h3 class="class">%s</h3>' % self._breadcrumbs(uid)
        str += '<h2 class="class">Class ' + uid.shortname()+'</h2>\n\n'

        # Write the base class tree
        if doc.bases():
            str += '<pre class="base-tree">\n' 
            str += self._base_tree(uid) 
            str += '</pre><br />\n\n'

        # Write the class's known subclasses
        if doc.subclasses():
            str += '<dl><dt><b>Known Subclasses:</b></dt>\n<dd>'
            for cls in doc.subclasses():
                str += '    '+self._link_to_html(cls) + ',\n'
            str = str[:-2] + '</dd></dl>\n\n'

        # Write the class's description
        if doc.descr():
            str += '<hr/>\n' + self._dom_to_html(doc.descr(), uid)
            str += '\n\n'
        str += '<hr/>\n\n'

        # Add the version, if available
        if doc.version():
            str += self._version(doc.version(), uid)

        # Add any author links.
        if doc.authors():
            str += self._author(doc.authors(), uid)

        # Add any requirements
        if doc.requires():
            str += self._requires(doc.requires(), uid)

        # Add any warnings
        if doc.warnings():
            str += self._warnings(doc.warnings(), uid)

        # Add any see-also links
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # Show the summaries for methods, instance variables, and
        # class variables contained in the class.
        allmethods = doc.methods()+doc.staticmethods()+doc.classmethods()
        str += self._func_summary(allmethods, doc.sortorder(),
                                  doc, 'Method Summary')
        str += self._var_summary(doc.ivariables(), doc.sortorder(),
                                 uid, 'Instance Variable Summary')
        str += self._var_summary(doc.cvariables(), doc.sortorder(),
                                 uid, 'Class Variable Summary')

        # Show details for methods and variables
        if doc.staticmethods() or doc.classmethods():
            str += self._func_details(doc.methods(), doc, 
                                      'Instance Method Details')
            str += self._func_details(doc.staticmethods(), doc, 
                                      'Static Method Details')
            str += self._func_details(doc.classmethods(), doc, 
                                      'Class Method Details')
        else:
            str += self._func_details(doc.methods(), doc, 
                                      'Method Details')
        str += self._var_details(doc.ivariables(), uid,
                                 'Instance Variable Details')
        str += self._var_details(doc.cvariables(), uid,
                                 'Class Variable Details')

        # Add a navigation bar and the footer.
        str += self._navbar(uid) + self._footer()
        
        return str

    def _trees_to_html(self):
        """
        @return: An HTML page containing the module and class
            hierarchies. 
        @rtype: C{string}
        """
        # Header and navigation bar
        str = self._header('Module and Class Hierarchies')
        str += self._navbar('trees', 1)

        # Module hierarchy
        str += self._start_of('Module Hierarchy')
        str += '<h2>Module Hierarchy</h2>\n'
        str += self._module_tree()

        # Does the project define any classes?
        defines_classes = 0
        for uid in self._docmap.keys():
            if uid.is_class(): defines_classes = 1; break

        # Class hierarchy
        if defines_classes:
            str += self._start_of('Class Hierarchy')
            str += '<h2>Class Hierarchy</h2>\n'
            str += self._class_tree()

        # Navigation bar and footer
        str += self._navbar('trees')
        str += self._footer()
        return str

    def _write_indices_to_stream(self, out):
        """
        Write the index to the given file-like object.  I write
        directly to the file (unlike most other pages, which are
        converted to strings, and then written) because the index page
        can be quite large.  For example, for the Python standard
        library, the index page is over 1.5mb.
        @param out: The stream to which the index should be written.
        @type out: C{stream}
        @rtype: C{None}
        """
        # Header and navigation bar.
        out.write(self._header('Index'))
        out.write(self._navbar('indices', 1))
        out.write('<br />\n')

        # Term index
        terms = self._extract_term_index().items()
        if terms:
            out.write(self._start_of('Term Index'))
            out.write(self._table_header('Term Index', 'index'))
            terms.sort()
            for (term, links) in terms:
                str = '  <tr><td width="15%">'+term+'</td>\n    <td>'
                links.sort()
                for link in links:
                    str += ('<i><a href="%s#%s">%s</a></i>, ' %
                            (self._uid_to_uri(link.target()),
                             self._term_index_to_anchor(term), link.name()))
                out.write(str[:-2] + '</tr></td>\n')
            out.write('</table>\n' +  '<br />\n')

        # Identifier index
        identifiers = self._extract_identifier_index()
        if identifiers:
            out.write(self._start_of('Identifier Index'))
            out.write(self._table_header('Identifier Index', 'index'))
            for uid in identifiers:
                href = self._uid_to_href(uid, uid.shortname())

                # Create the description string.
                if uid.is_package(): descr = 'Package'
                elif uid.is_module(): descr = 'Module'
                elif uid.is_class(): descr = 'Class'
                elif uid.is_variable(): descr = 'Variable'
                elif uid.is_method() or uid.is_builtin_method():
                    descr = 'Method'
                elif uid.is_function() or uid.is_builtin_function():
                    descr = 'Function'
                puid = uid.parent()
                if puid:
                    if puid.is_package(): descr +=' in package '
                    elif puid.is_module(): descr +=' in module '
                    elif puid.is_class(): descr +=' in class '
                    else: descr +=' in '
                    descr += self._uid_to_href(uid.parent())

                # Write the index entry.
                out.write('  <tr><td width="15%%">%s</td>\n' % href)
                out.write('    <td>%s</td></tr>\n' % descr)

            out.write('</table>\n' +  '<br />\n')

        # Navigation bar and footer.
        out.write(self._navbar('indices'))
        out.write(self._footer())

    def _toc_to_html(self):
        """
        @return: An HTML page containing the top-level table of
            contents page.  This page is used to select a module table
            of contents page, or the "everything" table of contents
            page. 
        @rtype: C{string}
        """
        uids = self._filtersort_uids(self._docmap.keys())

        # Header
        str = self._header('Table of Contents')
        str += ('<center><font size="+1"><b>Table&nbsp;of&nbsp;'
                 'Contents</b></font></center>\n<hr>\n')

        # Class table of contents (all classes/exceptions)
        str += ('<a target="moduleFrame" href="%s">%s</a><br />\n' %
                ('toc-everything.html', 'Everything'))

        # Package table of contents (individual packages)
        str += self._start_of('Packages')
        str += '<br /><font size="+1"><b>Packages</b></font><br />\n'
        for uid in uids:
            if uid.is_package():
                str += ('<a target="moduleFrame" href="toc-%s">'+
                        '%s</a><br />\n') % (self._uid_to_uri(uid), uid)

        # Module table of contents (individual modules)
        str += self._start_of('Modules')
        str += '<br /><font size="+1"><b>Modules</b></font><br />\n'
        for uid in uids:
            if uid.is_module() and not uid.is_package():
                str += ('<a target="moduleFrame" href="toc-%s">'+
                        '%s</a><br />\n') % (self._uid_to_uri(uid), uid)
                
        # The private/public link.
        str += '\n<br /><hr>\n'
        str += self._public_private_link('toc')
        
        return str + '\n</body>\n</html>\n'

    def _project_toc_to_html(self):
        """
        @return: An HTML page containing the table of contents page
            for the whole project.  This page lists the classes,
            exceptions, functions, and variables defined by any module
            or package in the project.
        @rtype: C{string}
        """
        # Header and name.
        str = self._header('Everything')
        str += ('<center><font size="+1"><b>Everything</b>' +
                 '</font></center>\n<hr>\n')

        # Find classes & exceptions
        classes = [Link(c.name(),c) for c in self._docmap.keys()
                   if c.is_class()]
        (classes,excepts) = self._split_classes(classes)

        # Find functions & variables
        funcs = []; vars = []
        for (uid, doc) in self._docmap.items():
            if isinstance(doc, ModuleDoc):
                funcs += doc.functions()
                vars += [(var,uid) for var in doc.variables()]
        
        # Class and excpetion lists.
        str += self._start_of('All Classes')
        str += self._toc_section('All&nbsp;Classes', classes)
        str += self._start_of('All Exceptions')
        str += self._toc_section('All&nbsp;Exceptions', excepts)
        str += self._start_of('All Functions')
        str += self._toc_section('All&nbsp;Functions', funcs)
        str += self._start_of('All Variables')
        str += self._toc_var_section('All&nbsp;Variables', vars)
        
        str += '\n<hr>\n'
        str += self._public_private_link('toc-everything')
        return str + '\n</body>\n</html>\n'

    def _module_toc_to_html(self, uid):
        """
        @return: An HTML page containing the table of contents page
            for the given module.  This page lists the modules,
            classes, exceptions, functions, and variables defined by
            the module. 
        @rtype: C{string}
        """
        doc = self._docmap[uid]
        (classes,excepts) = self._split_classes(doc.classes())
        vars = [(var,uid) for var in doc.variables()]

        # Header and name.
        str = self._header(uid.name())
        str += (('<center><font size="+1"><b><a target="mainFrame" '+
                'href="%s">%s</a></b></font></center>\n<hr>\n')
                % (self._uid_to_uri(uid), uid.shortname()))
        
        # Lists of modules, classes, exceptions, functions, and variables.
        if uid.is_package():
            str += self._toc_section('Modules', doc.modules())
        str += self._toc_section('Classes', classes)
        str += self._toc_section('Exceptions', excepts)
        str += self._toc_section('Functions', doc.functions())
        str += self._toc_var_section('Variables', vars)
                                 
        # The private/public link.
        str += '\n<hr>\n'
        str += self._public_private_link(uid, 1)
        return str + '\n</body>\n</html>\n'
    
    #////////////////////////////////////////////////////////////
    # Navigation bar
    #////////////////////////////////////////////////////////////
    # The navigation bar is placed at the top & bottom of every HTML
    # page.
    
    def _navbar(self, where=None, top=0):
        """
        @return: The HTML code for a navigation bar on the given type
            of page.  The navigation bar typically looks like::
            
                [ Package Module Class Tree Index Help ]
                
        @rtype: C{string}
        @param where: An identifier indicating what page we're
            creating a navigation bar for.  This is either a UID
            (for an object documentation page); or one of the strings
            C{'tree'}, C{'index'}, and C{'help'}.
        @type where: C{UID} or C{string}
        @param top: Whether this is the navigation bar at the top of
            the page.
        @type top: C{boolean}
        """
        str = self._start_of('Navbar')
        str += '<table class="navbar" border="0" width="100%"'
        str += ' cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">\n'
        str += '  <tr valign="center">\n'

        # The "Home" link
        if self._top_page in ('trees.html', 'indices.html',
                              'help.html'):
            pass # We already have a link for these.
        elif (isinstance(where, UID) and
            self._uid_to_uri(where) == self._top_page):
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Home&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;<a '
            str += 'class="navbar" href="%s">Home</a>' % self._top_page
            str += '&nbsp;&nbsp;&nbsp;</th>\n' 

        # The "Tree" link
        if where == 'trees':
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Trees&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="trees.html">Trees</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Index" link
        if where == 'indices':
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="indices.html">Index</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Help" link
        if where == 'help':
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Help&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="help.html">Help</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        if self._prj_link:
            str += '    <th class="navbar" align="right" width="100%">\n'
            str += '      <table border="0" cellpadding="0" cellspacing="0">\n'
            str += '      <tr><th class="navbar" align="center">\n'
            str += '        <p class="nomargin">\n          '
            str += self._prj_link
            str += '\n      </p></th></tr></table>\n'
            str += '    </th>\n'
        else:
            str += '    <th class="navbar" width="100%"></th>\n'
        str += '  </tr>\n</table>\n'

        # Breadcrumb, frames, and private/public link
        if top:
            str += '<table width="100%" cellpadding="0" cellspacing="0">\n'
            str += '  <tr valign="top">\n    <td width="100%">\n'
            if isinstance(where, UID): str += self._breadcrumbs(where)
            str += '    </td>\n    <td>'
            str += '<table cellpadding="0" cellspacing="0">\n'
            if self._create_private_docs:
                str += ('      <tr><td align="right">%s</td></tr>\n' %
                        self._public_private_link(where))
            str += ('      <tr><td align="right">%s</td></tr>\n' %
                    self._frames_link(where))
            str += '    </table></td>'
            str += '</tr></table>\n'
            
        return str

    def _frames_link(self, where):
        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        return ('<font size="-2">[<a href="frames.html"'+
                'target="_top">frames</a>&nbsp;|&nbsp;<a href="'+uri+
                '" target="_top">no&nbsp;frames</a>]</font>')
    
    def _public_private_link(self, where, toc=0):
        """
        @return: The HTML code for a link between the public & private
            copies of the documentation.
        @rtype: C{string}
        """
        # For private pages, there's no corresponding public page..
        if isinstance(where, UID) and where.is_private():
            return ('<font size="-2">[<b>show&nbsp;private</b>' +
                    '&nbsp;|&nbsp;hide&nbsp;private]</font>')

        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        if toc: uri = 'toc-'+uri
        
        if self._show_private:
            return ('<font size="-2">[show&nbsp;private&nbsp;|&nbsp;' +
                    '<a href="../public/' + uri + '">hide&nbsp;private' +
                    '</a>]</font>')
        else:
            return ('<font size="-2">[<a href="../private/' + uri +
                    '">show&nbsp;private</a>&nbsp;|&nbsp;hide&nbsp;' +
                    'private]</font>')
    
    #////////////////////////////////////////////////////////////
    # Base class trees
    #////////////////////////////////////////////////////////////
    
    def _find_tree_width(self, uid):
        """
        @return: The width of a base tree, when drawn
            right-justified.  This is used by L{_base_tree} to
            determine how far to indent lines of the base tree.
        @rtype: C{int}
        """
        width = 2
        if self._docmap.has_key(uid):
            for base in self._docmap[uid].bases():
                width = max(width, len(base.name())+4)
                width = max(width, self._find_tree_width(base.target())+4)

        return width
        
    def _base_tree(self, uid, width=None, postfix=''):
        """
        @return: The HTML code for a class's base tree.  The tree is
            drawn 'upside-down' and right justified, to allow for
            multiple inheritence.
        @rtype: C{string}
        """
        if not self._docmap.has_key(uid): return ''
        if width == None:
            width = self._find_tree_width(uid)
        
        bases = self._docmap[uid].bases()
        
        if postfix == '':
            str = ' '*(width-2) + '<b>'+uid.shortname()+'</b>\n'
        else: str = ''
        for i in range(len(bases)-1, -1, -1):
            base = bases[i]
            str = (' '*(width-4-len(base.name())) +
                   self._link_to_html(base)+' --+'+postfix+'\n' + 
                   ' '*(width-4) +
                   '   |'+postfix+'\n' +
                   str)
            (t,w) = (base.target(), width)
            if i != 0:
                str = (self._base_tree(t, w-4, '   |'+postfix)+str)
            else:
                str = (self._base_tree(t, w-4, '    '+postfix)+str)
        ss = re.sub('<[^<>]+>','',str)
        return str
                
    #////////////////////////////////////////////////////////////
    # Class hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _class_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_class_tree}.
        """
        if uid is not None:
            doc = self._docmap.get(uid, None)
            str = ' '*depth + '<li> <b>' + self._uid_to_href(uid)+'</b>'
            if doc and doc.descr():
                str += ': <i>' + self._summary(doc, uid.module()) + '</i>'
            str += '\n'
            if doc and doc.subclasses():
                str += ' '*depth + '  <ul>\n'
                children = [l.target() for l
                            in self._filtersort_links(doc.subclasses())]
                for child in children:
                    str += self._class_tree_item(child, depth+4)
                str += ' '*depth + '  </ul>\n'
        return str

    def _class_tree(self, sortorder=None):
        """
        @return: The HTML code for the class hierarchy tree.  This is
            used by L{_trees_to_html} to construct the hierarchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        uids = self._filtersort_uids(self._docmap.keys())
        #docs.sort(lambda a,b: cmp(a[0], b[0]))
        for uid in uids:
            doc = self._docmap[uid]
            if not isinstance(doc, ClassDoc): continue
            hasbase = 0
            for base in doc.bases():
                if self._docmap.has_key(base.target()):
                    hasbase = 1
            if not hasbase:
                str += self._class_tree_item(uid)
        return str +'</ul>\n'

    #////////////////////////////////////////////////////////////
    # Module hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _module_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_module_tree} and L{_module_list}.
        
        @rtype: C{string}
        """
        if uid is None: return ''

        doc = self._docmap.get(uid, None)
        name = uid.shortname()
        str = ' '*depth + '<li> <b>'
        str += self._uid_to_href(uid, name)+'</b>'
        if doc and doc.descr():
            str += ': <i>' + self._summary(doc, uid) + '</i>'
        str += '\n'
        if doc and doc.ispackage() and doc.modules():
            str += ' '*depth + '  <ul>\n'
            modules = [l.target() for l in 
                       self._filtersort_links(doc.modules(), doc.sortorder())]
            for module in modules:
                str += self._module_tree_item(module, depth+4)
            str += ' '*depth + '  </ul>\n'
        str += ' '*depth+'</li>'
        return str

    def _module_tree(self, sortorder=None):
        """
        @return: The HTML code for the module hierarchy tree.  This is
            used by L{_trees_to_html} to construct the hiearchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        uids = self._filtersort_uids(self._docmap.keys())
        #docs.sort(lambda a,b: cmp(a[0], b[0]))
        # Find all top-level packages. (what about top-level
        # modules?)
        for uid in uids:
            doc = self._docmap[uid]
            if not isinstance(doc, ModuleDoc): continue
            if not doc.package():
                str += self._module_tree_item(uid)
        return str +'</ul>\n'

    def _module_list(self, modules, sortorder):
        """
        @return: The HTML code for the module hierarchy tree,
            containing the given modules.  This is used by
            L{_module_to_html} to list the submodules of a package.
        @rtype: C{string}
        """
        if len(modules) == 0: return ''
        str = '<h3>Modules</h3>\n<ul>\n'
        modules = self._filtersort_links(modules, sortorder)
        
        for link in modules:
            str += self._module_tree_item(link.target())
        return str + '</ul>\n'

    #////////////////////////////////////////////////////////////
    # Class tables
    #////////////////////////////////////////////////////////////
    
    def _class_summary(self, classes, sortorder, heading='Class Summary'):
        """
        @return: The HTML code for the class summary table.  This is
            used by L{_module_to_html} to list the classes in a
            module.
        @rtype: C{string}
        """
        classes = self._filtersort_links(classes, sortorder)
        if len(classes) == 0: return ''
        str = self._table_header(heading, 'summary')

        for link in classes:
            cname = link.name()
            cls = link.target()
            if not self._docmap.has_key(cls): continue
            cdoc = self._docmap[cls]
            csum = self._summary(cdoc, cls.module())
            str += '<tr><td width="15%">\n'
            str += '  <b>'+self._link_to_html(link)
            str += '</b></td>\n  <td>' + csum + '</td></tr>\n'
        return str + '</table><br />\n\n'

    #////////////////////////////////////////////////////////////
    # Function tables
    #////////////////////////////////////////////////////////////
    
    def _func_summary(self, functions, sortorder, cls,
                      heading='Function Summary'):
        """
        @return: The HTML code for a function summary table.  This
            is used by L{_module_to_html} to list the functions in a
            module; and by L{_class_to_html} to list member
            functions. 
        @rtype: C{string}
        """
        functions = self._filtersort_links(functions, sortorder)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'summary')

        for link in functions:
            func = link.target()
            fname = link.name()
            if func.is_method() or func.is_builtin_method():
                container = func.cls()
                # (If container==ClassType, it's (probably) a class method.)
                inherit = (container != cls.uid() and
                           container.value() is not types.ClassType)
            else:
                inherit = 0
                try: container = func.module()
                except TypeError: container = None

            # If we don't have documentation for the function, then we
            # can't say anything about it.
            if not self._docmap.has_key(func): continue
            fdoc = self._docmap[func]
            
            # Try to find a documented ancestor.
            while (not fdoc.documented() and fdoc.overrides() and
                   self._docmap.has_key(fdoc.overrides())):
                fdoc = self._docmap[fdoc.overrides()]

            rval = fdoc.returns()
            if rval.type():
                rtype = self._dom_to_html(rval.type(), container, 8)
            else:
                rtype = '&nbsp;'

            descrstr = self._summary(fdoc, container)
            if descrstr != '&nbsp;':
                fsum = '<br />'+descrstr
            else:
                if inherit: fsum = '<br />\n'
                else: fsum = ''
            if inherit:
                fsum += ('    <i>(inherited from %s)</i>\n' %
                         self._uid_to_href(container, container.shortname()))
            #if not fdoc.documented():
            #    fsum = '    <br /><i>(undocumented)</i>\n'
            str += '<tr><td align="right" valign="top" width="15%">'
            str += '<font size="-1">'+rtype+'</font></td>\n  <td><code>'
            if fdoc.documented() or inherit:
                str += self._func_signature(fname, fdoc, 1, 0, 'summary-sig')
            else:
                str += '<a name="%s"></a>' % fname
                str += self._func_signature(fname, fdoc, 0, 0, 'summary-sig')
            str += '</code>\n' + fsum + '</td></tr>\n'
        return str + '</table><br />\n\n'

    def _func_details(self, functions, cls, heading='Function Details'):
        """
        @return: The HTML code for a function details table.  This
            is used by L{_module_to_html} to describe the functions in
            a module; and by L{_class_to_html} to describe member
            functions.
        @rtype: C{string}
        """
        functions = self._filtersort_links(functions)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'

        numfuncs = 0
        for link in functions:
            fname = link.name()
            func = link.target()
            if func.is_method() or func.is_builtin_method():
                container = func.cls()
                # (If container==ClassType, it's (probably) a class method.)
                inherit = (container != cls.uid() and
                           container.value() is not types.ClassType)
            else:
                inherit = 0
                try: container = func.module()
                except TypeError: container = None
            if not self._docmap.has_key(func):
                continue

            # Don't document inherited methods; instead, the method
            # summary points to the details description in the parent
            # class's file.
            if inherit: continue
            
            # If we don't have documentation for the function, then we
            # can't say anything about it.
            if not self._docmap.has_key(func): continue
            fdoc = self._docmap[func]

            # What does this method override?
            foverrides = fdoc.overrides()

            # Try to find a documented ancestor.
            inhdoc = fdoc
            inherit_docs = 0
            while (not inhdoc.documented() and inhdoc.overrides() and
                   self._docmap.has_key(inhdoc.overrides())):
                inherit_docs = 1
                inhdoc = self._docmap[inhdoc.overrides()]

            # If we couldn't find a documented ancestor, then we don't
            # have anything else to say.
            if not inhdoc.documented(): continue

            numfuncs += 1
            str += '\n<a name="'+fname+'"></a>\n'
            str += '<table width="100%" class="func-details"'
            str += ' bgcolor="#e0e0e0"><tr><td>\n'

            #if SPECIAL_METHODS.has_key(fname):
            #    str += '  <h3 class="func-details"><i>'
            #    str += SPECIAL_METHODS[fname]+'</i></h3>\n'
            #else:
            #    str += '  <h3 class="func-details">'+fname+'</h3>\n'
            #str += '  <p>%s</p>\n' % self._func_signature(fname, fdoc)

            str += '  <h3>%s\n' % self._func_signature(fname, fdoc)
            if SPECIAL_METHODS.has_key(fname):
                str += '    <br /><i>'
                str += '(%s)</i>\n' % SPECIAL_METHODS[fname]
            str += '  </h3>\n'

            # Use the inherited docs for everything but the signature.
            fdoc = inhdoc

            fdescr=fdoc.descr()
            fparam = fdoc.parameter_list()[:]
            if fdoc.vararg(): fparam.append(fdoc.vararg())
            if fdoc.kwarg(): fparam.append(fdoc.kwarg())
            freturn = fdoc.returns()
            fraises = fdoc.raises()
            
            # Don't list parameters that don't have any extra info.
            f = lambda p:p.descr() or p.type()
            fparam = filter(f, fparam)

            # Description
            if fdescr:
                str += self._dom_to_html(fdescr, container, 2)
            str += '  <dl><dt></dt><dd>\n'

            # Parameters
            if fparam:
                str += '    <dl><dt><b>Parameters:</b></dt>\n'
                for param in fparam:
                    pname = param.name()
                    str += '      <dd><code><b>' + pname +'</b></code>'
                    if param.descr():
                        pdescr = self._dom_to_html(param.descr(), container, 8)
                        str += ' -\n %s' % pdescr.rstrip()
                    str += '\n'
                    if param.type():
                        ptype = self._dom_to_html(param.type(), container, 14)
                        str += '        <br /><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % ptype.strip()
                    str += '      </dd>\n'
                str += '    </dl>\n'

            # Returns
            if freturn.descr() or freturn.type():
                str += '    <dl><dt><b>Returns:</b></dt>\n      <dd>\n'
                if freturn.descr():
                    str += self._dom_to_html(freturn.descr(), container, 8)
                    if freturn.type():
                        rtype = self._dom_to_html(freturn.type(),container,14)
                        str += '        <br /><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % rtype.strip()
                elif freturn.type():
                    str += self._dom_to_html(freturn.type(), container, 8)
                str += '      </dd>\n    </dl>\n'

            # Raises
            if fraises:
                str += '    <dl><dt><b>Raises:</b></dt>\n'
                for fraise in fraises:
                    str += '      '
                    str += '<dd><code><b>'+fraise.name()+'</b></code> -\n'
                    str += self._dom_to_html(fraise.descr(), container, 8)
                    str +'      </dd>\n'
                str += '    </dl>\n'

            # Overrides
            if foverrides:
                str += '    <dl><dt><b>Overrides:</b></dt>\n'
                str += '      <dd>'+self._uid_to_href(foverrides)
                if inherit_docs:
                    str += ' <i>(inherited documentation)</i>\n'
                str += '</dd>\n    </dl>\n'

            # Version
            if fdoc.version():
                str += self._version(fdoc.version(), func.parent())

            # Author
            if fdoc.authors():
                str += self._author(fdoc.authors(), func.parent())

            # Requirements
            if fdoc.requires():
                str += self._requires(fdoc.requires(), func.parent())
                    
            # Warnings
            if fdoc.warnings():
                str += self._warnings(fdoc.warnings(), func.parent())

            # See also
            if fdoc.seealsos():
                str += self._seealso(fdoc.seealsos(), func.parent())

            str += '  </dd></dl>\n'
            str += '</td></tr></table>\n'

        if numfuncs == 0: return ''

        str += '<br />\n\n'
        return str

    def _func_signature(self, fname, fdoc, link=0, show_defaults=1,
                        css_class="sig"):
        """
        @return: The HTML code for the function signature of the
            function with the given name and documentation.
        @param fname: The short name of the function.
        @type fname: C{string}
        @param fdoc: The documentation for the function.
        @type fdoc: L{objdoc.FuncDoc}
        @param link: Whether to create a link from the function's name
            to its details description.
        """
        str = '<span class=%s>' % css_class
        if link: str += self._uid_to_href(fdoc.uid(), fname, css_class+'-name')
        else: str += '<span class=%s-name>%s</span>' % (css_class, fname)
        
        PARAM_JOIN = ',\n'+' '*15
        str += '('
        str += self._params_to_html(fdoc.parameters(), css_class,
                                    show_defaults)
        if fdoc.vararg():
            vararg_name = fdoc.vararg().name()
            if vararg_name != '...': vararg_name = '*%s' % vararg_name
            str += ('<span class=%s-vararg>%s</span>%s' %
                    (css_class, vararg_name, PARAM_JOIN))
        if fdoc.kwarg():
            str += ('<span class=%s-kwarg>**%s</span>%s' %
                    (css_class, fdoc.kwarg().name(), PARAM_JOIN))
        if str[-1] != '(': str = str[:-len(PARAM_JOIN)]

        return str + ')</span>'

    def _params_to_html(self, parameters, css_class, show_defaults):
        PARAM_JOIN = ',\n'+' '*15
        str = ''
        for param in parameters:
            if type(param) in (type([]), type(())):
                sublist = self._params_to_html(param, css_class,
                                               show_defaults)
                str += '(%s), ' % sublist[:-len(PARAM_JOIN)]
            else:
                str += ('<span class=%s-arg>%s</span>' %
                        (css_class, param.name()))
                if show_defaults and param.default() is not None:
                    default = param.default()
                    default = re.sub('&', '&amp;', default)
                    default = re.sub('<', '&lt;', default)
                    default = re.sub('>', '&gt;', default)
                    default = re.sub(' ', '&nbsp;', default)
                    if len(default) > 60:
                        default = default[:57]+'...'
                    str += ('=<span class=%s-default>%s</span>' %
                            (css_class, default))
                str += PARAM_JOIN
        return str

    #////////////////////////////////////////////////////////////
    # Variable tables
    #////////////////////////////////////////////////////////////
    
    def _var_summary(self, variables, sortorder, container,
                     heading='Variable Summary'):
        """
        @return: The HTML code for a variable summary table.  This
            is used by L{_module_to_html} to list the variables in a
            module; and by L{_class_to_html} to list instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._filtersort_vars(variables, sortorder)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'summary')

        for var in variables:
            vname = var.name()
            if var.type():
                vtype = self._dom_to_html(var.type(), container, 10).strip()
            else: vtype = '&nbsp;'
            if var.descr():
                vsum = ' - ' +self._summary(var, container)
            else: vsum = ''
            str += '<tr><td align="right" valign="top" '
            str += 'width="15%"><font size="-1">'+vtype+'</font></td>\n'
            str += '  <td><code><b>'

            # If we don't have any info about it, then just list it in
            # the summary (not the details).
            if (var.descr() is None and var.type() is None and
                not var.has_value()): 
                str += '<a name="%s">%s</a>' % (vname, vname)
            else:
                str += '<a href="#%s">%s</a>' % (vname, vname)
            str += '</b></code>\n  ' + vsum + '</td></tr>\n'
        return str + '</table><br />\n\n'

    def _var_details(self, variables, container, heading='Variable Details'):
        """
        @return: The HTML code for a variable details table.  This
            is used by L{_module_to_html} to describe the variables in
            a module; and by L{_class_to_html} to describe instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._filtersort_vars(variables)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>'

        numvars = 0
        for var in variables:
            # Don't bother if we don't know anything about it.
            if (var.descr() is None and var.type() is None and
                not var.has_value()): continue
            numvars += 1
            
            str += ('<table width="100%" class="var-details"'+
                    ' bgcolor="#e0e0e0">'+
                    '<tr><td>\n')
            
            vname = var.name()
            vtyp = var.type()
            hasval = var.has_value()

            str += '<a name="'+vname+'"></a>\n'
            str += '<h3>'+vname+'</h3>\n'

            # If it's a module, class, method, type, or func, then
            # just link to it.
            if not var.uid().is_variable():
                str += ('<code>%s</code> = %s\n' %
                        (vname, self._uid_to_href(var.uid())))
                if self._documented(var.uid()):
                    str += '</td></tr></table>\n'
                    continue

            if var.descr():
                str += self._dom_to_html(var.descr(), container)
                
            if vtyp is not None or hasval:
                str += '<dl>\n  <dt></dt>\n  <dd>\n    <dl>\n'
                
            if vtyp:
                str += '      <dt><b>Type:</b></dt>\n      <dd>\n' 
                str += self._dom_to_html(vtyp, container)
                str += '\n      </dd>\n'

            str += self._pprint_var_value(var)

            if vtyp is not None or hasval:
                str += '    </dl>\n  </dd>\n</dl>'
                
            str += '</td></tr></table>\n'

        # If we didn't get any variables, don't print anything.
        if numvars == 0: return ''
        return str+'<br />'

    def _pprint_var_value(self, var):
        if not var.has_value(): return ''
        val = var.uid().value()
        linelen = self._variable_linelen
        do_quoting = 1
        
        # For regexps, use colorize_re.
        if type(val).__name__ == 'SRE_Pattern':
            val = colorize_re(val)
            do_quoting = 0
            
        # For strings, use repr.  Use tripple-quoted-strings where
        # appropriate.
        elif type(val) is type(''):
            val = `val`
            val = re.sub('&', '&amp;', val)
            val = re.sub('<', '&lt;', val)
            val = re.sub('>', '&gt;', val)
            do_quoting = 0
            if val.find(r'\n') >= 0:
                val = ('<span class="variable-quote">'+val[0]*3+'</span>'+
                        val[1:-1].replace(r'\n', '\n') +
                       '<span class="variable-quote">'+val[0]*3+'</span>')
                       
            else:
                val = ('<span class="variable-quote">'+val[0]+'</span>'+
                       val[1:-1]+
                       '<span class="variable-quote">'+val[0]+'</span>')

        # For lists, tuples, and dicts, use pprint.
        elif type(val) in (type(()), type([]), type({})):
            val = pprint.pformat(val)

        # For other objects, use repr to generate a representation.
        else:
            try: val = `val`
            except: val = '...'

        # Quote characters, where appropriate.
        if do_quoting:
            val = re.sub('&', '&amp;', val)
            val = re.sub('<', '&lt;', val)
            val = re.sub('>', '&gt;', val)

        # Do line-wrapping.
        val = self._linewrap_html(val)

        # Construct the value box.
        str = '      <dt><b>Value:</b></dt>\n' 
        str += '      <dd><table><tr><td>\n'
        str += '<pre class="variable">\n%s</pre>\n' % val
        str += '        </td></tr></table></dd>\n'
        return str

    def _linewrap_html(self, str):
        """
        Add line-wrapping to the HTML string C{str}.  Line length is
        determined by L{_variable_linelen}; and the maximum number of
        lines to display is determined by L{_variable_maxlines}.  This
        function treats HTML entities (e.g., C{&amp;}) as single
        characters; and ignores HTML tags (e.g., C{<p>}).
        """
        LINEWRAP_MARKER = r'<span class="variable-linewrap">\</span>'
        ELLIPSIS_MARKER = r'<span class="variable-ellipsis">...</span>'
        
        maxlines = self._variable_maxlines
        linelen = self._variable_linelen
        
        lines = []
        start = end = cnum = 0
        while len(lines) <= maxlines and end < len(str):
            # Skip over HTML tags.
            if str[end] == '<':
                while end<len(str) and str[end] != '>': end += 1
                cnum -= 1

            # HTML entities just count as 1 char.
            elif str[end] == '&':
                while end<len(str) and str[end] != ';': end += 1

            # Go on to the next character.
            cnum += 1
            end += 1

            # Check for end-of-line.
            if str[end-1] == '\n':
                lines.append(str[start:end-1])
                cnum = 0
                start = end

            # Check for line-wrap
            if cnum == linelen and end<len(str) and str[end] != '\n':
                lines.append(str[start:end]+LINEWRAP_MARKER)
                cnum = 0
                start = end

        # Add on anything that's left.
        if end == len(str):
            lines.append(str[start:end])

        # Use the ellipsis marker if the string is too long.
        if len(lines) > maxlines:
            lines[-1] = ELLIPSIS_MARKER
            cnum = 3

        # Pad the last line to linelen.
        lines[-1] += ' '*(linelen-cnum+1)

        return ('\n').join(lines)
            
    #////////////////////////////////////////////////////////////
    # Term index generation
    #////////////////////////////////////////////////////////////
    
    def _get_term_index_items(self, tree, link, dict):
        """
        @param dict: in/out parameter. 
        @rtype: C{None}
        """
        if isinstance(tree, xml.dom.minidom.Text): return
        if isinstance(tree, xml.dom.minidom.Document):
            self._get_term_index_items(tree.childNodes[0], link, dict)
            return
        if tree is None: return
        elif tree.tagName != 'indexed':
            # Look for index items in the child nodes.
            for child in tree.childNodes:
                self._get_term_index_items(child, link, dict)
        else:
            # We found an index item.
            children = [self._dom_to_html(c) for c in tree.childNodes]
            key = ''.join(children).lower().strip()
            if dict.has_key(key):
                dict[key].append(link)
            else:
                dict[key] = [link]

    def _extract_term_index(self):
        """
        @return: A dictionary mapping from terms to lists of source
            documents.
        @rtype: C{dictionary}
        """
        index = {}
        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            
            if uid.is_function():
                link = Link(uid.name(), uid.module())
            elif uid.is_method():
                link = Link(uid.name(), uid.cls())
            else:
                link = Link(uid.name(), uid)

            # Get index items from standard fields.
            self._get_term_index_items(doc.descr(), link, index)
            for see in doc.seealsos():
                self._get_term_index_items(see, link, index)
            if doc.version() is not None: 
                self._get_term_index_items(doc.version(), link, index)
            for author in doc.authors():
                self._get_term_index_items(author, link, index)
            for require in doc.requires():
                self._get_term_index_items(require, link, index)
            for warn in doc.warnings():
                self._get_term_index_items(warn, link, index)

            # Get index items from object-specific fields.
            if isinstance(doc, ModuleDoc):
                for var in doc.variables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_term_index_items(var.descr(), link, index)
                    self._get_term_index_items(var.type(), link, index)
            elif isinstance(doc, ClassDoc):
                for var in doc.ivariables() + doc.cvariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_term_index_items(var.descr(), link, index)
                    self._get_term_index_items(var.type(), link, index)
            elif isinstance(doc, FuncDoc):
                extra_p = [v for v in [doc.vararg(), doc.kwarg(),
                                       doc.returns()] if v is not None]
                for param in doc.parameter_list()+extra_p:
                    self._get_term_index_items(param.descr(), link, index)
                    self._get_term_index_items(param.type(), link, index)
                for fraise in doc.raises():
                    self._get_term_index_items(fraise.descr(), link, index)
                    
        return index

    #////////////////////////////////////////////////////////////
    # Identifier index generation
    #////////////////////////////////////////////////////////////

    def _extract_identifier_index(self):
        """
        @rtype: C{list} of C{(string, string)}
        """
        # List of (sort-key, UID), where sort-key is
        # uid.shortname().lower().
        uids = []

        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            
            uids.append( (uid.shortname().lower(), uid) )
            if uid.is_module():
                uids += [(v.name().lower(), v.uid())
                         for v in doc.variables()
                         if not v.uid().is_private()]
            elif uid.is_class():
                uids += [(v.name().lower(), v.uid())
                         for v in doc.ivariables() + doc.cvariables()
                         if not v.uid().is_private()]

        uids.sort()
        return [u[1] for u in uids]

        # list of (name, href, descr) tripples
        identifiers = []
        
        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            if uid.is_module():
                # Add the module to the index.
                if uid.is_package() and uid.package():
                    descr = 'Subpackage in package '
                    descr += self._uid_to_href(uid.package())
                elif uid.package():
                    descr = 'Module in package '
                    descr += self._uid_to_href(uid.package())
                else: descr = 'Module'
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add all of the module's variables to the index.
                descr = ' Variable in module %s' % self._uid_to_href(uid)
                for var in doc.variables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )
                    
            elif uid.is_class():
                # Add the class to the index.
                descr = ('Class in module %s' %
                         self._uid_to_href(uid.module()))
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add all the class variables to the index.
                descr = ('Class variable in class %s' %
                         self._uid_to_href(uid))
                for var in doc.cvariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )

                # Add all the instance variables to the index.
                descr = ('Instance variable in class %s' %
                         self._uid_to_href(uid))
                for var in doc.ivariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )

            elif uid.is_routine():
                # Add the function/method to the index.
                if uid.is_function() or uid.is_builtin_function():
                    descr = ('Function in module %s' %
                             self._uid_to_href(uid.module()))
                else:
                    descr = ('Method in class %s' %
                             self._uid_to_href(uid.cls()))
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add the parameters to the index.
                if self._index_parameters:
                    if uid.is_function() or uid.is_builtin_function():
                        descr = 'Parameter to function '
                        dsecr += self._uid_to_href(uid)
                    else:
                        descr = 'Parameter to method '
                        dsecr += self._uid_to_href(uid)
                    extra_p = [v for v in [doc.vararg(), doc.kwarg()]
                               if v is not None]
                    for var in doc.parameter_list()+extra_p:
                        href = self._uid_to_href(uid, var.name())
                        identifiers.append( (var.name(), href, descr) )
            else:
                raise AssertionError, 'fix me'

        identifiers.sort(lambda a,b: cmp(a[0].lower(),b[0].lower()))
        return [id[1:3] for id in identifiers]

    #////////////////////////////////////////////////////////////
    # Table of contents (frames) generation
    #////////////////////////////////////////////////////////////

    def _toc_section(self, section, links):
        # Sort & filter the links
        if not self._show_private:
            links = [o for o in links if not o.target().is_private()]
        links.sort(lambda x,y: cmp(x.name().lower(), y.name().lower()))

        if not links: return ''
        str = self._start_of(section)
        str += '<font size="+1"><b>%s</b></font><br />\n' % section
        for link in links:
            str += ('<a target="mainFrame" href="%s">%s</a><br />\n' %
                    (self._uid_to_uri(link.target()), link.name()))
        return str+'<br />\n'

    def _toc_var_section(self, section, vars):
        # Sort & filter the vars.
        if not self._show_private:
            vars = [o for o in vars if not o[0].uid().is_private()]
        vars.sort(lambda (v1,u1),(v2,u2): cmp(v1.name().lower(),
                                              v2.name().lower()))

        if not vars: return ''
        str = self._start_of(section)
        str += '<font size="+1"><b>%s</b></font><br />\n' % section
        for var in vars:
            str += ('<a target="mainFrame" href="%s#%s">%s</a><br />\n' %
                    (self._uid_to_uri(var[1]), var[0].name(), 
                     var[0].name()))
        return str+'<br />\n'

    #////////////////////////////////////////////////////////////
    # Docstring -> HTML Conversion
    #////////////////////////////////////////////////////////////

    def _term_index_to_anchor(self, str):
        """
        Given the name of an inline index item, construct a URI anchor.
        These anchors are used to create links from the index page to each
        index item.
        """
        # Include "-" so we don't accidentally collide with the name
        # of a python identifier. 
        return "index-"+re.sub("[^a-zA-Z0-9]", "_", str)
    
    def _dom_to_html(self, tree, container=None, indent=0):
        """
        Given the DOM document for an epytext string (as returned by
        L{epytext.parse}), return a string encoding it in HTML.  This
        string does not include C{<html>} or C{<body>} tags.
    
        @param tree: The DOM document for an epytext string.
        @type tree: C{xml.dom.minidom.Document}
        @param container: The container in which to look up objects by name
            (e.g., for link directives).
        @type container: Python module
        """
        if isinstance(tree, xml.dom.minidom.Document):
            tree = tree.childNodes[0]
        if not self._epytext_cache.has_key( (tree, container) ):
            html = self._dom_to_html_helper(tree, container, indent, 0)
            self._epytext_cache[tree, container] = html
        return self._epytext_cache[tree,container]
    
    def _dom_to_html_helper(self, tree, container, indent, seclevel):
        """
        Helper function for L{_dom_to_html}, that does the real work of
        converting a DOM tree for an epytext string to HTML.
    
        @param tree: The DOM tree for an epytext string.
        @type tree: L{xml.dom.minidom.Element}
        @param container: The container in which to look up objects by name
            (e.g., for link directives).
        @type container: Python module
        @param indent: The number of characters indentation that should be
            used for HTML tags.
        @type indent: C{int}
        @param seclevel: The current section level.
        @type seclevel: int
        """
        # This takes care of converting > to &gt;, etc.:
        if isinstance(tree, xml.dom.minidom.Text): return tree.toxml()

        if tree.tagName == 'epytext': indent -= 2
        if tree.tagName == 'section': seclevel += 1
    
        # Process the children first.
        children = [self._dom_to_html_helper(c, container, indent+2, seclevel)
                    for c in tree.childNodes]
    
        # Get rid of unnecessary <P>...</P> tags; they introduce extra
        # space on most browsers that we don't want.
        for i in range(len(children)-1):
            if (not isinstance(tree.childNodes[i], xml.dom.minidom.Text) and
                tree.childNodes[i].tagName == 'para' and
                (isinstance(tree.childNodes[i+1], xml.dom.minidom.Text) or
                 tree.childNodes[i+1].tagName != 'para')):
                children[i] = ' '*(indent+2)+children[i][5+indent:-5]+'\n'
        if (tree.hasChildNodes() and
            not isinstance(tree.childNodes[-1], xml.dom.minidom.Text) and
            tree.childNodes[-1].tagName == 'para'):
            children[-1] = ' '*(indent+2)+children[-1][5+indent:-5]+'\n'
    
        # Construct the HTML string for the children.
        childstr = ''.join(children)
    
        # Perform the approriate action for the DOM tree type.
        if tree.tagName == 'para':
            return epytext.wordwrap('<p>%s</p>' % childstr, indent)
        elif tree.tagName == 'code':
            return '<code>%s</code>' % childstr
        elif tree.tagName == 'uri':
            return '<a href="%s">%s</a>' % (children[1], children[0])
        elif tree.tagName == 'link':
            return self._dom_link_to_html(children[1], children[0],
                                          container)
        elif tree.tagName == 'italic':
            return '<i>%s</i>' % childstr
        elif tree.tagName == 'math':
            return '<i class="math">%s</i>' % childstr
        elif tree.tagName == 'indexed':
            return ('<a name="%s"></a><i class="indexterm">%s</i>' %
                    (self._term_index_to_anchor(childstr), childstr))
        elif tree.tagName == 'bold':
            return '<b>%s</b>' % childstr
        elif tree.tagName == 'ulist':
            return '%s<ul>\n%s%s</ul>\n' % (indent*' ', childstr, indent*' ')
        elif tree.tagName == 'olist':
            startAttr = tree.getAttributeNode('start')
            if startAttr: start = ' start="%s"' % startAttr.value
            else: start = ''
            return ('%s<ol%s>\n%s%s</ol>\n' %
                    (indent*' ', start, childstr, indent*' '))
        elif tree.tagName == 'li':
            return indent*' '+'<li>\n%s%s</li>\n' % (childstr, indent*' ')
        elif tree.tagName == 'heading':
            return ('%s<h%s class="heading">%s</h%s>\n' %
                    ((indent-2)*' ', seclevel, childstr, seclevel))
        elif tree.tagName == 'literalblock':
            return '<pre class="literalblock">\n%s\n</pre>\n' % childstr
        elif tree.tagName == 'doctestblock':
            dtb = colorize_doctestblock(childstr.strip())
            return '<pre class="doctestblock">\n%s</pre>\n' % dtb
        elif tree.tagName == 'fieldlist':
            raise AssertionError("There should not be any field lists left")
        elif tree.tagName in ('epytext', 'section', 'tag', 'arg',
                              'name', 'target'):
            return childstr
        else:
            raise ValueError('Unknown epytext DOM element %r' % tree.tagName)
    
    def _dom_link_to_html(self, target, name, container):
        uid = findUID(target, container, self._docmap)
        if uid is None:
            if sys.stderr.softspace: print >>sys.stderr
            print >>sys.stderr, ('Warning: could not find UID for '+
                                 'L{%s} in %s' % (target, container))
        return self._uid_to_href(uid, name, 'link')
    
    #////////////////////////////////////////////////////////////
    # Helper functions
    #////////////////////////////////////////////////////////////
    
    def _is_private(self, str):
        """
        @return: true if C{str} is the name of a private Python object.
        @rtype: C{boolean}
        """
        if str == '...': return 0
        for piece in str.split('.'):
            if piece[:1] == '_' and piece[-1:] != '_': return 1
        return 0

    def _breadcrumbs(self, uid):
        """
        @return: The HTML code for a series of links to the parents of
            C{uid}.
        @rtype: C{string}
        """
        #if not uid.parent(): return '</br>\n'
        if uid.is_package(): crumbs = ['Package&nbsp;%s' % uid.shortname()]
        elif uid.is_module(): crumbs = ['Module&nbsp;%s' % uid.shortname()]
        elif uid.is_class(): crumbs = ['Class&nbsp;%s' % uid.shortname()]
        uid = uid.parent()
        while uid is not None:
            if uid.is_package(): label = 'Package&nbsp;%s' % uid.shortname()
            elif uid.is_module(): label = 'Module&nbsp;%s' % uid.shortname()
            elif uid.is_class(): label = 'Class&nbsp;%s' % uid.shortname()
            else: raise ValueError('Bad uid type for breadcrumbs')
            crumbs.append(self._uid_to_href(uid, label, code=0))
            uid = uid.parent()
        crumbs.reverse()
        # PICK A BETTER CLASS NAME!!
        str = '<font size="-1"><b class="breadcrumbs">\n  '
        str += ' ::\n  '.join(crumbs)
        str += '</b></font></br>\n'
        return str

    def _find_top_page(self, pagename):
        """
        Find the top page for the API documentation.  This page is
        used as the default page shown in the main frame, when frames
        are used.  When frames are not used, a redirect page is
        created from C{index.html} to the top page.

        @param pagename: The name of the page, as specified by the
            keyword argument C{top} to the constructor.
        @type pagename: C{string}
        @return: The URL of the top page.
        @rtype: C{string}
        """
        # If the top_page is unspecified, find an appropriate page.
        if not pagename:
            top = self._find_toplevel()
            if top: return self._uid_to_uri(top)
            else: return 'trees.html'

        # If it's a URL, then use it directly.
        if pagename.startswith('http:'):
            return pagename

        # Look for it in the docmap.
        for uid in self._docmap.keys():
            if pagename == uid.name():
                if uid.is_module() or uid.is_class():
                    return self._uid_to_uri(uid)
                else:
                    estr = ('Warning: Specified top page object %s' % uid
                            + ' is not a module\n         or a class.')
                    if sys.stderr.softspace: print >>sys.stderr
                    print >>sys.stderr, estr
                    return self._find_top_page(None)
                
        # Try importing it as a module.
        try:
            uid = make_uid(import_module(pagename))
            if self._docmap.has_key(uid):
                return self._uid_to_uri(uid)
            else:
                estr = ('Warning: Specified top page object %s' % uid
                        + ' is not documented.')
                if sys.stderr.softspace: print >>sys.stderr
                print >>sys.stderr, estr
                return self._find_top_page(None)
        except: pass

        # Is it a special page name?  Note that these could, in
        # principle, be shadowed by modules or classes named "html"
        # contained in packages named "index" etc.
        if pagename in ('indices.html', 'help.html',
                        'trees.html'):
            return pagename

        # We didn't find anything.
        estr = ('Warning: Unable to find the specified top_page %s.'
                % pagename)
        if sys.stderr.softspace: print >>sys.stderr
        print >>sys.stderr, estr
        return self._find_top_page(None)
    
    def _find_toplevel(self):
        """
        @return: The UID of the top-level module or package, or

            C{None} if there is no top-level module or package.
        @rtype: L{UID} or C{None}
        """
        modules = []
        packages = []
        for (uid, doc) in self._docmap.items():
            if not isinstance(doc, ModuleDoc): continue
            modules.append(uid)
            if doc.ispackage():
                packages.append(uid)

        # Is there a unique module?
        if len(packages) == 0 and len(modules) == 1:
            return modules[0]
        
        # Is there a unique (top-level) package?
        if len(packages) == 0: return None
        else:
            for pkg in packages:
                for pkg2 in packages:
                    if pkg is pkg2: continue
                    if not pkg2.descendant_of(pkg): break
                else: return pkg

        # There is no top-level object.
        return None

    def _cmp_name(self, name1, name2):
        """
        Compare uid1 and uid2 by their names, using the following rules: 
          - C{'__init__'} < anything.
          - public < private.
          - otherwise, sort alphabetically by name (ignoring case)
    
        @return: -1 if C{uid1<uid2}; 0 if C{uid1==uid2}; and 1 if
            C{uid1>uid2}.
        @rtype: C{int}
        """
        if (name2 == '__init__'): return 1
        if (name1 == '__init__'): return -1
        if name1 == name2: return 0
        if self._is_private(name1) and not self._is_private(name2): return 1
        if self._is_private(name2) and not self._is_private(name1): return -1
        return cmp(name1.lower(), name2.lower())

    def _filtersort_links(self, links, sortorder=None):
        """
        Sort and filter a list of C{Link}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param links: The list of C{Link}s to be sorted and filtered.
        @type links: C{list} of L{Link}
        @param sortorder: A list of link names, typically generated
            from C{__epydoc__sort__}, and returned by
            L{ObjDoc.sortorder}.  Links whose name are in C{sortorder}
            are placed at the beginning of the sorted list, in the
            order that they appear in C{sortorder}.
        @type sortorder: C{list} of C{string}
        @return: The sorted list of links.
        @rtype: C{list} of L{Link}
        """
        # Filter out private objects.
        if not self._show_private:
            links = [l for l in links if not l.target().is_private()]
        else:
            links = list(links)

        # Check the sortorder.  If available, then use it to sort the
        # objects.
        if (type(sortorder) not in (type(()), type([]))):
            so_links = []
        else:
            if type(sortorder) == type(()): sortorder = list(sortorder)
            so_links = sortorder[:]
            for link in links:
                try: so_links[sortorder.index(link.name())] = link 
                except ValueError: continue
            so_links = [l for l in so_links if type(l) != type('')]
            for link in so_links: links.remove(link)

        # Sort any links not contained in sortorder.
        links.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        
        return so_links + links

    def _filtersort_uids(self, uids):
        """
        Sort and filter a list of C{UID}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param uids: The list of C{UID}s to be sorted and filtered.
        @type uids: C{list} of L{UID}
        @return: The sorted list of UIDs.
        @rtype: C{list} of L{UID}
        """
        # Filter out private objects
        if not self._show_private:
            uids = [u for u in uids if not u.is_private()]

        # Sort and return the UIDs.
        uids.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        return uids

    def _filtersort_vars(self, vars, sortorder=None):
        """
        Sort and filter a list of C{Var}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param vars: The list of C{Var}s to be sorted and filtered.
        @type vars: C{list} of L{Var}
        @param sortorder: A list of variable names, typically generated
            from C{__epydoc__sort__}, and returned by
            L{ObjDoc.sortorder}.  Vars whose name are in C{sortorder}
            are placed at the beginning of the sorted list, in the
            order that they appear in C{sortorder}.
        @type sortorder: C{list} of C{string}
        @return: The sorted list of variables.
        @rtype: C{list} of L{Var}
        """
        # Filter out private objects.
        if not self._show_private:
            vars = [v for v in vars if not v.uid().is_private()]
        else:
            vars = list(vars)

        # Check the sortorder.  If available, then use it to sort the
        # objects.
        if (type(sortorder) not in (type(()), type([]))):
            so_vars = []
        else:
            if type(sortorder) == type(()): sortorder = list(sortorder)
            so_vars = sortorder[:]
            for var in vars:
                try: so_vars[sortorder.index(var.name())] = var
                except ValueError: continue
            so_vars = [v for v in so_vars if type(v) != type('')]
            for var in so_vars: vars.remove(var)

        # Sort any variables not contained in sortorder.
        vars.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        
        return so_vars + vars
        
    def _header(self, name):
        """
        @return: The HTML code for the header of a page with the given
            name.
        @rtype: C{string}
        """
        return HEADER % name
               
    def _footer(self):
        """
        @return: The HTML code for the footer of a page.
        @rtype: C{string}
        """
        timestamp = time.asctime(time.localtime(time.time()))
        return FOOTER % (epydoc.__version__, timestamp)

    def _descrlist(self, items, singular, plural=None, short=0):
        """
        @return: The HTML code for a list of description items.
        @param items: The description items.
        @type items: C{list} of C{string}
        @param singular: The name of the list, if there is one
            element. 
        @param plural: The name of the list, if there are multiple
            elements.  
        """
        if plural is None: plural = singular
        if len(items) == 0: return ''
        if len(items) == 1:
            return '<p><b>%s:</b> %s<br /></p>\n\n' % (singular, items[0])
        if short:
            str = '<dl><dt><b>%s:</b></dt>\n  <dd>\n    ' % plural
            return str + ',\n    '.join(items) + '\n  </dd>\n</dl>\n\n'
        else:
            str = '<p><b>%s:</b>\n<ul>\n  <li>' % plural
            return (str + '</li>\n  <li>'.join(items) +
                    '\n  </li>\n</ul></p>\n\n')
    
    def _seealso(self, seealso, container):
        """
        @return: The HTML code for the see-also fields.
        """
        items = [self._dom_to_html(s, container) for s in seealso]
        return self._descrlist(items, 'See also', short=1)

    def _author(self, authors, container):
        """
        @return: The HTML code for the author fields.
        """
        items = [self._dom_to_html(a, container) for a in authors]
        return self._descrlist(items, 'Author', 'Authors', short=1)

    def _requires(self, requires, container):
        """
        @return: The HTML code for the requires field.
        """
        items = [self._dom_to_html(r, container) for r in requires]
        return self._descrlist(items, 'Requires')
         
    def _warnings(self, warnings, container):
        """
        @return: The HTML code for the warnings field.
        """
        items = [self._dom_to_html(r, container) for r in warnings]
        return self._descrlist(items, 'Warning', 'Warnings')

    def _version(self, version, container):
        return ('<p><b>Version:</b> %s</p>\n\n' %
                self._dom_to_html(version, container))
         
    def _imports(self, classes, excepts, functions, sortorder):
        if not self._show_imports: return ''
        class_items = [self._link_to_html(c)
                       for c in self._filtersort_links(classes, sortorder)]
        except_items = [self._link_to_html(e)
                        for e in self._filtersort_links(excepts, sortorder)]
        func_items = [self._link_to_html(f)
                      for f in self._filtersort_links(functions, sortorder)]
        if not (class_items or except_items or func_items):
            return ''
        str = self._start_of('Imports')+'<dl>\n'
        if len(class_items) > 0:
            str += '  <dt><b>Imported classes:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(class_items) + '\n  </dd>\n'
        if len(except_items) > 0:
            str += '  <dt><b>Imported exceptions:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(except_items) + '\n  </dd>\n'
        if len(func_items) > 0:
            str += '  <dt><b>Imported functions:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(func_items) + '\n  </dd>\n'
        return str + '</dl>\n\n'
                                
    def _summary(self, doc, container):
        """
        @return: The HTML code for the summary description of the
            object documented by C{doc}.  A summary description is the
            first sentence of the C{doc}'s 'description' field.  If the
            C{doc} has no 'description' field, but does have a
            'return' field, then the summary is taken from the return
            field instead.
        @rtype: C{string}
        @param doc: The documentation for the object whose summary
            should be returned.
        @type doc: L{objdoc.ObjDoc}
        @param container: The container object for C{doc}, or C{None}
            if there is none.  This container object is used to
            resolve links (E{L}{...}) in the epytext.
        @type container: L{uid.UID}
        """
        descr = doc.descr()

        # Try to find a documented ancestor.
        if isinstance(doc, FuncDoc):
            while (not doc.documented() and doc.overrides() and
                   self._docmap.has_key(doc.overrides())):
                doc = self._docmap[doc.overrides()]

        if descr != None:
            str = self._dom_to_html(epytext.summary(descr), container).strip()
            if str == '': str = '&nbsp;'
            return str
        elif (isinstance(doc, FuncDoc) and
              doc.returns().descr() is not None):
            summary = epytext.summary(doc.returns().descr())
            summary = self._dom_to_html(summary, container).strip()
            summary = summary[:1].lower() + summary[1:]
            return ('Return '+ summary)
        else:
            return '&nbsp;'

    def _link_to_html(self, link):
        """
        @return: The HTML code for the given link.  This code consists
            of an anchor with an href to the page for the link's
            target, and with text taken from the link's name. If the
            target is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type link: L{uid.Link}
        """
        return self._uid_to_href(link.target(), link.name())

    def _uid_to_uri(self, uid):
        """
        @return: a URI that points to the description of the object
            identified by C{uid}.
        @rtype: C{string}
        @param uid: A unique identifier for the object.
        @type uid: L{UID}
        """
        if uid.is_module():
            return '%s-module.html' % uid.name()
        elif uid.is_class():
            return '%s-class.html' % uid.name()
        else:
            parent = uid.parent()
            if parent is None:
                return '%s-unknown.html' % uid.name() # Error
            elif parent.is_module():
                return '%s-module.html#%s' % (parent.name(), uid.shortname())
            elif parent.is_class():
                return '%s-class.html#%s' % (parent.name(), uid.shortname())
            else:
                return '%s-unknown.html' % uid.name() # Error
            
    def _documented(self, uid):
        """
        @return: True if the given UID is documented by the
            documentation map for this C{HTMLFormatter}.  If C{uid} is the
            UID for a private object, and C{_show_private=0}, then
            this method will also return false.
        @rtype: C{boolean}
        """
        # Does it have a UID?
        if uid is None:
            return 0

        # Is it private, if we're not showing private?
        if (not self._show_private) and uid.is_private():
            return 0

        # Is it a variable or routine whose parent is not documented?
        if ((uid.is_routine() or uid.is_variable()) and
            (not self._docmap.has_key(uid.parent()))):
            return 0

        # Is it a non-variable that's not documented? (variables are
        # not included in the docmap)
        if (not uid.is_variable() and not self._docmap.has_key(uid)):
            return 0

        # Otherwise, it must be documented.
        return 1
    
    def _uid_to_href(self, uid, label=None, css_class=None, code=1):
        """
        @return: The HTML code to link to the given UID.  This code
            consists of an anchor with an href to the page for C{uid}.
            If C{label} is not C{None}, then it is used as the text
            for the link; otherwise, C{uid} is used as the text.  If
            C{uid} is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type uid: L{uid.UID}
        @type label: C{string}
        @param code: Whether or not to include C{<code>...</code>}
            tags around the label.
        """
        # We shouldn't need this, but include it just in case.
        if uid is None and label is None:
            return '<code>??</code>'
        
        # Find a default value for the label.
        if label is None: label = uid.name()

        if not self._documented(uid):
            if code: return '<code>%s</code>' % label
            else: return '%s' % label

        # Construct an href, using uid_to_uri.
        if css_class and code:
            return ('<a href="%s" class="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif css_class:
            return ('<a href="%s" class="%s">%s</a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif code:
            return ('<a href="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), label))
        else:
            return ('<a href="%s">%s</a>' %
                    (self._uid_to_uri(uid), label))

    def _start_of(self, heading):
        """
        @return: The HTML code for a 'start-of' comment.  These
            comments are used to deliniate sections of the HTML
            output.
        @rtype: C{string}
        @param heading: The name of the section that is starting.
        @type heading: C{string}
        """
        return '\n<!-- =========== START OF '+heading.upper()+\
               ' =========== -->\n'
    
    def _table_header(self, heading, css_class):
        """
        @return: The HTML code for the start of a table.  This is used
            by class tables, function tables, variable tables, etc.
        @rtype: C{string}
        @param heading: The name for the table.
        @type heading: C{string}
        @param css_class: The css class for the table.  This is used
            to allow different tables to be given different styles.
            Currently, the following classes are used: C{'summary'};
            C{'details'}; and C{'index'}.
        """
        return self._start_of(heading)+\
               '<table class="'+css_class+'" border="1" cellpadding="3"' +\
               ' cellspacing="0" width="100%" bgcolor="white">\n' +\
               '<tr bgcolor="#70b0f0" class="'+css_class+'">\n'+\
               '  <th colspan="2">' + heading + '</th></tr>\n'
    
    def _split_classes(self, classes_and_excepts):
        """
        Divide the classes fromt the given module into exceptions and
        non-exceptions.  This is used by L{_module_to_html} to list
        exceptions and non-exceptions separately.

        @param classes_and_excepts: The list of classes to split up.
        @type classes_and_excepts: C{list} of L{uid.Link}
        @return: A list C{(I{classes}, I{excepts})}, where
            C{I{classes}} is the list of non-exception classes, and
            C{I{excepts}} is the list of exception classes.
        @rtype: C{pair} of C{list} of L{uid.Link}
        """
        classes = []
        excepts = []
        for link in classes_and_excepts:
            try:
                if (self._docmap.has_key(link.target()) and
                    self._docmap[link.target()].is_exception()):
                    excepts.append(link)
                else:
                    classes.append(link)
            except:
                classes.append(link)
        return (classes, excepts)
        
