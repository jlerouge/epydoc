#
# epydoc.html: epydoc HTML output generator
# Edward Loper
#
# Created [01/30/01 05:18 PM]
# $Id$
#

"""
Documentation to HTML converter.
"""

# To do:
#   - Control over whether you link to non-documented objects
#   - Better help

##################################################
## Implementation Notes
##################################################

# Index:
#     1. Constants
#     2. Imports
#     3. HTML Formatter
#       - Constructor
#       - Write
#       - HTML page generation
#       - Navigation bar
#       - Base class trees
#       - Class hierarchy trees
#       - Module hierarchy trees
#       - Class tables
#       - Function tables
#       - Variable tables
#       - Term index generation
#       - Identifier index generation
#       - Table of contents (frames)
#       - Docstring->HTML Conversion
#       - Helper functions
#

# I chose to implement the formatter as a class (rather than as a
# group of functions) because it lets me use instance variables to
# remember all the configuration variables, which might have
# far-reaching consequences.  Passing these around manually would be a
# pain.  Also, I don't have to explicitly pass around the docmap,
# which is used almost everywhere.

##################################################
## Constants
##################################################

# Expects: (name, css)
HEADER = '''<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title> %s</title>
    <link rel="stylesheet" href="%s" type="text/css"></link>
  </head>
  <body bgcolor="white" text="black" link="blue" vlink="#204080"
        alink="#204080">
'''
# Expects: (version, date)
FOOTER = '''
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left"><font size="-2">Generated by Epydoc %s on %s</font></td>
    <td align="right"><a href="http://epydoc.sourceforge.net"
                      ><font size="-2">http://epydoc.sf.net</font></a></td>
  </tr>
</table>
</body>
</html>
'''
# Expects: (name, mainFrame_src)
FRAMES = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
  <head>
    <title> %s </title>
  </head>
  <frameset cols="20%%,80%%">
    <frameset rows="30%%,70%%">
      <frame src="epydoc-toc.html" name="moduleListFrame">
      <frame src="epydoc-project-toc.html" name="moduleFrame">
    </frameset>
    <frame src="%s" name="mainFrame">
  </frameset>
</html>
'''

# Names for the __special__ methods.
SPECIAL_METHODS ={
    '__init__': 'Constructor',
    '__del__': 'Destructor',
    '__add__': 'Addition operator',
    '__sub__': 'Subtraction operator',
    '__and__': 'And operator',
    '__or__': 'Or operator',
    '__repr__': 'Representation operator',
    '__call__': 'Call operator',
    '__getattr__': 'Qualification operator',
    '__getitem__': 'Indexing operator',
    '__setitem__': 'Index assignment operator',
    '__delitem__': 'Index deletion operator',
    '__delslice__': 'Slice deletion operator',
    '__setslice__': 'Slice assignment operator',
    '__getslice__': 'Slicling operator',
    '__len__': 'Length operator',
    '__cmp__': 'Comparison operator',
    '__eq__': 'Equality operator',
    '__in__': 'Containership operator',
    '__gt__': 'Greater-than operator',
    '__lt__': 'Less-than operator',
    '__ge__': 'Greater-than-or-equals operator',
    '__le__': 'Less-than-or-equals operator',
    '__radd__': 'Right-side addition operator',
    '__hash__': 'Hashing function',
    '__contains__': 'In operator',
    '__str__': 'Informal representation operator',
    }

##################################################
## Imports
##################################################

# system imports
import re, sys, os.path, string, time, pprint
import xml.dom.minidom

# epydoc imports
import epydoc
import epydoc.epytext as epytext
from epydoc.uid import UID, Link, findUID
from epydoc.objdoc import DocMap, ModuleDoc, FuncDoc
from epydoc.objdoc import ClassDoc, Var, Raise, ObjDoc
from epydoc.css import STYLESHEETS
from epydoc.help import HTML_HELP

##################################################
## Documentation -> HTML Conversion
##################################################

class HTML_Doc:
    """
    Documentation to HTML converter.

    For each module/package, create a file containing:
      - Navbar
      - Module Name
      - Description
      - See-also
      - Module list
      - Class summary
      - Function summary
      - Variable summary
      - Function details
      - Variable details
      - Navbar

    For each class, create a file containing:
      - Navbar
      - Module name
      - Class Name
      - Base tree
      - Known subclasses
      - Description
      - See-also
      - Method summary
      - Instance Variable summary
      - Class Variable summary
      - Method details
      - Instance Variable details
      - Class Variable details
      - Navbar

    Also, generate an index file, a help file, and a tree file.

    @type docmap: L{DocMap}
    @ivar docmap: The documentation object, encoding the objects that
        should be documented.
    @type _prj_name: C{string}
    @ivar _prj_name: A name for the documentation (for the navbar).
    @type _prj_url: C{string}
    @ivar _prj_url: A URL for the documentation (for the navpar).
    
    @ivar _module: The UID of the top-level module, if there is one.
        If there is more than one top-level module, then C{_module} is
        C{'multiple'}; if there is no top-level module, then
        C{_module} is C{None}.
    @ivar _package: The UID of the top-level package, if there is one.
        If there is more than one top-level package, then C{_package} is
        C{'multiple'}; if there is no top-level package, then
        C{_package} is C{None}.
    @ivar _show_private: Whether we are currently writing files that
        show private objects.
    @ivar _css: The name of a file containing a CSS stylesheet; or the
        name of a CSS stylesheet.
    @ivar _cssfile: The name of the CSS stylesheet file.  This should be
        C{'epydoc.css'} when C{_show_private==0} and C{'../epydoc.css'}
        when C{_show_private==1}.
    """

    #////////////////////////////////////////////////////////////
    # Constructor
    #////////////////////////////////////////////////////////////
    
    def __init__(self, docmap, **kwargs):
        """
        Construct a new HTML outputter, using the given
        L{DocMap} object.
        
        @param docmap: The documentation to output.
        @type docmap: L{DocMap}
        @param kwargs: Keyword arguments:
            - C{prj_name}: A name for the documentation (for the
              navbar).  This name can contain arbitrary HTML code
              (e.g., images or tables).  (type=C{string})
            - C{prj_url}: A URL for the documentation (for the
              navbar).  (type=C{string})
            - C{css}: The CSS stylesheet file.  If C{css} is a file,
              then its conents will be used.  Otherwise, if C{css} is
              the name of a CSS stylesheet in L{epydoc.css}, then that
              stylesheet will be used.  Otherwise, an error is
              reported.  If no stylesheet is specified, then the
              default stylesheet is used.  (type=C{string})
            - C{private_css}: The CSS stylesheet file for the private
              API documentation.  If C{css} is a file, then its
              conents will be used.  Otherwise, if C{css} is the name
              of a CSS stylesheet in L{epydoc.css}, then that
              stylesheet will be used.  Otherwise, an error is
              reported.  If no stylesheet is specified, then the
              private API documentation will use the same stylesheet
              as the public API documentation.  (type=C{string})
            - C{help}: The help file.  If no help file is specified,
              then the default help file will be used.
              (type=C{string})
            - C{private}: Whether to create documentation for private
              objects.  By default, private objects are documented.
              (type=C{boolean})
        """
        self._docmap = docmap

        # Process keyword arguments.
        self._css = kwargs.get('css')
        self._private_css = kwargs.get('private_css') or self._css
        self._show_imports = kwargs.get('show_imports', 0)
        self._prj_url = kwargs.get('prj_url', None)
        self._prj_name = kwargs.get('prj_name', '')
        self._helpfile = kwargs.get('help', None)
        self._create_private_docs = kwargs.get('private', 1)
        self._create_frames = kwargs.get('frames', 0)
        self._index_parameters = kwargs.get('index_parameters', 0)

        # If the name doesn't include any html tags, then assume it's
        # plaintext, and munge it appropriately.
        if not re.match('^([^<>]*<[^<>]+>)+$', self._prj_name):
            self._prj_name = re.sub('&', '&amp;', self._prj_name)
            self._prj_name = re.sub('<', '&lt;', self._prj_name)
            self._prj_name = re.sub('>', '&gt;', self._prj_name)
            self._prj_name = re.sub(' ', '&nbsp;', self._prj_name)

        # Find the top-level object (if any)
        self._find_toplevel()

        # Cache the HTML that we generate for each docstring.
        self._epytext_cache = {}

    def num_files(self):
        """
        @return: The number of files that this C{HTML_Doc} will
            generate.
        @rtype: C{int}
        """
        # Basic files (tree, index, help, css)
        n = 4

        # TOC files (frames, toc, project-toc)
        if self._create_frames: n += 3

        # Private basic & TOC files.
        if self._create_private_docs: n *= 2

        for uid in self._docmap.keys():
            # Module and class API files
            if not (uid.is_module() or uid.is_class()): continue
            if not uid.is_private(): n += 1
            if self._create_private_docs: n += 1

            # Module TOC files.
            if not (uid.is_module() and self._create_frames): continue
            if not uid.is_private(): n += 1
            if self._create_private_docs: n += 1
        return n

    #////////////////////////////////////////////////////////////
    # Write (and its helpers)
    #////////////////////////////////////////////////////////////
    
    def write(self, directory=None, progress_callback=None):
        """
        Write the documentation to the given directory.

        @type directory: C{string}
        @param directory: The directory to which output should be
            written.  If no directory is specified, output will be
            written to the current directory.  If the directory does
            not exist, it will be created.
        @type progress_callback: C{function}
        @param progress_callback: A callback function that is called
            before each file is written, with two arguments: the name
            of the created file (C{string}); and the object documented
            by the file, if any (L{ObjDoc}).
        @rtype: C{None}
        @raise OSError: If C{directory} cannot be created, or if any
            file cannot be created or written to. 
        """
        if directory in ('', None): directory = './'
        if directory[-1] != '/': directory = directory + '/'
        self._show_private = 0
        
        # Create dest directories, if necessary
        if not os.path.isdir(directory):
            if os.path.exists(directory):
                raise OSError('%r is not a directory' % directory)
            os.mkdir(directory)
        if self._create_private_docs:
            if not os.path.isdir(os.path.join(directory, 'private/')):
                if os.path.exists(os.path.join(directory, 'private/')):
                    raise OSError('%r is not a directory' %
                                  os.path.join(directory, 'private/'))
                os.mkdir(os.path.join(directory, 'private/'))
            if not os.path.isdir(os.path.join(directory, 'public/')):
                if os.path.exists(os.path.join(directory, 'public/')):
                    raise OSError('%r is not a directory' %
                                  os.path.join(directory, 'public/'))
                os.mkdir(os.path.join(directory, 'public/'))

        if self._create_private_docs:
            # Create the public version of the API docs
            self._show_private = 0
            self._write(os.path.join(directory, 'public/'),
                        progress_callback)

            # Create the private version of the API docs.  We have to
            # clear the epytext cache, since some L{...} links might
            # be available in the private docs that weren't in the
            # public docs. 
            self._epytext_cache = {}
            self._show_private = 1
            self._write(os.path.join(directory, 'private/'),
                        progress_callback)
        else:
            self._show_private = 0
            self._write(directory, progress_callback)

    def _write(self, directory, progress_callback):
        """
        A helper for L{write} that writes all documentation to a given
        directory.  This is typically called once for the public
        API documentation, and once for the private API documentation. 
        """
        # Write the object documentation.
        self._write_docs(directory, progress_callback)
        
        # Write the tree file (package & class hierarchies)
        filename = os.path.join(directory, 'epydoc-tree.html')
        if progress_callback: progress_callback(filename, None)
        str = self._tree_to_html()
        open(filename, 'w').write(str)

        # Write the index file.
        filename = os.path.join(directory, 'epydoc-index.html')
        if progress_callback: progress_callback(filename, None)
        str = self._index_to_html()
        open(filename, 'w').write(str)

        # Write the help file.
        filename = os.path.join(directory, 'epydoc-help.html')
        if progress_callback: progress_callback(filename, None)
        self._write_help(filename)
        
        # Write the frames-based table of contents
        if self._create_frames:
            self._write_frames(directory, progress_callback)
        
        # Write the CSS file.
        filename = os.path.join(directory, 'epydoc.css')
        if progress_callback: progress_callback(filename, None)
        self._write_css(filename)

    def _write_docs(self, directory, progress_callback):
        """
        Write the object documentation to the given directory.  The
        object documentation consists of one file for each module and
        class.

        @rtype: C{None}
        """
        for uid in self._filtersort_uids(self._docmap.keys()):
            doc = self._docmap[uid]
            filename = os.path.join(directory, '%s.html' % uid)
            if isinstance(doc, ModuleDoc):
                if progress_callback: progress_callback(filename, doc)
                str = self._module_to_html(uid)
                open(filename, 'w').write(str)
            elif isinstance(doc, ClassDoc):
                if progress_callback: progress_callback(filename, doc)
                str = self._class_to_html(uid)
                open(filename, 'w').write(str)

    def _write_frames(self, directory, progress_callback):
        """
        Write the frames-driven contents files for the project to the
        given directory.

          - C{epydoc-frames.html}
          - C{epydoc-toc.html}
          - C{epydoc-project-toc.html}
          - C{I{module}-toc.html}

        @rtype: C{None}
        """
        # Write the main frames index file
        filename = os.path.join(directory, 'epydoc-frames.html')
        if progress_callback: progress_callback(filename, None)

        name = self._prj_name or 'API Documentation'
        if re.search('<.*>', self._prj_name): name = 'API Documentation' 
        if isinstance(self._package, UID):
            mainpage = self._uid_to_uri(self._package)
        elif isinstance(self._module, UID):
            mainpage = self._uid_to_uri(self._module)
        else:
            mainpage = 'epydoc-tree.html'

        open(filename, 'w').write(FRAMES % (name, mainpage))

        # Write the top-level table of contents.
        filename = os.path.join(directory, 'epydoc-toc.html')
        if progress_callback: progress_callback(filename, None)
        open(filename, 'w').write(self._toc_to_html())

        # Classes table of contents
        filename = os.path.join(directory, 'epydoc-project-toc.html')
        if progress_callback: progress_callback(filename, None)
        str = self._project_toc_to_html()
        open(filename, 'w').write(str)

        # Write the table of contents for each module.
        for uid in self._filtersort_uids(self._docmap.keys()):
            if uid.is_module():
                doc = self._docmap[uid]
                filename = os.path.join(directory, '%s-mtoc.html' % uid)
                str = self._module_toc_to_html(uid)
                if progress_callback: progress_callback(filename, doc)
                open(filename, 'w').write(str)

    def _write_help(self, filename):
        """
        Write the help file to the given file.  If C{self._helpfile}
        contains a help file, then use it; otherwise, use the default
        helpfile.

        @rtype: C{None}
        """
        # Get the contents of the help file.
        if self._helpfile:
            if os.path.exists(self._helpfile):
                try: help = open(self._helpfile).read()
                except: raise IOError("Can't open help file: %r" %
                                      self._helpfile)
            else:
                raise IOError("Can't find help file: %r" % self._helpfile)
        else:
            help = HTML_HELP
        
        # Write the help file.
        helpfile = open(filename, 'w')
        helpfile.write(self._header('Help')+self._navbar('epydoc-help', 1)+
                       help+self._navbar('epydoc-help', 0)+self._footer())
        helpfile.close()
        
    def _write_css(self, filename):
        """
        Write the CSS stylesheet to the given file.  If
        C{self._css} contains a stylesheet file or name (from
        L{epydoc.css}), then use that stylesheet; otherwise, if a
        stylesheet file already exists, use that stylesheet.
        Otherwise, use the default stylesheet.

        @rtype: C{None}
        """
        if self._show_private: cssname = self._private_css
        else: cssname = self._css
        
        # Get the contents for the stylesheet file.  If none was
        # specified, and a stylesheet is already present, then don't
        # do anything.
        if cssname is None:
            if os.path.exists(filename):
                return
            else: css = STYLESHEETS['default'][0]
        else:
            if os.path.exists(cssname):
                try: css = open(cssname).read()
                except: raise IOError("Can't open CSS file: %r" % cssname)
            elif STYLESHEETS.has_key(cssname):
                css = STYLESHEETS[cssname][0]
            else:
                raise IOError("Can't find CSS file: %r" % cssname)

        # Write the stylesheet.
        cssfile = open(filename, 'w')
        cssfile.write(css)
        cssfile.close()
                       
    #////////////////////////////////////////////////////////////
    # HTML page generation
    #////////////////////////////////////////////////////////////
    # Each of these functions creates a single HTML file, and returns
    # it as a string.
    
    def _module_to_html(self, uid):
        """
        @return: An HTML page describing the module identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the module that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation.
        doc = self._docmap[uid]

        # Write the header & navigation bar.
        str = self._header(uid.name())
        str += self._navbar(uid, 1)

        # Write the module's name.
        if uid.is_package():
            str += self._start_of('Package Description')
            str += '<h2>Package '+uid.name()+'</h2>\n\n'
        else:
            str += self._start_of('Module Description')
            str += '<h2>Module '+uid.name()+'</h2>\n\n'

        # Add any author links.
        if doc.authors():
            str += self._author(doc.authors(), uid)

        # Write the module's description.
        if doc.descr():
            str += self._dom_to_html(doc.descr(), uid) + '<hr/>\n'

        # Add any see-also links.
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # If it's a package, add a list of sub-modules.
        if doc.ispackage():
            str += self._module_list(doc.modules(), doc.sortorder())

        # Show the summaries for classes, exceptions, functions, and
        # variables contained in the module.
        (classes,excepts) = self._split_classes(doc.classes())
        (iclasses,iexcepts) = self._split_classes(doc.imported_classes())
        str += self._class_summary(classes, doc.sortorder(), 'Classes')
        str += self._class_summary(excepts, doc.sortorder(), 'Exceptions')
        str += self._func_summary(doc.functions(), doc.sortorder(), None)
        str += self._var_summary(doc.variables(), doc.sortorder(), uid)
        str += self._imports(iclasses, iexcepts, doc.imported_functions(),
                             doc.sortorder())

        # Show details for the functions and variables.
        str += self._func_details(doc.functions(), None)
        str += self._var_details(doc.variables(), uid)

        # Add another navigation bar and the footer.
        str += self._navbar(uid) + self._footer()
        
        return str

    def _class_to_html(self, uid):
        """
        @return: An HTML page describing the class identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the class that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation
        doc = self._docmap[uid]
        
        # Write the header & navigation bar.
        str = self._header(uid.name())
        str += self._navbar(uid, 1)

        # Add any author links.
        if doc.authors():
            str += self._author(doc.authors(), uid)

        # Write the class's module and its name.
        str += self._start_of('Class Description')
        str += '<h2><font size="-1">\n'+uid.module().name()+'</font><br>\n' 
        str += 'Class ' + uid.name()+'</h2>\n\n'

        # Write the base class tree
        if doc.bases():
            str += '<pre class="base-tree">\n' 
            str += self._base_tree(uid) 
            str += '</pre><br>\n\n'

        # Write the class's known subclasses
        if doc.subclasses():
            str += '<dl><dt><b>Known Subclasses:</b></dt>\n<dd>'
            for cls in doc.subclasses():
                str += '    '+self._link_to_html(cls) + ',\n'
            str = str[:-2] + '</dd></dl>\n\n'

        # Write the class's description
        if doc.descr():
            str += '<hr/>\n' + self._dom_to_html(doc.descr(), uid)
            str += '\n\n'
        str += '<hr/>\n\n'

        # Add any see-also links
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # Show the summaries for methods, instance variables, and
        # class variables contained in the class.
        str += self._func_summary(doc.methods(), doc.sortorder(),
                                  doc, 'Method Summary')
        str += self._var_summary(doc.ivariables(), doc.sortorder(),
                                 uid, 'Instance Variable Summary')
        str += self._var_summary(doc.cvariables(), doc.sortorder(),
                                 uid, 'Class Variable Summary')

        # Show details for methods and variables
        str += self._func_details(doc.methods(), doc, 
                                  'Method Details')
        str += self._var_details(doc.ivariables(), uid,
                                 'Instance Variable Details')
        str += self._var_details(doc.cvariables(), uid,
                                 'Class Variable Details')

        # Add a navigation bar and the footer.
        str += self._navbar(uid) + self._footer()
        
        return str

    def _tree_to_html(self):
        """
        @return: An HTML page containing the module and class
            hierarchies. 
        @rtype: C{string}
        """
        # Header and navigation bar
        str = self._header('Module and Class Hierarchies')
        str += self._navbar('epydoc-tree', 1)

        # Module hierarchy
        str += self._start_of('Module Hierarchy')
        str += '<h2>Module Hierarchy</h2>\n'
        str += self._module_tree()

        # Class hierarchy
        str += self._start_of('Class Hierarchy')
        str += '<h2>Class Hierarchy</h2>\n'
        str += self._class_tree()

        # Navigation bar and footer
        str += self._navbar('epydoc-tree')
        str += self._footer()
        return str

    def _index_to_html(self):
        """
        @return: An HTML page containing the index terms.
        @rtype: C{string}
        """
        # Header and navigation bar.
        str = self._header('Index')
        str += self._navbar('epydoc-index', 1) 
        str += '<br>\n'

        # Term index
        str += self._start_of('Term Index')
        str += self._table_header('Term Index', 'index')
        index = self._extract_term_index().items()
        index.sort()
        for (term, links) in index:
            str += '  <tr><td width="15%">'+term+'</td>\n    <td>'
            links.sort()
            for link in links:
                str += ('<i><a href="%s#%s">%s</a></i>, ' %
                        (self._uid_to_uri(link.target()),
                         self._term_index_to_anchor(term), link.name()))
            str = str[:-2] + '</tr></td>\n'
        str += '</table>\n' +  '<br>\n'

        # Identifier index
        str += self._start_of('Identifier Index')
        str += self._table_header('Identifier Index', 'index')
        identifiers = self._extract_identifier_index()
        for (href, descr) in identifiers:
            str += '  <tr><td width="15%%">%s</td>\n' % href
            str += '    <td>%s</td></tr>\n' % descr
        str += '</table>\n' +  '<br>\n'
            

        # Navigation bar and footer.
        str += self._navbar('epydoc-index')
        str += self._footer()
        return str

    def _toc_to_html(self):
        """
        @return: An HTML page containing the top-level table of
            contents page.  This page is used to select a module table
            of contents page, or the "everything" table of contents
            page. 
        @rtype: C{string}
        """
        uids = self._filtersort_uids(self._docmap.keys())

        # Header
        str = self._header('Table of Contents')
        str += ('<center><font size="+1"><b>Table&nbsp;of&nbsp;'
                 'Contents</b></font></center>\n<hr>\n')

        # Class table of contents (all classes/exceptions)
        str += ('<a target="moduleFrame" href="%s">%s</a><br>\n' %
                ('epydoc-project-toc.html', 'Everything'))

        # Package table of contents (individual packages)
        str += self._start_of('Packages')
        str += '<br><font size="+1"><b>Packages</b></font><br>\n'
        for uid in uids:
            if uid.is_package():
                str += ('<a target="moduleFrame" href="%s-mtoc.html">'+
                         '%s</a><br>\n') % (uid, uid)

        # Module table of contents (individual modules)
        str += self._start_of('Modules')
        str += '<br><font size="+1"><b>Modules</b></font><br>\n'
        for uid in uids:
            if uid.is_module() and not uid.is_package():
                str += ('<a target="moduleFrame" href="%s-mtoc.html">'+
                        '%s</a><br>\n') % (uid, uid)
                
        # The private/public link.
        str += '\n<br><hr>\n'
        str += self._public_private_link('epydoc-toc')
        
        return str + '\n</body>\n</html>\n'

    def _project_toc_to_html(self):
        """
        @return: An HTML page containing the table of contents page
            for the whole project.  This page lists the classes,
            exceptions, functions, and variables defined by any module
            or package in the project.
        @rtype: C{string}
        """
        # Header and name.
        str = self._header('Everything')
        str += ('<center><font size="+1"><b>Everything</b>' +
                 '</font></center>\n<hr>\n')

        # Find classes & exceptions
        classes = [Link(c.name(),c) for c in self._docmap.keys()
                   if c.is_class()]
        (classes,excepts) = self._split_classes(classes)

        # Find functions & variables
        funcs = []; vars = []
        for (uid, doc) in self._docmap.items():
            if isinstance(doc, ModuleDoc):
                funcs += doc.functions()
                vars += [(var,uid) for var in doc.variables()]
        
        # Class and excpetion lists.
        str += self._start_of('All Classes')
        str += self._toc_section('All&nbsp;Classes', classes)
        str += self._start_of('All Exceptions')
        str += self._toc_section('All&nbsp;Exceptions', excepts)
        str += self._start_of('All Functions')
        str += self._toc_section('All&nbsp;Functions', funcs)
        str += self._start_of('All Variables')
        str += self._toc_var_section('All&nbsp;Variables', vars)
        
        str += '\n<hr>\n'
        str += self._public_private_link('epydoc-project-toc')
        return str + '\n</body>\n</html>\n'

    def _module_toc_to_html(self, uid):
        """
        @return: An HTML page containing the table of contents page
            for the given module.  This page lists the modules,
            classes, exceptions, functions, and variables defined by
            the module. 
        @rtype: C{string}
        """
        doc = self._docmap[uid]
        (classes,excepts) = self._split_classes(doc.classes())
        vars = [(var,uid) for var in doc.variables()]

        # Header and name.
        str = self._header(uid.name())
        str += (('<center><font size="+1"><b><a target="mainFrame" '+
                'href="%s">%s</a></b></font></center>\n<hr>\n')
                % (self._uid_to_uri(uid), uid.shortname()))
        
        # Lists of modules, classes, exceptions, functions, and variables.
        if uid.is_package():
            str += self._toc_section('Modules', doc.modules())
        str += self._toc_section('Classes', classes)
        str += self._toc_section('Exceptions', excepts)
        str += self._toc_section('Functions', doc.functions())
        str += self._toc_var_section('Variables', vars)
                                 
        # The private/public link.
        str += '\n<hr>\n'
        str += self._public_private_link('%s-mtoc' % uid)

        return str + '\n</body>\n</html>\n'
    
    #////////////////////////////////////////////////////////////
    # Navigation bar
    #////////////////////////////////////////////////////////////
    # The navigation bar is placed at the top & bottom of every HTML
    # page.
    
    def _navbar(self, where=None, top=0):
        """
        @return: The HTML code for a navigation bar on the given type
            of page.  The navigation bar typically looks like::
            
                [ Package Module Class Tree Index Help ]
                
        @rtype: C{string}
        @param where: An identifier indicating what page we're
            creating a navigation bar for.  This is either a UID
            (for an object documentation page); or one of the strings
            C{'tree'}, C{'index'}, and C{'help'}.
        @type where: C{UID} or C{string}
        @param top: Whether this is the navigation bar at the top of
            the page.
        @type top: C{boolean}
        """
        str = self._start_of('Navbar')
        str += '<table class="navbar" border="0" width="100%"'
        str += ' cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">\n'
        str += '  <tr valign="center">\n'

        I = ' '*4 # indentation

        # Make sure that "package" and "parent" take up the same
        # amount of room, so the navbar looks the same on different
        # pages..
        WIDTH = ''
        #if self._package is None: WIDTH=''
        #else: WIDTH='width="20%"'
        
        # The "Go to Package" link
        if self._package is None: pass
        elif isinstance(where, UID) and where.is_package():
            pkg = where.package()
            if pkg is not None:
                str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;&nbsp;'
                str += self._uid_to_href(pkg, 'Parent', 'navbar', 0)
                str += '&nbsp;&nbsp;&nbsp;</th>\n'
            else:
                str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;'
                str += '&nbsp;Parent&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(where, UID):
            pkg = where.package()
            if pkg is not None:
                str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;&nbsp;'
                str += self._uid_to_href(pkg, 'Package', 'navbar', 0)
                str += '&nbsp;&nbsp;&nbsp;</th>\n'
            else:
                str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;'
                str += '&nbsp;Package&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(self._package, UID):
            str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;&nbsp;'
            str += self._uid_to_href(self._package, 'Package', 'navbar', 0)
            str += '&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;&nbsp;'
            str += 'Package&nbsp;&nbsp;&nbsp;</th></b>\n'
        
        # The "Go to Module" link
        if self._module is None: pass
        elif isinstance(where, UID) and where.is_package():
            str += I+'<th '+WIDTH+' bgcolor="#70b0f0" class="navselect">' 
            str += '&nbsp;&nbsp;&nbsp;Package&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(where, UID) and where.is_module():
            str += I+'<th '+WIDTH+' bgcolor="#70b0f0" class="navselect">' 
            str += '&nbsp;&nbsp;&nbsp;Module&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(where, UID) and where.is_class():
            str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;&nbsp;'
            str += self._uid_to_href(where.module(), 'Module', 'navbar', 0)
            str += '&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(self._module, UID):
            str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;&nbsp;'
            str += self._uid_to_href(self._module, 'Module', 'navbar', 0)
            str += '&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th '+WIDTH+' class="navbar">&nbsp;&nbsp;&nbsp;'
            str += 'Module&nbsp;&nbsp;&nbsp;</th>\n'
        
        # The "Go to Class" link
        if isinstance(where, UID) and where.is_class():
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Class&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;Class' 
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Tree" link
        if where == 'epydoc-tree':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Trees&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="epydoc-tree.html">Trees</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Index" link
        if where == 'epydoc-index':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="epydoc-index.html">Index</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Help" link
        if where == 'epydoc-help':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Help&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="epydoc-help.html">Help</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        str += I+'<td width="100%"></td>\n'
        str += I+'<th class="navbar">'
        if self._prj_name:
            if self._prj_url:
                str += ('<a class="navbar" target="_top" href="%s">%s</a>' %
                          (self._prj_url, self._prj_name))
            else:
                str += self._prj_name

        str += '</th>\n  </tr>\n</table>\n'

        # Frames and public/private link
        if top and (self._create_private_docs or self._create_frames):
            str += '<table width="100%"><tr>\n'
            if self._create_frames:
                str += '  <td>%s</td>\n' % self._frames_link(where)
            str += '  <td width="100%"></td>\n'
            if self._create_private_docs:
                str += '  <td>%s</td>\n' % self._public_private_link(where)
            str += '</tr></table>\n'
            
        return str

    def _frames_link(self, where):
        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        return ('<font size="-2">[<a href="epydoc-frames.html"'+
                'target="_top">frames</a>&nbsp;|&nbsp;<a href="'+uri+
                '" target="_top">no&nbsp;frames</a>]</font>')
    
    def _public_private_link(self, where):
        """
        @return: The HTML code for a link between the public & private
            copies of the documentation.
        @rtype: C{string}
        """
        # For private pages, there's no corresponding public page..
        if isinstance(where, UID) and where.is_private():
            return ('<font size="-2">[<b>show&nbsp;private</b>' +
                    '&nbsp;|&nbsp;hide&nbsp;private]</font>')

        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        
        if self._show_private:
            return ('<font size="-2">[show&nbsp;private&nbsp;|&nbsp;' +
                    '<a href="../public/' + uri + '">hide&nbsp;private' +
                    '</a>]</font>')
        else:
            return ('<font size="-2">[<a href="../private/' + uri +
                    '">show&nbsp;private</a>&nbsp;|&nbsp;hide&nbsp;' +
                    'private]</font>')
    
    #////////////////////////////////////////////////////////////
    # Base class trees
    #////////////////////////////////////////////////////////////
    
    def _find_tree_width(self, uid):
        """
        @return: The width of a base tree, when drawn
            right-justified.  This is used by L{_base_tree} to
            determine how far to indent lines of the base tree.
        @rtype: C{int}
        """
        width = 2
        if self._docmap.has_key(uid):
            for base in self._docmap[uid].bases():
                width = max(width, len(base.name())+4)
                width = max(width, self._find_tree_width(base.target())+4)

        return width
        
    def _base_tree(self, uid, width=None, postfix=''):
        """
        @return: The HTML code for a class's base tree.  The tree is
            drawn 'upside-down' and right justified, to allow for
            multiple inheritence.
        @rtype: C{string}
        """
        if not self._docmap.has_key(uid): return ''
        if width == None:
            width = self._find_tree_width(uid)
        
        bases = self._docmap[uid].bases()
        
        if postfix == '':
            str = ' '*(width-2) + '<b>'+uid.shortname()+'</b>\n'
        else: str = ''
        for i in range(len(bases)-1, -1, -1):
            base = bases[i]
            str = (' '*(width-4-len(base.name())) +
                   self._link_to_html(base)+' --+'+postfix+'\n' + 
                   ' '*(width-4) +
                   '   |'+postfix+'\n' +
                   str)
            (t,w) = (base.target(), width)
            if i != 0:
                str = (self._base_tree(t, w-4, '   |'+postfix)+str)
            else:
                str = (self._base_tree(t, w-4, '    '+postfix)+str)
        ss = re.sub('<[^<>]+>','',str)
        return str
                
    #////////////////////////////////////////////////////////////
    # Class hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _class_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_class_tree}.
        """
        if uid is not None:
            doc = self._docmap.get(uid, None)
            str = ' '*depth + '<li> <b>' + self._uid_to_href(uid)+'</b>'
            if doc and doc.descr():
                str += ': <i>' + self._summary(doc, uid.module()) + '</i>'
            str += '\n'
            if doc and doc.subclasses():
                str += ' '*depth + '  <ul>\n'
                children = [l.target() for l
                            in self._filtersort_links(doc.subclasses())]
                for child in children:
                    str += self._class_tree_item(child, depth+4)
                str += ' '*depth + '  </ul>\n'
        return str

    def _class_tree(self, sortorder=None):
        """
        @return: The HTML code for the class hierarchy tree.  This is
            used by L{_tree_to_html} to construct the hierarchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        uids = self._filtersort_uids(self._docmap.keys())
        #docs.sort(lambda a,b: cmp(a[0], b[0]))
        for uid in uids:
            doc = self._docmap[uid]
            if not isinstance(doc, ClassDoc): continue
            hasbase = 0
            for base in doc.bases():
                if self._docmap.has_key(base.target()):
                    hasbase = 1
            if not hasbase:
                str += self._class_tree_item(uid)
        return str +'</ul>\n'

    #////////////////////////////////////////////////////////////
    # Module hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _module_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_module_tree} and L{_module_list}.
        
        @rtype: C{string}
        """
        if uid is None: return ''

        doc = self._docmap.get(uid, None)
        name = uid.shortname()
        str = ' '*depth + '<li> <b>'
        str += self._uid_to_href(uid, name)+'</b>'
        if doc and doc.descr():
            str += ': <i>' + self._summary(doc, uid) + '</i>'
        str += '\n'
        if doc and doc.ispackage() and doc.modules():
            str += ' '*depth + '  <ul>\n'
            modules = [l.target() for l in 
                       self._filtersort_links(doc.modules(), doc.sortorder())]
            for module in modules:
                str += self._module_tree_item(module, depth+4)
            str += ' '*depth + '  </ul>\n'
        str += ' '*depth+'</li>'
        return str

    def _module_tree(self, sortorder=None):
        """
        @return: The HTML code for the module hierarchy tree.  This is
            used by L{_tree_to_html} to construct the hiearchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        uids = self._filtersort_uids(self._docmap.keys())
        #docs.sort(lambda a,b: cmp(a[0], b[0]))
        # Find all top-level packages. (what about top-level
        # modules?)
        for uid in uids:
            doc = self._docmap[uid]
            if not isinstance(doc, ModuleDoc): continue
            if not doc.package():
                str += self._module_tree_item(uid)
        return str +'</ul>\n'

    def _module_list(self, modules, sortorder):
        """
        @return: The HTML code for the module hierarchy tree,
            containing the given modules.  This is used by
            L{_module_to_html} to list the submodules of a package.
        @rtype: C{string}
        """
        if len(modules) == 0: return ''
        str = '<h3>Modules</h3>\n<ul>\n'
        modules = self._filtersort_links(modules, sortorder)
        
        for link in modules:
            str += self._module_tree_item(link.target())
        return str + '</ul>\n'

    #////////////////////////////////////////////////////////////
    # Class tables
    #////////////////////////////////////////////////////////////
    
    def _class_summary(self, classes, sortorder, heading='Class Summary'):
        """
        @return: The HTML code for the class summary table.  This is
            used by L{_module_to_html} to list the classes in a
            module.
        @rtype: C{string}
        """
        classes = self._filtersort_links(classes, sortorder)
        if len(classes) == 0: return ''
        str = self._table_header(heading, 'summary')

        for link in classes:
            cname = link.name()
            cls = link.target()
            if not self._docmap.has_key(cls): continue
            cdoc = self._docmap[cls]
            csum = self._summary(cdoc, cls.module())
            str += '<tr><td width="15%">\n'
            str += '  <b><i>'+self._link_to_html(link)
            str += '</i></b></td>\n  <td>' + csum + '</td></tr>\n'
        return str + '</table><br>\n\n'

    #////////////////////////////////////////////////////////////
    # Function tables
    #////////////////////////////////////////////////////////////
    
    def _func_summary(self, functions, sortorder, cls,
                      heading='Function Summary'):
        """
        @return: The HTML code for a function summary table.  This
            is used by L{_module_to_html} to list the functions in a
            module; and by L{_class_to_html} to list member
            functions. 
        @rtype: C{string}
        """
        functions = self._filtersort_links(functions, sortorder)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'summary')

        for link in functions:
            func = link.target()
            fname = link.name()
            if func.is_method():
                container = func.cls()
                inherit = (container != cls.uid())
            else:
                inherit = 0
                try: container = func.module()
                except TypeError: container = None

            # If we don't have documentation for the function, then we
            # can't say anything about it.
            if not self._docmap.has_key(func): continue
                
            fdoc = self._docmap[func]
            
            # Try to find a documented ancestor.
            while (not fdoc.documented() and
                   fdoc.overrides() and
                   self._docmap.has_key(fdoc.overrides())):
                fdoc = self._docmap[fdoc.overrides()]
                
            rval = fdoc.returns()
            if rval.type():
                rtype = self._dom_to_html(rval.type(), container, 8)
            else:
                rtype = '&nbsp;'

            descrstr = self._summary(fdoc, container)
            if descrstr != '&nbsp;':
                fsum = '<br>'+descrstr
            else:
                if inherit: fsum = '<br>\n'
                else: fsum = ''
            if inherit:
                fsum += ('    <i>(inherited from %s)</i>\n' %
                         self._uid_to_href(container, container.shortname()))
            str += '<tr><td align="right" valign="top" width="15%">'
            str += '<font size="-1">'+rtype+'</font></td>\n  <td>'
            str += self._func_signature(fname, fdoc, 1, 'summary-sig')
            str += fsum+'</td></tr>\n'
        return str + '</table><br>\n\n'

    def _func_details(self, functions, cls, heading='Function Details'):
        """
        @return: The HTML code for a function details table.  This
            is used by L{_module_to_html} to describe the functions in
            a module; and by L{_class_to_html} to describe member
            functions.
        @rtype: C{string}
        """
        functions = self._filtersort_links(functions)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'

        for link in functions:
            fname = link.name()
            func = link.target()
            if func.is_method():
                container = func.cls()
                inherit = (container != cls.uid())
            else:
                inherit = 0
                try: container = func.module()
                except TypeError: container = None
            if not self._docmap.has_key(func):
                continue

            # Don't document inherited methods; instead, the method
            # summary points to the details description in the parent
            # class's file.
            if inherit: continue
            
            str += '\n<a name="'+fname+'"></a>\n'
            str += '<table width="100%" class="func-details"'
            str += ' bgcolor="#e0e0e0"><tr><td>\n'

            if not self._docmap.has_key(func): continue
            fdoc = self._docmap[func]

            if SPECIAL_METHODS.has_key(fname):
                str += '  <h3 class="func-details"><i>'
                str += SPECIAL_METHODS[fname]+'</i></h3>\n'
            else:
                str += '  <h3 class="func-details">'+fname+'</h3>\n'

            str += '  <p>%s</p>\n' % self._func_signature(fname, fdoc)

            foverrides = fdoc.overrides()

            # If we inherit docs, then make sure that the parameter
            # names match the function that we're inheriting docs from.
            fparam_names = [p.name() for p in fdoc.parameter_list()]
            kwarg_name = fdoc.kwarg() and fdoc.kwarg().name()
            vararg_name = fdoc.vararg() and fdoc.vararg().name()

            # Try to find a documented ancestor.
            inheritdoc = 0
            while (not fdoc.documented() and
                   fdoc.overrides() and
                   self._docmap.has_key(fdoc.overrides())):
                # Get the inherited documentation.
                inh_fdoc = self._docmap[fdoc.overrides()]
                
                # Require that the names of parameters match.
                ifparam_names = [p.name() for p in inh_fdoc.parameter_list()]
                ikwarg_name = inh_fdoc.kwarg() and inh_fdoc.kwarg().name()
                ivararg_name = inh_fdoc.vararg() and inh_fdoc.vararg().name()
                if (fparam_names != ifparam_names[:len(fparam_names)] or
                    kwarg_name != ikwarg_name or
                    vararg_name != ivararg_name):
                    if fname != '__init__':
                        estr =(('\nWarning: The parameters of %s do not '+
                                'match the parameters of the base class '+
                                'method %s; not inheriting documentation.')
                               % (fdoc.uid(), inh_fdoc.uid()))
                        estr = epytext.wordwrap(estr, 9, 75-9).strip()
                        print >>sys.stderr, estr
                    break

                # Inherit the documentation.
                fdoc = inh_fdoc
                inheritdoc = 1
                
            fdescr=fdoc.descr()
            fparam = fdoc.parameter_list()[:]
            if fdoc.vararg(): fparam.append(fdoc.vararg())
            if fdoc.kwarg(): fparam.append(fdoc.kwarg())
            freturn = fdoc.returns()
            fraises = fdoc.raises()
            
            # Don't list parameters that don't have any extra info.
            f = lambda p:p.descr() or p.type()
            fparam = filter(f, fparam)

            # Description
            if fdescr:
                str += self._dom_to_html(fdescr, container, 2)
            str += '  <dl><dt></dt><dd>\n'

            # Parameters
            if fparam:
                str += '    <dl><dt><b>Parameters:</b></dt>\n'
                for param in fparam:
                    pname = param.name()
                    str += '      <dd><code><b>' + pname +'</b></code>'
                    if param.descr():
                        pdescr = self._dom_to_html(param.descr(), container, 8)
                        str += ' -\n %s' % pdescr.rstrip()
                    str += '\n'
                    if param.type():
                        ptype = self._dom_to_html(param.type(), container, 14)
                        str += '        <br><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % ptype.strip()
                    str += '      </dd>\n'
                str += '    </dl>\n'

            # Returns
            if freturn.descr() or freturn.type():
                str += '    <dl><dt><b>Returns:</b></dt>\n      <dd>\n'
                if freturn.descr():
                    str += self._dom_to_html(freturn.descr(), container, 8)
                    if freturn.type():
                        rtype = self._dom_to_html(freturn.type(),container,14)
                        str += '        <br><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % rtype.strip()
                elif freturn.type():
                    str += self._dom_to_html(freturn.type(), container, 8)
                str += '      </dd>\n    </dl>\n'

            # Raises
            if fraises:
                str += '    <dl><dt><b>Raises:</b></dt>\n'
                for fraise in fraises:
                    str += '      '
                    str += '<dd><code><b>'+fraise.name()+'</b></code> -\n'
                    str += self._dom_to_html(fraise.descr(), container, 8)
                    str +'      </dd>\n'
                str += '    </dl>\n'

            # Overrides
            if foverrides:
                str += '    <dl><dt><b>Overrides:</b></dt>\n'
                if self._docmap.has_key(foverrides.cls()):
                    str += '      <dd>'+self._uid_to_uri(foverrides)
                else:
                    str += '      <dd><code>%s</code>' % func
                if inheritdoc:
                    str += ' <i>(inherited documentation)</i>\n'
                str += '</dd>\n    </dl>\n'

            str += '  </dd></dl>\n'
            str += '</td></tr></table>\n'

        str += '<br>\n\n'
        return str

    def _func_signature(self, fname, fdoc, link=0, css_class="sig"):
        """
        @return: The HTML code for the function signature of the
            function with the given name and documentation.
        @param fname: The short name of the function.
        @type fname: C{string}
        @param fdoc: The documentation for the function.
        @type fdoc: L{objdoc.FuncDoc}
        @param link: Whether to create a link from the function's name
            to its details description.
        """
        str = '<code class=%s>' % css_class
        if link: str += self._uid_to_href(fdoc.uid(), fname, css_class)
        else: str += '<span class=%s-name>%s</span>' % (css_class, fname)
        
        PARAM_JOIN = ',\n'+' '*15
        str += '('
        str += self._params_to_html(fdoc.parameters(), css_class, not link)
        if fdoc.vararg():
            vararg_name = fdoc.vararg().name()
            if vararg_name != '...': vararg_name = '*%s' % vararg_name
            str += ('<span class=%s-vararg>%s</span>%s' %
                    (css_class, vararg_name, PARAM_JOIN))
        if fdoc.kwarg():
            str += ('<span class=%s-kwarg>**%s</span>%s' %
                    (css_class, fdoc.kwarg().name(), PARAM_JOIN))
        if str[-1] != '(': str = str[:-len(PARAM_JOIN)]

        return str + ')</code>'

    def _params_to_html(self, parameters, css_class, show_defaults):
        PARAM_JOIN = ',\n'+' '*15
        str = ''
        for param in parameters:
            if type(param) in (type([]), type(())):
                sublist = self._params_to_html(param, css_class,
                                               show_defaults)
                str += '(%s), ' % sublist[:-len(PARAM_JOIN)]
            else:
                str += ('<span class=%s-arg>%s</span>' %
                        (css_class, param.name()))
                if show_defaults and param.default() is not None:
                    default = param.default()
                    default = re.sub('&', '&amp;', default)
                    default = re.sub('<', '&lt;', default)
                    default = re.sub('>', '&gt;', default)
                    default = re.sub(' ', '&nbsp;', default)
                    if len(default) > 60:
                        default = default[:57]+'...'
                    str += ('=<span class=%s-default>%s</span>' %
                            (css_class, default))
                str += PARAM_JOIN
        return str

    #////////////////////////////////////////////////////////////
    # Variable tables
    #////////////////////////////////////////////////////////////
    
    def _var_summary(self, variables, sortorder, container,
                     heading='Variable Summary'):
        """
        @return: The HTML code for a variable summary table.  This
            is used by L{_module_to_html} to list the variables in a
            module; and by L{_class_to_html} to list instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._filtersort_vars(variables, sortorder)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'summary')

        for var in variables:
            vname = var.name()
            if var.type():
                vtype = self._dom_to_html(var.type(), container, 10).strip()
            else: vtype = '&nbsp;'
            if var.descr():
                vsum = ' - ' +self._summary(var, container)
            else: vsum = ''
            str += '<tr><td align="right" valign="top" '
            str += 'width="15%"><font size="-1">'+vtype+'</font></td>\n'
            str += '  <td><code><b><a href="#'+vname+'">'+vname
            str += '</a></b></code>\n  ' + vsum + '</td></tr>\n'
        return str + '</table><br>\n\n'

    def _var_details(self, variables, container, heading='Variable Details'):
        """
        @return: The HTML code for a variable details table.  This
            is used by L{_module_to_html} to describe the variables in
            a module; and by L{_class_to_html} to describe instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._filtersort_vars(variables)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>'

        numvars = 0
        for var in variables:
            # Don't bother if we don't know anything about it.
            if (var.descr() is None and var.type() is None and
                not var.has_value()): continue
            numvars += 1
            
            str += ('<table width="100%" class="var-details"'+
                    ' bgcolor="#e0e0e0">'+
                    '<tr><td>\n')
            
            vname = var.name()
            vtyp = var.type()
            hasval = var.has_value()

            str += '<a name="'+vname+'"></a>\n'
            str += '<h3>'+vname+'</h3>\n'

            # If it's a module, class, method, type, or func, then
            # just link to it.
            if not var.uid().is_variable():
                str += ('<code>%s</code> = %s\n' %
                        (vname, self._uid_to_href(var.uid())))
                hasval = vtyp = None

            if var.descr():
                str += self._dom_to_html(var.descr(), container)
                
            if vtyp is not None or hasval:
                str += '<dl>\n  <dt></dt>\n  <dd>\n    <dl>\n'
                
            if vtyp:
                str += '      <dt><b>Type:</b></dt>\n      <dd>' 
                str += self._dom_to_html(vtyp, container)
                str += '</dd>\n'

            str += self._pprint_var_value(var)

            if vtyp is not None or hasval:
                str += '    </dl>\n  </dd>\n</dl>'
                
            str += '</dl></td></tr></table>\n'

        # If we didn't get any variables, don't print anything.
        if numvars == 0: return ''
        return str+'<br>'

    def _pprint_var_value(self, var):
        if not var.has_value(): return ''
        val = var.uid().value()

        # These should be defined somewhere higher, and maybe
        # customizable.
        MAXLINES = 8 # Max total lines
        LINELEN = 60 # Length of lines (for wrapping), in chars.
        LINEWRAP_MARKER = r'<span class="variable-linewrap">\</span>'
        ELLIPSIS_MARKER = r'<span class="variable-ellipsis">...</span>'

        # For regexps, display the regexp pattern.
        if type(val).__name__ == 'SRE_Pattern':
            try:
                pat = `val.pattern`
                if len(pat) < (MAXLINES*LINELEN): val = pat
            except: pass

        # For lists, tuples, and dicts, use pprint??
        if type(val) in (type(()), type([]), type({})):
            val = pprint.pformat(val)
            
        # For other non-strings, use repr to generate a representation.
        if type(val) is not type(''):
            try: val = `val`
            except: val = '...'

        # Get rid of any null characters.
        val = val.replace('\0', '')

        # Add line wrapping.  The "\0" will be turned into
        # LINEWRAP_MARK below.
        if len(val) > LINELEN:
            val = re.sub('(%s)(?=.)' % ('.'*LINELEN), '\\1\0\n', val)

        # Pad the last line, so all value regions will have equal width.
        val += ' '*(LINELEN-len(val)+val.rfind('\n')+1)

        # Quote characters.
        val = re.sub('&', '&amp;', val)
        val = re.sub('<', '&lt;', val)
        val = re.sub('>', '&gt;', val)
        val = re.sub('\0', LINEWRAP_MARKER, val)

        # Truncate at MAXLINES.
        if val.count('\n') >= MAXLINES:
            val = ('\n'.join(val.split('\n')[:MAXLINES]) + '\n' +
                   ELLIPSIS_MARKER+ ' '*(LINELEN-3))
        
        # Construct the value box.
        str = '      <dt><b>Value:</b></dt>\n' 
        str += '      <dd><table><tr><td>\n'
        str += '<pre class="variable">\n%s</pre>\n' % val
        str += '        </td></tr></table></dd>\n'
        return str


    #////////////////////////////////////////////////////////////
    # Term index generation
    #////////////////////////////////////////////////////////////
    
    def _get_term_index_items(self, tree, link, dict):
        """
        @param dict: in/out parameter. 
        @rtype: C{None}
        """
        if isinstance(tree, xml.dom.minidom.Text): return
        if isinstance(tree, xml.dom.minidom.Document):
            self._get_term_index_items(tree.childNodes[0], link, dict)
            return
        if tree is None: return
        elif tree.tagName != 'index':
            # Look for index items in the child nodes.
            for child in tree.childNodes:
                self._get_term_index_items(child, link, dict)
        else:
            # We found an index item.
            children = [self._dom_to_html(c) for c in tree.childNodes]
            key = ''.join(children).lower().strip()
            if dict.has_key(key):
                dict[key].append(link)
            else:
                dict[key] = [link]

    def _extract_term_index(self):
        """
        @return: A dictionary mapping from terms to lists of source
            documents.
        @rtype: C{dictionary}
        """
        index = {}
        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            
            if uid.is_function():
                link = Link(uid.name(), uid.module())
            elif uid.is_method():
                link = Link(uid.name(), uid.cls())
            else:
                link = Link(uid.name(), uid)

            # Get index items from standard fields.
            self._get_term_index_items(doc.descr(), link, index)
            for see in doc.seealsos():
                self._get_term_index_items(see, link, index)
            if doc.version() is not None: 
                self._get_term_index_items(doc.version(), link, index)
            for author in doc.authors():
                self._get_term_index_items(author, link, index)

            # Get index items from object-specific fields.
            if isinstance(doc, ModuleDoc):
                for var in doc.variables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_term_index_items(var.descr(), link, index)
                    self._get_term_index_items(var.type(), link, index)
            elif isinstance(doc, ClassDoc):
                for var in doc.ivariables() + doc.cvariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_term_index_items(var.descr(), link, index)
                    self._get_term_index_items(var.type(), link, index)
            elif isinstance(doc, FuncDoc):
                extra_p = [v for v in [doc.vararg(), doc.kwarg(),
                                       doc.returns()] if v is not None]
                for param in doc.parameter_list()+extra_p:
                    self._get_term_index_items(param.descr(), link, index)
                    self._get_term_index_items(param.type(), link, index)
                for fraise in doc.raises():
                    self._get_term_index_items(fraise.descr(), link, index)
                    
        return index

    #////////////////////////////////////////////////////////////
    # Identifier index generation
    #////////////////////////////////////////////////////////////

    def _extract_identifier_index(self):
        """
        @rtype: C{list} of C{(string, string)}
        """
        # list of (name, href, descr) tripples
        identifiers = []
        
        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            if uid.is_module():
                # Add the module to the index.
                if uid.is_package() and uid.package():
                    descr = 'Subpackage in package '
                    descr += self._uid_to_href(uid.package())
                elif uid.package():
                    descr = 'Module in package '
                    descr += self._uid_to_href(uid.package())
                else: descr = 'Module'
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add all of the module's variables to the index.
                descr = ' Variable in module %s' % self._uid_to_href(uid)
                for var in doc.variables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )
                    
            elif uid.is_class():
                # Add the class to the index.
                descr = ('Class in module %s' %
                         self._uid_to_href(uid.module()))
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add all the class variables to the index.
                descr = ('Class variable in class %s' %
                         self._uid_to_href(uid))
                for var in doc.cvariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )

                # Add all the instance variables to the index.
                descr = ('Instance variable in class %s' %
                         self._uid_to_href(uid))
                for var in doc.ivariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )

            elif uid.is_routine():
                # Add the function/method to the index.
                if uid.is_function() or uid.is_builtin_function():
                    descr = ('Function in module %s' %
                             self._uid_to_href(uid.module()))
                else:
                    descr = ('Method in class %s' %
                             self._uid_to_href(uid.cls()))
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add the parameters to the index.
                if self._index_parameters:
                    if uid.is_function() or uid.is_builtin_function():
                        descr = 'Parameter to function '
                        dsecr += self._uid_to_href(uid)
                    else:
                        descr = 'Parameter to method '
                        dsecr += self._uid_to_href(uid)
                    extra_p = [v for v in [doc.vararg(), doc.kwarg()]
                               if v is not None]
                    for var in doc.parameter_list()+extra_p:
                        href = self._uid_to_href(uid, var.name())
                        identifiers.append( (var.name(), href, descr) )
            else:
                raise AssertionError, 'fix me'

        identifiers.sort(lambda a,b: cmp(a[0].lower(),b[0].lower()))
        return [id[1:3] for id in identifiers]

    #////////////////////////////////////////////////////////////
    # Table of contents (frames) generation
    #////////////////////////////////////////////////////////////

    def _toc_section(self, section, links):
        # Sort & filter the links
        if not self._show_private:
            links = [o for o in links if not o.target().is_private()]
        links.sort(lambda x,y: cmp(x.name().lower(), y.name().lower()))

        if not links: return ''
        str = self._start_of(section)
        str += '<font size="+1"><b>%s</b></font><br>\n' % section
        for link in links:
            str += ('<a target="mainFrame" href="%s">%s</a><br>\n' %
                    (self._uid_to_uri(link.target()), link.name()))
        return str+'<br>\n'

    def _toc_var_section(self, section, vars):
        # Sort & filter the vars.
        if not self._show_private:
            vars = [o for o in vars if not o[0].uid().is_private()]
        vars.sort(lambda (v1,u1),(v2,u2): cmp(v1.name().lower(),
                                              v2.name().lower()))

        if not vars: return ''
        str = self._start_of(section)
        str += '<font size="+1"><b>%s</b></font><br>\n' % section
        for var in vars:
            str += ('<a target="mainFrame" href="%s#%s">%s</a><br>\n' %
                    (self._uid_to_uri(var[1]), var[0].name(), 
                     var[0].name()))
        return str+'<br>\n'

    #////////////////////////////////////////////////////////////
    # Docstring -> HTML Conversion
    #////////////////////////////////////////////////////////////

    def _term_index_to_anchor(self, str):
        """
        Given the name of an inline index item, construct a URI anchor.
        These anchors are used to create links from the index page to each
        index item.
        """
        # Include "-" so we don't accidentally collide with the name
        # of a python identifier. 
        return "index-"+re.sub("[^a-zA-Z0-9]", "_", str)
    
    def _dom_to_html(self, tree, container=None, indent=0):
        """
        Given the DOM document for an epytext string (as returned by
        L{epytext.parse}), return a string encoding it in HTML.  This
        string does not include C{<html>} or C{<body>} tags.
    
        @param tree: The DOM document for an epytext string.
        @type tree: C{xml.dom.minidom.Document}
        @param container: The container in which to look up objects by name
            (e.g., for link directives).
        @type container: Python module
        """
        if isinstance(tree, xml.dom.minidom.Document):
            tree = tree.childNodes[0]
        if not self._epytext_cache.has_key( (tree, container) ):
            html = self._dom_to_html_helper(tree, container, indent, 0)
            self._epytext_cache[tree, container] = html
        return self._epytext_cache[tree,container]
    
    def _dom_to_html_helper(self, tree, container, indent, seclevel):
        """
        Helper function for L{_dom_to_html}, that does the real work of
        converting a DOM tree for an epytext string to HTML.
    
        @param tree: The DOM tree for an epytext string.
        @type tree: L{xml.dom.minidom.Element}
        @param container: The container in which to look up objects by name
            (e.g., for link directives).
        @type container: Python module
        @param indent: The number of characters indentation that should be
            used for HTML tags.
        @type indent: C{int}
        @param seclevel: The current section level.
        @type seclevel: int
        """
        # This takes care of converting > to &gt;, etc.:
        if isinstance(tree, xml.dom.minidom.Text): return tree.toxml()
    
        if tree.tagName == 'epytext': indent -= 2
        if tree.tagName == 'section': seclevel += 1
    
        # Process the children first.
        children = [self._dom_to_html_helper(c, container, indent+2, seclevel)
                    for c in tree.childNodes]
    
        # Get rid of unnecessary <P>...</P> tags; they introduce extra
        # space on most browsers that we don't want.
        for i in range(len(children)-1):
            if (not isinstance(tree.childNodes[i], xml.dom.minidom.Text) and
                tree.childNodes[i].tagName == 'para' and
                (isinstance(tree.childNodes[i+1], xml.dom.minidom.Text) or
                 tree.childNodes[i+1].tagName != 'para')):
                children[i] = ' '*(indent+2)+children[i][5+indent:-5]+'\n'
        if (tree.hasChildNodes() and
            not isinstance(tree.childNodes[-1], xml.dom.minidom.Text) and
            tree.childNodes[-1].tagName == 'para'):
            children[-1] = ' '*(indent+2)+children[-1][5+indent:-5]+'\n'
    
        # Construct the HTML string for the children.
        childstr = ''.join(children)
    
        # Perform the approriate action for the DOM tree type.
        if tree.tagName == 'para':
            return epytext.wordwrap('<p>%s</p>' % childstr, indent)
        elif tree.tagName == 'code':
            return '<code>%s</code>' % childstr
        elif tree.tagName == 'uri':
            return '<a href="%s">%s</a>' % (children[1], children[0])
        elif tree.tagName == 'link':
            return self._dom_link_to_html(children[1], children[0],
                                          container)
        elif tree.tagName == 'italic':
            return '<i>%s</i>' % childstr
        elif tree.tagName == 'math':
            return '<i class="math">%s</i>' % childstr
        elif tree.tagName == 'index':
            return ('<a name="%s"></a><i class="indexterm">%s</i>' %
                    (self._term_index_to_anchor(childstr), childstr))
        elif tree.tagName == 'bold':
            return '<b>%s</b>' % childstr
        elif tree.tagName == 'ulist':
            return '%s<ul>\n%s%s</ul>\n' % (indent*' ', childstr, indent*' ')
        elif tree.tagName == 'olist':
            startAttr = tree.getAttributeNode('start')
            if startAttr: start = ' start="%s"' % startAttr.value
            else: start = ''
            return ('%s<ol%s>\n%s%s</ol>\n' %
                    (indent*' ', start, childstr, indent*' '))
        elif tree.tagName == 'li':
            return indent*' '+'<li>\n%s%s</li>\n' % (childstr, indent*' ')
        elif tree.tagName == 'heading':
            return ('%s<h%s class="heading">%s</h%s>\n' %
                    ((indent-2)*' ', seclevel, childstr, seclevel))
        elif tree.tagName == 'literalblock':
            return '<pre class="literalblock">\n%s\n</pre>\n' % childstr
        elif tree.tagName == 'doctestblock':
            dtb = self._colorize_doctestblock(childstr.strip())
            return '<pre class="doctestblock">\n%s</pre>\n' % dtb
        elif tree.tagName == 'fieldlist':
            raise AssertionError("There should not be any field lists left")
        elif tree.tagName in ('epytext', 'section', 'tag', 'arg',
                              'name', 'target'):
            return childstr
        else:
            raise ValueError('Unknown epytext DOM element %r' % tree.tagName)
    
    # Construct two regular expressions that are useful for colorizing
    # doctest blocks: _PROMPT_RE and _COLORIZE_RE.
    _KEYWORDS = ["del", "from", "lambda", "return", "and", "or", "is", 
                 "global", "not", "try", "break", "else", "if", "elif", 
                 "while", "class", "except", "import", "pass", "raise",
                 "continue", "finally", "in", "print", "def", "for"]
    _KEYWORD = '|'.join([r'(\b%s\b)' % kw for kw in _KEYWORDS])
    _STRING = '|'.join([r'("""("""|.*?((?!").)"""))', r'("("|.*?((?!").)"))',
                        r"('''('''|.*?[^\\']'''))", r"('('|.*?[^\\']'))"])
    _STRING = _STRING.replace('"', '&quot;') # Careful with this!
    _COMMENT = '(#.*?$)'
    _PROMPT = r'(^\s*(&gt;&gt;&gt;|\.\.\.)(\s|$))'
    _PROMPT_RE = re.compile(_PROMPT, re.MULTILINE | re.DOTALL)
    _COLORIZE_RE = re.compile('|'.join([_STRING, _COMMENT, _KEYWORD]),
                              re.MULTILINE | re.DOTALL)
    del _KEYWORDS, _KEYWORD, _STRING, _COMMENT
    def _colorize_doctestblock(self, str):
        """
        Do some colorization for a doctest block.  In particular, this
        identifies spans with the following css classes:
          - pysrc: The Python source code
          - pyprompt: The ">>>" and "..." prompts
          - pystring: Strings in the Python source code
          - pycomment: Comments in the Python source code
          - pykeyword: Keywords in the Python source code
          - pyoutput: Python's output (lines without a prompt)
        
        @type str: C{string}
        @param str: The contents of the doctest block to be colorized.
        @rtype: C{string}
        @return: The colorized doctest block.
        """
        PROMPT_RE = HTML_Doc._PROMPT_RE
        COLORIZE_RE = HTML_Doc._COLORIZE_RE
        pysrc = pyout = ''
        outstr = ''
        for line in str.split('\n')+['\n']:
            if PROMPT_RE.match(line):
                if pyout:
                    outstr += ('<span class="pyoutput">%s</span>\n\n' %
                               pyout.strip())
                    pyout = ''
                pysrc += line+'\n'
            else:
                if pysrc:
                    # Prompt over-rides other colors (incl string)
                    pysrc = COLORIZE_RE.sub(self._colorize_match, pysrc)
                    pysrc = PROMPT_RE.sub(r'<span class="pyprompt">'+
                                          r'\1</span>', pysrc)
                    outstr += ('<span class="pysrc">%s</span>\n'
                               % pysrc.strip())
                    pysrc = ''
                pyout += line+'\n'
        if pyout.strip():
            outstr += ('<span class="pyoutput">%s</span>\n' %
                       pyout.strip())
        return outstr.strip()
        
    def _colorize_match(self, match):
        """
        This helper function is used by L{_colorize_doctestblock} to
        add colorization to matching expressions.  It is called by
        C{_COLORIZE_RE.sub} with an expression that matches
        C{_COLORIZE_RE}.

        @return: The HTML code for the colorized expression.
        @rtype: C{string}
        """
        str = match.group()
        if str[:1] == "'" or str[:6] == '&quot;':
            return '<span class="pystring">%s</span>' % str
        elif str[:1] in '#':
            return '<span class="pycomment">%s</span>' % str
        else:
            return '<span class="pykeyword">%s</span>' % str
        
    def _dom_link_to_html(self, target, name, container):
        uid = findUID(target, container, self._docmap)
        if uid is None:
            print >>sys.stderr, ('\nWarning: could not find UID for '+
                                 'L{%s} in %s' % (target, container))
        return self._uid_to_href(uid, name, 'link')
    
    #////////////////////////////////////////////////////////////
    # Helper functions
    #////////////////////////////////////////////////////////////
    
    def _is_private(self, str):
        """
        @return: true if C{str} is the name of a private Python object.
        @rtype: C{boolean}
        """
        if str == '...': return 0
        for piece in str.split('.'):
            if piece[:1] == '_' and piece[-1:] != '_': return 1
        return 0
    
    def _find_toplevel(self):
        """
        Try to find a unique module/package for this set of docs.
        Update the member variables L{_package} and L{_module} to
        contain the top-level module/package.
        """
        modules = []
        packages = []
        for (uid, doc) in self._docmap.items():
            if not isinstance(doc, ModuleDoc): continue
            modules.append(uid)
            if doc.ispackage():
                packages.append(uid)

        # Is there a unique module?
        if len(modules) == 0: self._module = None
        elif len(modules) == 1: self._module = modules[0]
        else: self._module = 'multiple'

        # Is there a unique (top-level) package?
        if len(packages) == 0: self._package = None
        else:
            self._package = 'multiple'
            for pkg in packages:
                toplevel = 1
                for p2 in packages:
                    if pkg != p2 and not p2.descendant_of(pkg):
                        toplevel = 0
                if toplevel:
                    self._package = pkg

    def _cmp_name(self, name1, name2):
        """
        Compare uid1 and uid2 by their names, using the following rules: 
          - C{'__init__'} < anything.
          - public < private.
          - otherwise, sort alphabetically by name (ignoring case)
    
        @return: -1 if C{uid1<uid2}; 0 if C{uid1==uid2}; and 1 if
            C{uid1>uid2}.
        @rtype: C{int}
        """
        if (name2 == '__init__'): return 1
        if (name1 == '__init__'): return -1
        if name1 == name2: return 0
        if self._is_private(name1) and not self._is_private(name2): return 1
        if self._is_private(name2) and not self._is_private(name1): return -1
        return cmp(name1.lower(), name2.lower())

    def _filtersort_links(self, links, sortorder=None):
        """
        Sort and filter a list of C{Link}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param links: The list of C{Link}s to be sorted and filtered.
        @type links: C{list} of L{Link}
        @param sortorder: A list of link names, typically generated
            from C{__epydoc__sort__}, and returned by
            L{ObjDoc.sortorder}.  Links whose name are in C{sortorder}
            are placed at the beginning of the sorted list, in the
            order that they appear in C{sortorder}.
        @type sortorder: C{list} of C{string}
        @return: The sorted list of links.
        @rtype: C{list} of L{Link}
        """
        # Filter out private objects.
        if not self._show_private:
            links = [l for l in links if not l.target().is_private()]
        else:
            links = list(links)

        # Check the sortorder.  If available, then use it to sort the
        # objects.
        if (type(sortorder) not in (type(()), type([]))):
            so_links = []
        else:
            if type(sortorder) == type(()): sortorder = list(sortorder)
            so_links = sortorder[:]
            for link in links:
                try: so_links[sortorder.index(link.name())] = link 
                except ValueError: continue
            so_links = [l for l in so_links if type(l) != type('')]
            for link in so_links: links.remove(link)

        # Sort any links not contained in sortorder.
        links.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        
        return so_links + links

    def _filtersort_uids(self, uids):
        """
        Sort and filter a list of C{UID}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param uids: The list of C{UID}s to be sorted and filtered.
        @type uids: C{list} of L{UID}
        @return: The sorted list of UIDs.
        @rtype: C{list} of L{UID}
        """
        # Filter out private objects
        if not self._show_private:
            uids = [u for u in uids if not u.is_private()]

        # Sort and return the UIDs.
        uids.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        return uids

    def _filtersort_vars(self, vars, sortorder=None):
        """
        Sort and filter a list of C{Var}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param vars: The list of C{Var}s to be sorted and filtered.
        @type vars: C{list} of L{Var}
        @param sortorder: A list of variable names, typically generated
            from C{__epydoc__sort__}, and returned by
            L{ObjDoc.sortorder}.  Vars whose name are in C{sortorder}
            are placed at the beginning of the sorted list, in the
            order that they appear in C{sortorder}.
        @type sortorder: C{list} of C{string}
        @return: The sorted list of variables.
        @rtype: C{list} of L{Var}
        """
        # Filter out private objects.
        if not self._show_private:
            vars = [v for v in vars if not v.uid().is_private()]
        else:
            vars = list(vars)

        # Check the sortorder.  If available, then use it to sort the
        # objects.
        if (type(sortorder) not in (type(()), type([]))):
            so_vars = []
        else:
            if type(sortorder) == type(()): sortorder = list(sortorder)
            so_vars = sortorder[:]
            for var in vars:
                try: so_vars[sortorder.index(var.name())] = var
                except ValueError: continue
            so_vars = [v for v in so_vars if type(v) != type('')]
            for var in so_vars: vars.remove(var)

        # Sort any variables not contained in sortorder.
        vars.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        
        return so_vars + vars
        
    def _header(self, name):
        """
        @return: The HTML code for the header of a page with the given
            name.
        @rtype: C{string}
        """
        return HEADER % (name, 'epydoc.css')
               
    def _footer(self):
        """
        @return: The HTML code for the footer of a page.
        @rtype: C{string}
        """
        timestamp = time.asctime(time.localtime(time.time()))
        return FOOTER % (epydoc.__version__, timestamp)
    
    def _seealso(self, seealso, container):
        """
        @return: The HTML code for the see-also fields.
        """
        items = [self._dom_to_html(s, container) for s in seealso]
        if len(items) == 0: return ''
        if len(items) == 1:
            return '<p><b>See also:</b> %s</p>\n\n' % items[0]
        if len(items) > 1:
            str = '<dl><dt><b>See also:</b></dt>\n  <dd>\n    '
            return str + ',\n    '.join(items) + '\n  </dd>\n</dl>\n\n'

    def _author(self, authors, container):
        """
        @return: The HTML code for the author fields.
        """
        items = [self._dom_to_html(a, container) for a in authors]
        if len(items) == 0: return ''
        if len(items) == 1:
            return '<p><b>Author:</b> %s</p>\n\n' % items[0]
        if len(items) > 1:
            str = '<dl><dt><b>Authors:</b></dt>\n  <dd>\n    '
            return str + ',\n    '.join(items) + '\n  </dd>\n</dl>\n\n'

    def _imports(self, classes, excepts, functions, sortorder):
        if not self._show_imports: return ''
        class_items = [self._link_to_html(c)
                       for c in self._filtersort_links(classes, sortorder)]
        except_items = [self._link_to_html(e)
                        for e in self._filtersort_links(excepts, sortorder)]
        func_items = [self._link_to_html(f)
                      for f in self._filtersort_links(functions, sortorder)]
        if not (class_items or except_items or func_items):
            return ''
        str = self._start_of('Imports')+'<dl>\n'
        if len(class_items) > 0:
            str += '  <dt><b>Imported classes:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(class_items) + '\n  </dd>\n'
        if len(except_items) > 0:
            str += '  <dt><b>Imported exceptions:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(except_items) + '\n  </dd>\n'
        if len(func_items) > 0:
            str += '  <dt><b>Imported functions:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(func_items) + '\n  </dd>\n'
        return str + '</dl>\n\n'
                                
    def _summary(self, doc, container):
        """
        @return: The HTML code for the summary description of the
            object documented by C{doc}.  A summary description is the
            first sentence of the C{doc}'s 'description' field.  If the
            C{doc} has no 'description' field, but does have a
            'return' field, then the summary is taken from the return
            field instead.
        @rtype: C{string}
        @param doc: The documentation for the object whose summary
            should be returned.
        @type doc: L{objdoc.ObjDoc}
        @param container: The container object for C{doc}, or C{None}
            if there is none.  This container object is used to
            resolve links (E{L}{...}) in the epytext.
        @type container: L{uid.UID}
        """
        descr = doc.descr()

        # Try to find a documented ancestor.
        if isinstance(doc, FuncDoc):
            while (not doc.documented() and
                   doc.overrides() and
                   self._docmap.has_key(doc.overrides())):
                doc = self._docmap[doc.overrides()]

        if descr != None:
            str = self._dom_to_html(epytext.summary(descr), container).strip()
            if str == '': str = '&nbsp;'
            return str
        elif (isinstance(doc, FuncDoc) and
              doc.returns().descr() is not None):
            summary = epytext.summary(doc.returns().descr())
            summary = self._dom_to_html(summary, container).strip()
            summary = summary[:1].lower() + summary[1:]
            return ('Return '+ summary)
        else:
            return '&nbsp;'

    def _link_to_html(self, link):
        """
        @return: The HTML code for the given link.  This code consists
            of an anchor with an href to the page for the link's
            target, and with text taken from the link's name. If the
            target is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type link: L{uid.Link}
        """
        return self._uid_to_href(link.target(), link.name())

    def _uid_to_uri(self, uid):
        """
        @return: a URI that points to the description of the object
            identified by C{uid}.
        @rtype: C{string}
        @param uid: A unique identifier for the object.
        @type uid: L{UID}
        """
        name = uid.name()
        if uid.is_routine() or uid.is_variable():
            dot = name.rindex('.')
            return '%s.html#%s' % (name[:dot], name[dot+1:])
        else:
            return '%s.html' % name
    
    def _uid_to_href(self, uid, label=None, css_class=None, code=1):
        """
        @return: The HTML code to link to the given UID.  This code
            consists of an anchor with an href to the page for C{uid}.
            If C{label} is not C{None}, then it is used as the text
            for the link; otherwise, C{uid} is used as the text.  If
            C{uid} is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type uid: L{uid.UID}
        @type label: C{string}
        @param code: Whether or not to include C{<code>...</code>}
            tags around the label.
        """
        # Find a default value for the label.
        if label is None: label = uid.name()

        # If there's no UID, or it's an undocumented object, or it's
        # private and we're not showing private, then don't link to
        # it; just show the label.
        if (uid is None or (not self._docmap.has_key(uid)) or
            (not self._show_private) and uid.is_private()):
            if code: return '<code>%s</code>' % label
            else: return '%s' % label
                

        # Construct an href, using uid_to_uri.
        if css_class and code:
            return ('<a href="%s" class="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif css_class:
            return ('<a href="%s" class="%s">%s</a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif code:
            return ('<a href="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), label))
        else:
            return ('<a href="%s">%s</a>' %
                    (self._uid_to_uri(uid), label))

    def _start_of(self, heading):
        """
        @return: The HTML code for a 'start-of' comment.  These
            comments are used to deliniate sections of the HTML
            output.
        @rtype: C{string}
        @param heading: The name of the section that is starting.
        @type heading: C{string}
        """
        return '\n<!-- =========== START OF '+string.upper(heading)+\
               ' =========== -->\n'
    
    def _table_header(self, heading, css_class):
        """
        @return: The HTML code for the start of a table.  This is used
            by class tables, function tables, variable tables, etc.
        @rtype: C{string}
        @param heading: The name for the table.
        @type heading: C{string}
        @param css_class: The css class for the table.  This is used
            to allow different tables to be given different styles.
            Currently, the following classes are used: C{'summary'};
            C{'details'}; and C{'index'}.
        """
        return self._start_of(heading)+\
               '<table class="'+css_class+'" border="1" cellpadding="3"' +\
               ' cellspacing="0" width="100%" bgcolor="white">\n' +\
               '<tr bgcolor="#70b0f0" class="'+css_class+'">\n'+\
               '  <th colspan="2">' + heading + '</th></tr>\n'
    
    def _split_classes(self, classes_and_excepts):
        """
        Divide the classes fromt the given module into exceptions and
        non-exceptions.  This is used by L{_module_to_html} to list
        exceptions and non-exceptions separately.

        @param classes_and_excepts: The list of classes to split up.
        @type classes_and_excepts: C{list} of L{uid.Link}
        @return: A list C{(I{classes}, I{excepts})}, where
            C{I{classes}} is the list of non-exception classes, and
            C{I{excepts}} is the list of exception classes.
        @rtype: C{pair} of C{list} of L{uid.Link}
        """
        classes = []
        excepts = []
        for link in classes_and_excepts:
            try:
                if (self._docmap.has_key(link.target()) and
                    self._docmap[link.target()].is_exception()):
                    excepts.append(link)
                else:
                    classes.append(link)
            except:
                classes.append(link)
        return (classes, excepts)
        
