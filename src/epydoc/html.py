#
# epydoc.py: epydoc HTML output generator
# Edward Loper
#
# Created [01/30/01 05:18 PM]
# $Id$
#

"""
Documentation to HTML converter.  This module defines a single class,
L{HTMLFormatter}, which translates the API documentation encoded in a
L{DocMap} into a set of HTML files.

@todo: fix toc private/public links (?)
@todo: don't print headers for empty sections. :-/
@todo: use _DevNull for the public stream if it's a private object.
@todo: either use StringIO more (if it's significantly faster), or
       don't use it at all.

@var HEADER: The header for standard documentation HTML pages.
@var FOOTER: The footer for standard documentation HTML pages.
@var REDIRECT_INDEX: The contents of redirect index page.  This page
    is only used if the supplied top page is external.
@var SPECIAL_METHODS: A dictionary providing names for the special
    methods that a class can define.
"""
__docformat__ = 'epytext en'

##################################################
## Implementation Notes
##################################################

# Index:
#     1. Constants
#     2. Imports
#     3. HTML Formatter
#       - Constructor
#       - Write
#       - HTML page generation
#       - Navigation bar
#       - Base class trees
#       - Class hierarchy trees
#       - Module hierarchy trees
#       - Class tables
#       - Function tables
#       - Variable tables
#       - Term index generation
#       - Identifier index generation
#       - Table of contents (frames)
#       - Docstring->HTML Conversion
#       - Helper functions
#

# I chose to implement the formatter as a class (rather than as a
# group of functions) because it lets me use instance variables to
# remember all the configuration variables.  Passing these around
# manually would be a pain.  Also, I don't have to explicitly pass
# around the docmap, which is used almost everywhere.

##################################################
## Constants
##################################################

# Expects: name
HEADER = '''<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>%s</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
</head>
<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
'''
# Expects: (version, date)
FOOTER = '''
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left"><font size="-2">Generated by Epydoc %s on %s</font></td>
    <td align="right"><a href="http://epydoc.sourceforge.net"
                      ><font size="-2">http://epydoc.sf.net</font></a></td>
  </tr>
</table>
</body>
</html>
'''
# Expects: (name, mainFrame_src)
FRAMES_INDEX = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
  <title> %s </title>
</head>
<frameset cols="20%%,80%%">
  <frameset rows="30%%,70%%">
    <frame src="toc.html" name="moduleListFrame">
    <frame src="toc-everything.html" name="moduleFrame">
  </frameset>
  <frame src="%s" name="mainFrame">
</frameset>
</html>
'''
# Expects (url, url, name)
REDIRECT_INDEX = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
  <title> Redirect </title>
  <meta http-equiv="refresh" content="1;url=%s">
  <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
</head>
<body>
  Redirecting to the API documentation for <a href="%s">%s</a>...
</body>
</html>
'''

# Names for the __special__ methods.
SPECIAL_METHODS ={
    '__init__': 'Constructor',
    '__del__': 'Destructor',
    '__add__': 'Addition operator',
    '__sub__': 'Subtraction operator',
    '__and__': 'And operator',
    '__or__': 'Or operator',
    '__repr__': 'Representation operator',
    '__call__': 'Call operator',
    '__getattr__': 'Qualification operator',
    '__getitem__': 'Indexing operator',
    '__setitem__': 'Index assignment operator',
    '__delitem__': 'Index deletion operator',
    '__delslice__': 'Slice deletion operator',
    '__setslice__': 'Slice assignment operator',
    '__getslice__': 'Slicling operator',
    '__len__': 'Length operator',
    '__cmp__': 'Comparison operator',
    '__eq__': 'Equality operator',
    '__in__': 'Containership operator',
    '__gt__': 'Greater-than operator',
    '__lt__': 'Less-than operator',
    '__ge__': 'Greater-than-or-equals operator',
    '__le__': 'Less-than-or-equals operator',
    '__radd__': 'Right-side addition operator',
    '__hash__': 'Hashing function',
    '__contains__': 'In operator',
    '__nonzero__': 'Boolean test operator',
    '__str__': 'Informal representation operator',
    }

##################################################
## Imports
##################################################

# system imports
import re, sys, os.path, time, pprint, types
import xml.dom.minidom

try: from cStringIO import StringIO
except: from StringIO import StringIO

# epydoc imports
import epydoc
import epydoc.markup as markup
from epydoc.uid import UID, Link, findUID, make_uid
from epydoc.imports import import_module
from epydoc.objdoc import DocMap, ModuleDoc, FuncDoc
from epydoc.objdoc import ClassDoc, Var, Raise, ObjDoc
from epydoc.css import STYLESHEETS
from epydoc.help import HTML_HELP
from epydoc.colorize import colorize_re

##################################################
## Documentation -> HTML Conversion
##################################################

class HTMLFormatter:
    """
    Documentation to HTML converter.  The API documentation produced
    C{HTMLFormatter} consists of a set of HTML files.  Two
    subdirectories are created for the public and private
    documentation.  Within each subdirectories, every class and module
    is documented in its own file.  An index file, a trees file, a
    help file, and a frames-based table of contents are also created.
    In particular, C{HTMLFormatter} generates the following files:

      - X{index.html}: The standard entry point for the documentation.
        Normally, index.html is a frame index file, which defines
        three frames: two frames on the left side of the browser
        contain a table of contents, and the main frame on the right
        side of the window contains documentation pages.  But if the
        --no-frames option is used, then index.html will redirect the
        user to the project's top page.
      - X{I{module}-module.html}: The API documentation for a module.
        I{module} is the complete dotted name of the module, such as
        sys or epydoc.epytext.
      - X{I{class}-class.html}: The API documentation for a class, exception,
        or type.  I{class} is the complete dotted name of the class,
        such as epydoc.epytext.Token or array.ArrayType.
      - X{trees.html}: The module and class hierarchies.
      - X{indices.html} The term and identifier indices.  
      - X{help.html}: The help page for the project.  This page
        explains how to use and navigate the webpage produced by
        epydoc.
      - X{toc.html}: The top-level table of contents page.  This page
        is displayed in the upper-left frame, and provides links to
        toc-everything.html and the toc-I{module}-module.html files.  toc.html
        is not generated if the --no-frames option is used.
      - X{toc-everything.html}: The table of contents for the entire
        project.  This page is displayed in the lower-left frame, and
        provides links to every class, type, exception, function,
        and variable defined by the project.  toc-everything.html is
        not generated if the --no-frames option is used.
      - X{toc-I{module}-module.html}: The table of contents for a module.
        This page is displayed in the lower-left frame, and provides
        links to every class, type, exception, function, and variable
        defined by the module.  module is the complete dotted name of
        the module, such as sys or epydoc.epytext.  toc-m-module.html
        is not generated if the --no-frames option is used.
      - X{epydoc.css}: The CSS stylesheet used to display all HTML
        pages.

    @type _docmap: L{DocMap}
    @ivar _docmap: The documentation map, encoding the objects that
        should be documented.
    @type _prj_name: C{string}
    @ivar _prj_name: A name for the documentation (for the navbar).
    @type _prj_url: C{string}
    @ivar _prj_url: A URL for the documentation (for the navpar).
    @ivar _module: The UID of the top-level module, if there is one. 
        If there is more than one top-level module, then C{_module} is
        C{'multiple'}; if there is no top-level module, then
        C{_module} is C{None}.
    @ivar _package: The UID of the top-level package, if there is
        one. If there is more than one top-level package, then
        C{_package} is C{'multiple'}; if there is no top-level
        package, then C{_package} is C{None}.
    @ivar _show_private: Whether we are currently writing files that
        show private objects.
    @ivar _css: The name of a file containing a CSS stylesheet; or the
        name of a CSS stylesheet.
    @ivar _cssfile: The name of the CSS stylesheet file.  This should
        be C{'epydoc.css'} when C{_show_private==0} and
        C{'../epydoc.css'} when C{_show_private==1}.
    @ivar _variable_linelen:  The maximum line length used for
        displaying the values of variables in the variable
        details sections.
    @ivar _variable_maxlines: The maximum number of lines that
         should be displayed for the value of a variable in the
         variable details section.
    """

    #////////////////////////////////////////////////////////////
    # Constructor
    #////////////////////////////////////////////////////////////
    
    def __init__(self, docmap, **kwargs):
        """
        Construct a new HTML formatter, using the given documentation map.
        @param docmap: The documentation to output.
        @type docmap: L{DocMap}
        @param kwargs: Keyword arguments:
            - C{prj_name}: The name of the project.  Defaults to
              none.  (type=C{string})
            - C{prj_url}: The target for the project hopeage link on
              the navigation bar.  If C{prj_url} is not specified,
              then no hyperlink is created.  (type=C{string})
            - C{prj_link}: The label for the project link on the
              navigation bar.  This link can contain arbitrary HTML
              code (e.g. images).  By default, a label is constructed
              from C{prj_name}.  (type=C{string})
            - C{top}: The top page for the documentation.  This
              is the default page shown main frame, when frames are
              enabled.  C{top} can be a URL, the name of a
              module, the name of a class, or one of the special
              strings C{"trees.html"}, C{"indices.html"}, or
              C{"help.html"}.  By default, the top-level package or
              module is used, if there is one; otherwise, C{"trees"}
              is used.  (type=C{string})
            - C{css}: The CSS stylesheet file.  If C{css} is a file
              name, then the specified file's conents will be used.
              Otherwise, if C{css} is the name of a CSS stylesheet in
              L{epydoc.css}, then that stylesheet will be used.
              Otherwise, an error is reported.  If no stylesheet is
              specified, then the default stylesheet is used.
              (type=C{string})
            - C{private_css}: The CSS stylesheet file for the private
              API documentation.  If C{css} is a file name, then the
              specified file's conents will be used.  Otherwise, if
              C{css} is the name of a CSS stylesheet in L{epydoc.css},
              then that stylesheet will be used.  Otherwise, an error
              is reported.  If no stylesheet is specified, then the
              private API documentation will use the same stylesheet
              as the public API documentation.  (type=C{string})
            - C{help}: The name of the help file.  If no help file is
              specified, then the default help file will be used.
              (type=C{string})
            - C{private}: Whether to create documentation for private
              objects.  By default, private objects are documented.
              (type=C{boolean})
            - C{frames}: Whether to create a frames-based table of
              contents.  By default, it is produced.
              (type=C{boolean}) 
            - C{show_imports}: Whether or not to display lists of
              imported functions and classes.  By default, they are
              not shown.  (type=C{boolean})
            - C{index_parameters}: Whether or not to include function
              parameters in the identifier index.  By default, they
              are not included.  (type=C{boolean})
            - C{variable_maxlines}: The maximum number of lines that
              should be displayed for the value of a variable in the
              variable details section.  By default, 8 lines are
              displayed.  (type=C{int})
            - C{variable_linelength}: The maximum line length used for
              displaying the values of variables in the variable
              details sections.  If a line is longer than this length,
              then it will be wrapped to the next line.  The default
              line length is 70 characters.  (type=C{int})
            - C{variable_summary_linelength}: The maximum line length
              used for displaying the values of variables in the summary
              section.  If a line is longer than this length, then it
              will be truncated.  The default is 40 characters.
              (type=C{int})
            - C{variable_tooltip_linelength}: The maximum line length
              used for tooltips for the values of variables.  If a
              line is longer than this length, then it will be
              truncated.  The default is 600 characters.  (type=C{int})
            - C{inheritance}: How inherited objects should be displayed.
              If C{inheritance='grouped'}, then inherited objects are
              gathered into groups; if C{inheritance='listed'}, then
              inherited objects are listed in a short list at the
              end of their group; if C{inheritance='included'}, then
              inherited objects are mixed in with non-inherited
              objects.  The default is 'grouped'.  (type=C{string})
        """
        self._docmap = docmap

        # Process keyword arguments.
        self._prj_name = kwargs.get('prj_name', None)
        self._prj_url = kwargs.get('prj_url', None)
        self._prj_link = kwargs.get('prj_link', None)
        self._top_page = self._find_top_page(kwargs.get('top', None))
        self._css = kwargs.get('css')
        self._private_css = kwargs.get('private_css') or self._css
        self._helpfile = kwargs.get('help', None)
        self._create_private_docs = kwargs.get('private', 1)
        self._frames_index = kwargs.get('frames', 1)
        self._show_imports = kwargs.get('show_imports', 0)
        self._index_parameters = kwargs.get('index_parameters', 0)
        self._variable_maxlines = kwargs.get('variable_maxlines', 8)
        self._variable_linelen = kwargs.get('variable_linelength', 70)
        self._variable_summary_linelen = \
                         kwargs.get('variable_summary_linelength', 40)
        self._variable_tooltip_linelen = \
                         kwargs.get('variable_tooltip_linelength', 600)
        self._inheritance = kwargs.get('inheritance', 'grouped')

        # Create the project homepage link, if it was not specified.
        if (self._prj_name or self._prj_url) and not self._prj_link:
            name = self._prj_name or 'Project Homepage'
            name = name.replace('&', '&amp;')
            name = name.replace('<', '&lt;')
            name = name.replace('>', '&gt;')
            name = name.replace(' ', '&nbsp;')
            self._prj_link = name

        # Add a hyperlink to _prj_url, if _prj_link doesn't already
        # contain any hyperlinks.
        if (self._prj_link and self._prj_url and
            not re.search(r'<a[^>]*\shref', self._prj_link)):
            self._prj_link = ('<a class="navbar" target="_top" href="'+
                              self._prj_url+'">'+self._prj_link+'</a>')

    def num_files(self):
        """
        @return: The number of files that this C{HTMLFormatter} will
            generate.
        @rtype: C{int}
        """
        # Basic files (index.html, tree, indices, help, css, toc,
        # toc-everything, frames, base directory index.html, base
        # directory css)
        if self._create_private_docs: n = 12
        else: n = 8

        for uid in self._docmap.keys():
            # Module and class API files
            if not (uid.is_module() or uid.is_class()): continue
            n += 1
            #if self._create_private_docs: n += 1
            ##elif uid.is_public(): n += 1

            # Module TOC files.
            if not uid.is_module(): continue
            n += 1
            #if self._create_private_docs: n += 1
            ##elif uid.is_public(): n += 1
        return n

    #////////////////////////////////////////////////////////////
    # Write (and its helpers)
    #////////////////////////////////////////////////////////////
    
    def write(self, directory=None, progress_callback=None):
        """
        Write the documentation to the given directory.

        @type directory: C{string}
        @param directory: The directory to which output should be
            written.  If no directory is specified, output will be
            written to the current directory.  If the directory does
            not exist, it will be created.
        @type progress_callback: C{function}
        @param progress_callback: A callback function that is called
            before each file is written, with the name of the created
            file.
        @rtype: C{None}
        @raise OSError: If C{directory} cannot be created,
        @raise OSError: If any file cannot be created or written to.
        """
        if not directory: directory = os.curdir
        self._show_private = 0 # ELIM THIS
        
        public_directory = os.path.join(directory, 'public')
        private_directory = os.path.join(directory, 'private')

        # Keep track of failed xrefs, and report them at the end.
        self._failed_xrefs = {}

        # Create destination directories, if necessary
        self._mkdir(directory)
        if self._create_private_docs:
            self._mkdir(public_directory)
            self._mkdir(private_directory)

        # Write the tree file (package & class hierarchies)
        self._write(self._write_trees, directory,
                     'trees.html', progress_callback)
        
        # Write the term & identifier indices
        self._write(self._write_indices, directory,
                     'indices.html', progress_callback)
        
        # Write the help file.
        self._write(self._write_help, directory,
                     'help.html', progress_callback)
        
        # Write the frames-based table of contents.
        self._write(self._write_frames, directory, 'frames.html',
                     progress_callback)
        self._write(self._write_toc, directory, 'toc.html',
                     progress_callback)
        self._write(self._write_project_toc, directory,
                     'toc-everything.html', progress_callback)
        for (uid, doc) in self._docmap.items():
            if uid.is_module():
                filename = 'toc-%s' % self._uid_to_filename(uid)
                self._write(self._write_module_toc, directory, filename,
                             progress_callback, uid, doc)
        
        # Write the object documentation.
        for (uid, doc) in self._docmap.items():
            if not (isinstance(doc, ModuleDoc) or
                    isinstance(doc, ClassDoc)): continue
            filename = self._uid_to_filename(uid)
            if isinstance(doc, ModuleDoc):
                self._write(self._write_module, directory, filename,
                             progress_callback, uid, doc)
            else:
                self._write(self._write_class, directory, filename,
                             progress_callback, uid, doc)
        
        # Write the CSS files.
        if self._create_private_docs:
            self._write_css(public_directory, progress_callback, self._css)
            self._write_css(private_directory, progress_callback,
                            self._private_css)
            self._write_css(directory, progress_callback, self._css)
        else:
            self._write_css(directory, progress_callback, self._css)

        # Write the index.html files.
        if self._create_private_docs:
            self._write_index(public_directory, progress_callback, 0)
            self._write_index(private_directory, progress_callback, 0)
            self._write_index(directory, progress_callback, 1)
        else:
            self._write_index(directory, progress_callback, 0)

    def _write(self, func, directory, filename, progress_callback, *args):
        """
        A helper for L{write}, that creates new public and private
        streams for a given filename, and delegates writing to
        C{func}.  If L{_create_private_docs} is true, then the streams
        are created in the C{'public'} and C{'private'} subdirectories
        of C{directory}.  If it's false, then the public stream is
        created in C{directory}, and a L{_DevNull} is used for the
        private stream.

        @param func: The output function to delegate to.  It is called
            with a public stream, a private stream, and any arguments
            given in C{args}.
        @param directory: The base directory of the output.
        @param filename: The filename of the file(s) that C{func}
            should write to.
        @param progress_callback: A progress callback function.  If it
            is not C{None}, then it is called with C{filename} before
            C{func} is called.
        @param args: Extra arguments for C{func}
        """
        # IF IT'S A PRIVATE OBJECT, THEN PUBLIC SHOULD BE _DEVNULL
        if progress_callback: progress_callback(filename)
        if self._create_private_docs:
            public = open(os.path.join(directory, 'public', filename), 'w')
            private = open(os.path.join(directory, 'private', filename), 'w')
        else:
            public = open(os.path.join(directory, filename), 'w')
            private = _DevNull()
        func(public, private, *args)
        public.close()
        private.close()

    def _mkdir(self, directory):
        if not os.path.isdir(directory):
            if os.path.exists(directory):
                raise OSError('%r is not a directory' % directory)
            os.mkdir(directory)
        
    def _write_frames(self, public, private):
        prj_name = self._prj_name or "API Documentation"
        str = FRAMES_INDEX % (prj_name, self._top_page)
        public.write(str); private.write(str)

    def _write_index(self, directory, progress_callback, frombase):
        """
        Write the C{index.html} file to the given file.
        
        @param frombase: True if this is the index file for the base
            directory when we are generating both public and private
            documentation.  In this case, all hyperlinks should be
            changed to point into the C{public} subdirectory.
        @type frombase: C{boolean}
        """
        filename = os.path.join(directory, 'index.html')
        if progress_callback: progress_callback(filename)
        if self._frames_index: top = 'frames.html'
        else: top = self._top_page

        # Copy the non-frames index file from top, if it's internal.
        if top[:5] != 'http:' and '/' not in top:
            try:
                # Read top into str.
                if frombase:
                    pubdir = os.path.join(directory, 'public')
                    topfile = os.path.join(pubdir, top)
                else:
                    topfile = os.path.join(directory, top)
                str = open(topfile, 'r').read()

                # Redirect links, if appropriate.
                if frombase:
                    # Excluding ":" makes sure we don't get any links
                    # to external targets (like href="http://...")
                    INTERNAL_LINK = r'(<a[^>]+href=")([^:">]+"[^>]*>)'
                    FRAME_LINK = r'(<frame[^>]+src=")([^:">]+"[^>]*>)'
                    str = re.sub(INTERNAL_LINK, r'\1public/\2', str)
                    str = re.sub(FRAME_LINK, r'\1public/\2', str)

                # Write the output file.
                open(filename, 'w').write(str)
                return
            except:
                if sys.stderr.softspace: print >>sys.stderr
                estr = 'Warning: error copying index; using a redirect page'
                print >>sys.stderr, estr
                if frombase: top = 'public/%s' % top

        # Use a redirect if top is external, or if we faild to copy.
        name = self._prj_name or 'this project'
        open(filename, 'w').write(REDIRECT_INDEX % (top, top, name))

    def _write_help(self, public, private):
        """
        Write the help file to the given file.  If C{self._helpfile}
        contains a help file, then use it; otherwise, use the default
        helpfile.

        @rtype: C{None}
        """
        # Get the contents of the help file.
        if self._helpfile:
            if os.path.exists(self._helpfile):
                try: help = open(self._helpfile).read()
                except: raise IOError("Can't open help file: %r" %
                                      self._helpfile)
            else:
                raise IOError("Can't find help file: %r" % self._helpfile)
        else:
            if self._prj_name: thisprj = self._prj_name
            else: thisprj = 'this project'
            help = HTML_HELP % {'this_project':thisprj}

        # Write the header & navbar
        header = self._header('Help')
        public.write(header); private.write(header)
        self._write_navbar(public, private, 'help', top=1)
        
        # Write the help file.
        public.write(help)
        private.write(help)

        # Write the footer
        self._write_navbar(public, private, 'help', top=0)
        footer = self._footer()
        public.write(footer); private.write(footer)

    def _write_css(self, directory, progress_callback, cssname):
        """
        Write the CSS stylesheet to the given file.  If
        C{self._css} contains a stylesheet file or name (from
        L{epydoc.css}), then use that stylesheet; otherwise, if a
        stylesheet file already exists, use that stylesheet.
        Otherwise, use the default stylesheet.

        @rtype: C{None}
        """
        filename = os.path.join(directory, 'epydoc.css')
        if progress_callback: progress_callback(filename)
        
        # Get the contents for the stylesheet file.  If none was
        # specified, and a stylesheet is already present, then don't
        # do anything.
        if cssname is None:
            if os.path.exists(filename):
                return
            else: css = STYLESHEETS['default'][0]
        else:
            if os.path.exists(cssname):
                try: css = open(cssname).read()
                except: raise IOError("Can't open CSS file: %r" % cssname)
            elif STYLESHEETS.has_key(cssname):
                css = STYLESHEETS[cssname][0]
            else:
                raise IOError("Can't find CSS file: %r" % cssname)

        # Write the stylesheet.
        cssfile = open(filename, 'w')
        cssfile.write(css)
        cssfile.close()
                       
    #////////////////////////////////////////////////////////////
    # HTML page generation
    #////////////////////////////////////////////////////////////
    # Each of these functions creates a single HTML file, and returns
    # it as a string.

    def _write_module(self, public, private, uid, doc):
        # Write the header, navbar, & module name
        str = self._header(uid.name())
        private.write(str)
        public.write(str)

        self._write_navbar(public, private, uid, top=1)

        sio = StringIO()
        if uid.is_package(): sio.write(self._start_of('Package Description'))
        else: sio.write(self._start_of('Module Description'))
        if uid.is_package():
            sio.write('<h2 class="package">Package '+uid.name()+'</h2>\n\n')
        else:
            sio.write('<h2 class="module">Module '+uid.name()+'</h2>\n\n')

        # Write the module's description.
        if doc.descr():
            sio.write(self._docstring_to_html(doc.descr(), uid) + '<hr/>\n')

        # Add version, author, warnings, requirements, notes, etc.
        sio.write(self._standard_fields(doc))

        public.write(sio.getvalue())
        private.write(sio.getvalue())
        sio = None

        # If it's a package, add a list of sub-modules.
        if doc.ispackage():
            self._write_module_list(public, private, doc.modules(),
                                    doc.by_group(doc.modules()))

        # Show the summaries for classes, exceptions, functions, and
        # variables contained in the module.
        (classes,excepts) = self._split_classes(doc.classes())
        self._write_class_summary(public, private, classes,
                                  doc.by_group(classes), 'Classes')
        self._write_class_summary(public, private, excepts,
                                  doc.by_group(excepts), 'Exceptions')
        self._write_func_summary(public, private, doc.functions(), None,
                                 doc.by_group(doc.functions()),
                                 'Function Summary')
        self._write_var_summary(public, private, doc.variables(), uid,
                                doc.by_group(doc.variables()),
                                'Variable Summary')
        
        # Show a list of all imported objects.
        (iclasses,iexcepts) = self._split_classes(doc.imported_classes())
        self._write_imports(public, private, iclasses, iexcepts,
                            doc.imported_functions(),
                            doc.imported_variables())

        # Show details for the functions and variables.
        self._write_func_details(public, private, doc.functions(), None)
        self._write_var_details(public, private, doc.variables(), uid)

        # Add another navigation bar and the footer.
        self._write_navbar(public, private, uid, top=0)
        footer = self._footer()
        public.write(footer)
        private.write(footer)

    def _write_class(self, public, private, uid, doc):
        """
        @return: An HTML page describing the class identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the class that should
            be documented.
        @type uid: L{UID}
        """
        # Write the header, navigation bar, & class name.
        str = self._header(uid.name())
        private.write(str)
        public.write(str)

        self._write_navbar(public, private, uid, top=1)
        
        str = self._start_of('Class Description')
        str += '<h2 class="class">Class ' + uid.shortname()+'</h2>\n\n'

        # Write the base class tree
        if doc.bases():
            str += '<pre class="base-tree">\n' 
            str += self._base_tree(uid) 
            str += '</pre><br />\n\n'

        private.write(str)
        public.write(str)

        # Write the class's known subclasses
        subclasses = doc.subclasses()
        if subclasses:
            header = '<dl><dt><b>Known Subclasses:</b></dt>\n<dd>\n    '
            _write_if_nonempty(public, private, subclasses, header)
            private.write(',\n    '.join([self._link_to_html(s)
                                          for s in subclasses]))
            public.write(',\n    '.join([self._link_to_html(s)
                                         for s in subclasses
                                         if s.is_public()]))
            footer = '</dd></dl>\n\n'
            _write_if_nonempty(public, private, subclasses, footer)

        # Write the class's description
        str = '<hr/>\n\n'
        if doc.descr():
            str += '%s<hr/>\n\n' % self._docstring_to_html(doc.descr(), uid)
        private.write(str)
        public.write(str)

        # Add version, author, warnings, requirements, notes, etc.
        str = self._standard_fields(doc)
        private.write(str)
        public.write(str)

        # Show the summaries for methods, instance variables, and
        # class variables contained in the class.
        self._write_func_summary(public, private, doc.allmethods(), doc,
                                 doc.by_group(doc.allmethods()),
                                 'Method Summary')
        self._write_property_summary(public, private, doc.properties(),
                                     uid, doc.by_group(doc.properties()),
                                     'Property Summary')
        self._write_var_summary(public, private, doc.ivariables(), uid,
                                doc.by_group(doc.ivariables()),
                                'Instance Variable Summary')
        self._write_var_summary(public, private, doc.cvariables(), uid,
                                doc.by_group(doc.cvariables()),
                                'Class Variable Summary')

        # Show details for methods
        if doc.staticmethods() or doc.classmethods():
            self._write_func_details(public, private, doc.methods(),
                                     doc, 'Instance Method Details')
            self._write_func_details(public, private, doc.staticmethods(),
                                     doc, 'Static Method Details')
            self._write_func_details(public, private, doc.classmethods(),
                                     doc, 'Class Method Details')
        else:
            self._write_func_details(public, private, doc.methods(),
                                     doc, 'Method Details')

        # Show details for variables.
        self._write_property_details(public, private, doc.properties(),
                                     uid, 'Property Details')
        self._write_var_details(public, private, doc.ivariables(),
                                uid, 'Instance Variable Details')
        self._write_var_details(public, private, doc.cvariables(),
                                uid, 'Class Variable Details')

        # Add a navigation bar and the footer.
        self._write_navbar(public, private, uid, top=0)
        footer = self._footer()
        public.write(footer)
        private.write(footer)

    def _write_trees(self, public, private):
        """
        @return: An HTML page containing the module and class
            hierarchies. 
        @rtype: C{string}
        """
        # Header and navigation bar
        header = self._header('Module and Class Hierarchies')
        private.write(header)
        public.write(header)

        self._write_navbar(public, private, 'trees', top=1)

        # Module hierarchy
        str = self._start_of('Module Hierarchy')
        str += '<h2>Module Hierarchy</h2>\n'
        private.write(str)
        public.write(str)
        
        self._write_module_tree(public, private)

        # Does the project define any classes?
        defines_classes = 0
        for uid in self._docmap.keys():
            if uid.is_class(): defines_classes = 1; break

        # Class hierarchy
        if defines_classes:
            str = self._start_of('Class Hierarchy')
            str += '<h2>Class Hierarchy</h2>\n'
            private.write(str)
            public.write(str)
            self._write_class_tree(public, private)

        # Add a navigation bar and the footer.
        self._write_navbar(public, private, uid, top=0)
        footer = self._footer()
        public.write(footer)
        private.write(footer)

    def _write_indices(self, public, private):
        """
        Write the index to the given file-like object.  I write
        directly to the file (unlike most other pages, which are
        converted to strings, and then written) because the index page
        can be quite large.  For example, for the Python standard
        library, the index page is over 1.5mb.
        @param out: The stream to which the index should be written.
        @type out: C{stream}
        @rtype: C{None}
        """
        # Header and navigation bar.
        header = self._header('Index')
        public.write(header); private.write(header)
        self._write_navbar(public, private, 'indices', top=1)
        public.write('<br />\n'); private.write('<br />\n')

        # Term index
        index_terms, index_links = self._extract_term_index()
        if index_terms:
            header = (self._start_of('Term Index') +
                      self._table_header('Term Index', 'index'))
            public.write(header); private.write(header)
            terms = index_terms.keys()
            terms.sort()
            for term in terms:
                termtext = index_terms[term].to_plaintext(None)
                str = '  <tr><td width="15%">'+termtext
                str += '</td>\n    <td>'
                index_links[term].sort()
                for link in index_links[term]:
                    str += ('<i><a href="%s#%s">%s</a></i>, ' %
                            (self._uid_to_uri(link.target()),
                             term, link.name()))
                str = str[:-2] + '</tr></td>\n'
                # Should public link to private terms here??? !!!
                public.write(str); private.write(str)
            footer = '</table>\n<br />\n'
            public.write(footer); private.write(footer)

        # Identifier index # !!! Check for empty public?
        identifiers = self._extract_identifier_index()
        if identifiers:
            header = (self._start_of('Identifier Index') +
                      self._table_header('Identifier Index', 'index'))
            _write_if_nonempty(public, private, identifiers, header)
            for uid in identifiers:
                href = self._uid_to_href(uid, uid.shortname())

                # Create the description string.
                if uid.is_package(): descr = 'Package'
                elif uid.is_module(): descr = 'Module'
                elif uid.is_class(): descr = 'Class'
                elif uid.is_variable(): descr = 'Variable'
                elif uid.is_method() or uid.is_builtin_method():
                    descr = 'Method'
                elif uid.is_function() or uid.is_builtin_function():
                    descr = 'Function'
                puid = uid.parent()
                if puid:
                    if puid.is_package(): descr +=' in package '
                    elif puid.is_module(): descr +=' in module '
                    elif puid.is_class(): descr +=' in class '
                    else: descr +=' in '
                    descr += self._uid_to_href(uid.parent())

                # Write the index entry.
                str = ('  <tr><td width="15%%">%s</td>\n' % href +
                       '    <td>%s</td></tr>\n' % descr)
                private.write(str)
                if uid.is_public(): public.write(str)

            footer = '</table>\n<br />\n'
            _write_if_nonempty(public, private, identifiers, footer)

        # Navigation bar and footer.
        self._write_navbar(public, private, 'indices', top=0)
        footer = self._footer()
        public.write(footer); private.write(footer)

    def _write_toc(self, private, public):
        """
        @return: An HTML page containing the top-level table of
            contents page.  This page is used to select a module table
            of contents page, or the "everything" table of contents
            page. 
        @rtype: C{string}
        """
        uids = self._docmap.keys()

        # Header
        str = self._header('Table of Contents')
        str += ('<center><font size="+1"><b>Table&nbsp;of&nbsp;'
                 'Contents</b></font></center>\n<hr>\n')
        public.write(str); private.write(str)

        # Class table of contents (all classes/exceptions)
        str = ('<a target="moduleFrame" href="%s">%s</a><br />\n' %
                ('toc-everything.html', 'Everything'))
        public.write(str); private.write(str)

        # Package table of contents (individual packages)
        str = self._start_of('Packages')
        str += '<br /><font size="+1"><b>Packages</b></font><br />\n'
        public.write(str); private.write(str)
        for uid in uids:
            if uid.is_package():
                str = ('<a target="moduleFrame" href="toc-%s">'+
                       '%s</a><br />\n') % (self._uid_to_uri(uid), uid)
                private.write(str)
                if uid.is_public(): public.write(str)

        # Module table of contents (individual modules)
        str = self._start_of('Modules')
        str += '<br /><font size="+1"><b>Modules</b></font><br />\n'
        public.write(str); private.write(str)
        for uid in uids:
            if uid.is_module() and not uid.is_package():
                str = ('<a target="moduleFrame" href="toc-%s">'+
                       '%s</a><br />\n') % (self._uid_to_uri(uid), uid)
                private.write(str)
                if uid.is_public(): public.write(str)
                
        # The private/public link.
        if self._create_private_docs:
            str = '\n<br /><hr>\n'
            public.write(str); private.write(str)
            public.write(self._public_private_link('toc', from_private=0))
            private.write(self._public_private_link('toc', from_private=1))
        
        str = '\n</body>\n</html>\n'
        public.write(str); private.write(str)

    def _write_project_toc(self, public, private):
        """
        @return: An HTML page containing the table of contents page
            for the whole project.  This page lists the classes,
            exceptions, functions, and variables defined by any module
            or package in the project.
        @rtype: C{string}
        """
        # Header and name.
        str = self._header('Everything')
        str += ('<center><font size="+1"><b>Everything</b>' +
                 '</font></center>\n<hr>\n')
        public.write(str); private.write(str)

        # Find classes & exceptions
        classes = [Link(c.name(),c) for c in self._docmap.keys()
                   if c.is_class()]
        (classes,excepts) = self._split_classes(classes)

        # Find functions & variables
        funcs = []; vars = []
        for (uid, doc) in self._docmap.items():
            if isinstance(doc, ModuleDoc):
                funcs += doc.functions()
                vars += doc.variables()
        
        # Only include objects that come from modules that we
        # documented.  In particular, do not include base classes,
        # inherited methods, and imported objects from other modules
        # in the index.  But *do* include objects whose modules we
        # can't determine (why?).
        self._docmap[None] = None # <- something of a hack. :-/
        classes = [c for c in classes
                   if self._docmap.has_key(c.target().module())]
        excepts = [e for e in excepts
                   if self._docmap.has_key(e.target().module())]
        funcs = [f for f in funcs
                 if self._docmap.has_key(f.target().module())]
        vars = [v for v in vars
                if self._docmap.has_key(v.uid().module())]
        del self._docmap[None] # <- eliminate hack (see above)

        # Class and excpetion lists.
        str = self._start_of('All Classes')
        public.write(str); private.write(str)
        self._write_toc_section(public, private, 'All&nbsp;Classes', classes)
        
        str = self._start_of('All Exceptions')
        public.write(str); private.write(str)
        self._write_toc_section(public, private, 'All&nbsp;Exceptions',
                                excepts)
        
        str = self._start_of('All Functions')
        public.write(str); private.write(str)
        self._write_toc_section(public, private, 'All&nbsp;Functions', funcs)
        
        str = self._start_of('All Variables')
        public.write(str); private.write(str)
        self._write_toc_section(public, private, 'All&nbsp;Variables', vars)

        # The private/public link.
        if self._create_private_docs:
            str = '\n<hr>\n'
            public.write(str); private.write(str)
            public.write(self._public_private_link('toc', from_private=0))
            private.write(self._public_private_link('toc', from_private=1))

        str = '\n</body>\n</html>\n'
        public.write(str); private.write(str)

    def _write_module_toc(self, public, private, uid, doc):
        """
        @return: An HTML page containing the table of contents page
            for the given module.  This page lists the modules,
            classes, exceptions, functions, and variables defined by
            the module. 
        @rtype: C{string}
        """
        doc = self._docmap[uid]
        (classes,excepts) = self._split_classes(doc.classes())

        # Header and name.
        str = self._header(uid.name())
        str += (('<center><font size="+1"><b><a target="mainFrame" '+
                'href="%s">%s</a></b></font></center>\n<hr>\n')
                % (self._uid_to_uri(uid), uid.shortname()))
        public.write(str); private.write(str)
        
        # Lists of modules, classes, exceptions, functions, and variables.
        if uid.is_package():
            self._write_toc_section(public, private, 'Modules', doc.modules())
        self._write_toc_section(public, private, 'Classes', classes)
        self._write_toc_section(public, private, 'Exceptions', excepts)
        self._write_toc_section(public, private, 'Functions', doc.functions())
        self._write_toc_section(public, private, 'Variables', doc.variables())
                                 
        # The private/public link.
        if self._create_private_docs:
            str = '\n<hr>\n'
            public.write(str); private.write(str)
            public.write(self._public_private_link('toc', from_private=0))
            private.write(self._public_private_link('toc', from_private=1))

        str = '\n</body>\n</html>\n'
        public.write(str); private.write(str)
    
    #////////////////////////////////////////////////////////////
    # Navigation bar
    #////////////////////////////////////////////////////////////
    # The navigation bar is placed at the top & bottom of every HTML
    # page.

    def _navbar(self, *args): return ''
    def _write_navbar(self, public, private, where=None, top=0):
        """
        @return: The HTML code for a navigation bar on the given type
            of page.  The navigation bar typically looks like::
            
                [ Package Module Class Tree Index Help ]
                
        @rtype: C{string}
        @param where: An identifier indicating what page we're
            creating a navigation bar for.  This is either a UID
            (for an object documentation page); or one of the strings
            C{'tree'}, C{'index'}, and C{'help'}.
        @type where: C{UID} or C{string}
        @param top: Whether this is the navigation bar at the top of
            the page.
        @type top: C{boolean}
        """
        sio = StringIO()
        sio.write(self._start_of('Navbar'))
        sio.write('<table class="navbar" border="0" width="100%"')
        sio.write(' cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">\n')
        sio.write('  <tr valign="center">\n')

        # The "Home" link
        if self._top_page in ('trees.html', 'indices.html',
                              'help.html'):
            pass # We already have a link for these.
        elif (isinstance(where, UID) and
            self._uid_to_uri(where) == self._top_page):
            sio.write('    <th bgcolor="#70b0f0" class="navselect">&nbsp;')
            sio.write('&nbsp;&nbsp;Home&nbsp;&nbsp;&nbsp;</th>\n')
        else:
            sio.write('    <th class="navbar">&nbsp;&nbsp;&nbsp;<a ')
            sio.write('class="navbar" href="%s">Home</a>' % self._top_page)
            sio.write('&nbsp;&nbsp;&nbsp;</th>\n' )

        # The "Tree" link
        if where == 'trees':
            sio.write('    <th bgcolor="#70b0f0" class="navselect">&nbsp;')
            sio.write('&nbsp;&nbsp;Trees&nbsp;&nbsp;&nbsp;</th>\n')
        else:
            sio.write('    <th class="navbar">&nbsp;&nbsp;&nbsp;')
            sio.write('<a class="navbar" href="trees.html">Trees</a>')
            sio.write('&nbsp;&nbsp;&nbsp;</th>\n')

        # The "Index" link
        if where == 'indices':
            sio.write('    <th bgcolor="#70b0f0" class="navselect">&nbsp;')
            sio.write('&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;</th>\n')
        else:
            sio.write('    <th class="navbar">&nbsp;&nbsp;&nbsp;')
            sio.write('<a class="navbar" href="indices.html">Index</a>')
            sio.write('&nbsp;&nbsp;&nbsp;</th>\n')

        # The "Help" link
        if where == 'help':
            sio.write('    <th bgcolor="#70b0f0" class="navselect">&nbsp;')
            sio.write('&nbsp;&nbsp;Help&nbsp;&nbsp;&nbsp;</th>\n')
        else:
            sio.write('    <th class="navbar">&nbsp;&nbsp;&nbsp;')
            sio.write('<a class="navbar" href="help.html">Help</a>')
            sio.write('&nbsp;&nbsp;&nbsp;</th>\n')

        if self._prj_link:
            sio.write('    <th class="navbar" align="right" width="100%">\n')
            sio.write('      <table border="0" cellpadding="0" cellspacing="0">\n')
            sio.write('      <tr><th class="navbar" align="center">\n')
            sio.write('        <p class="nomargin">\n          ')
            sio.write(self._prj_link)
            sio.write('\n      </p></th></tr></table>\n')
            sio.write('    </th>\n')
        else:
            sio.write('    <th class="navbar" width="100%"></th>\n')
        sio.write('  </tr>\n</table>\n')
        str = sio.getvalue()
        public.write(str)
        private.write(str)

        # Breadcrumb, frames, and private/public link
        if top:
            str = '<table width="100%" cellpadding="0" cellspacing="0">\n'
            str += '  <tr valign="top">\n    <td width="100%">\n'
            if isinstance(where, UID): str += self._breadcrumbs(where)
            str += '    </td>\n    <td>'
            str += '<table cellpadding="0" cellspacing="0">\n'
            public.write(str)
            private.write(str)
            if self._create_private_docs:
                link = self._public_private_link(where, from_private=0)
                public.write('      <tr><td align="right">%s</td></tr>\n'
                             % link)
                link = self._public_private_link(where, from_private=1)
                private.write('      <tr><td align="right">%s</td></tr>\n'
                             % link)
            str = ('      <tr><td align="right">%s</td></tr>\n' %
                    self._frames_link(where))
            str += '    </table></td>'
            str += '</tr></table>\n'
            public.write(str)
            private.write(str)
            
    def _frames_link(self, where):
        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        return ('<font size="-2">[<a href="frames.html"'+
                'target="_top">frames</a>&nbsp;|&nbsp;<a href="'+uri+
                '" target="_top">no&nbsp;frames</a>]</font>')
    
    def _public_private_link(self, where, toc=0, from_private=0):
        """
        @return: The HTML code for a link between the public & private
            copies of the documentation.
        @rtype: C{string}
        """
        # For private pages, there's no corresponding public page..
        if isinstance(where, UID) and where.is_private():
            return ('<font size="-2">[<b>show&nbsp;private</b>' +
                    '&nbsp;|&nbsp;hide&nbsp;private]</font>')

        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        if toc: uri = 'toc-'+uri
        
        if from_private:
            return ('<font size="-2">[show&nbsp;private&nbsp;|&nbsp;' +
                    '<a href="../public/' + uri + '">hide&nbsp;private' +
                    '</a>]</font>')
        else:
            return ('<font size="-2">[<a href="../private/' + uri +
                    '">show&nbsp;private</a>&nbsp;|&nbsp;hide&nbsp;' +
                    'private]</font>')
    
    def _breadcrumbs(self, uid):
        """
        @return: The HTML code for a series of links to the parents of
            C{uid}.
        @rtype: C{string}
        """
        #if not uid.parent(): return '</br>\n'
        if uid.is_package(): crumbs = ['Package&nbsp;%s' % uid.shortname()]
        elif uid.is_module(): crumbs = ['Module&nbsp;%s' % uid.shortname()]
        elif uid.is_class(): crumbs = ['Class&nbsp;%s' % uid.shortname()]
        uid = uid.parent()
        while uid is not None:
            if uid.is_package(): label = 'Package&nbsp;%s' % uid.shortname()
            elif uid.is_module(): label = 'Module&nbsp;%s' % uid.shortname()
            elif uid.is_class(): label = 'Class&nbsp;%s' % uid.shortname()
            else: raise ValueError('Bad uid type for breadcrumbs')
            crumbs.append(self._uid_to_href(uid, label, code=0))
            uid = uid.parent()
        crumbs.reverse()
        str = '<font size="-1"><b class="breadcrumbs">\n  '
        str += ' ::\n  '.join(crumbs)
        str += '</b></font></br>\n'
        return str

    #////////////////////////////////////////////////////////////
    # Base class trees
    #////////////////////////////////////////////////////////////
    
    def _find_tree_width(self, uid):
        """
        @return: The width of a base tree, when drawn
            right-justified.  This is used by L{_base_tree} to
            determine how far to indent lines of the base tree.
        @rtype: C{int}
        """
        width = 2
        if self._docmap.has_key(uid):
            for base in self._docmap[uid].bases():
                width = max(width, len(base.name())+4)
                width = max(width, self._find_tree_width(base.target())+4)

        return width
        
    def _base_tree(self, uid, width=None, postfix=''):
        """
        @return: The HTML code for a class's base tree.  The tree is
            drawn 'upside-down' and right justified, to allow for
            multiple inheritance.
        @rtype: C{string}
        """
        if not self._docmap.has_key(uid): return ''
        if width == None:
            width = self._find_tree_width(uid)
        
        bases = self._docmap[uid].bases()
        
        if postfix == '':
            str = ' '*(width-2) + '<b>'+uid.shortname()+'</b>\n'
        else: str = ''
        for i in range(len(bases)-1, -1, -1):
            base = bases[i]
            str = (' '*(width-4-len(base.name())) +
                   self._link_to_html(base)+' --+'+postfix+'\n' + 
                   ' '*(width-4) +
                   '   |'+postfix+'\n' +
                   str)
            (t,w) = (base.target(), width)
            if i != 0:
                str = (self._base_tree(t, w-4, '   |'+postfix)+str)
            else:
                str = (self._base_tree(t, w-4, '    '+postfix)+str)
        ss = re.sub('<[^<>]+>','',str)
        return str
                
    #////////////////////////////////////////////////////////////
    # Class hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _class_tree_item(self, uid, filter_private, depth=0):
        """
        Helper function for L{_write_class_tree}.
        """
        if uid is None: return
        if filter_private and uid.is_private(): return ''
        doc = self._docmap.get(uid, None)
        str = ' '*depth + '<li> <b>' + self._uid_to_href(uid)+'</b>'
        if doc and doc.descr():
            str += ': <i>' + self._summary(doc, uid) + '</i>'
        str += '\n'
        
        if doc and doc.subclasses():
            str += ' '*depth + '  <ul>\n'
            children = [l.target() for l in doc.subclasses()]
            if filter_private:
                children = [c for c in children if c.is_public()]
            for child in children:
                str += self._class_tree_item(child, filter_private, depth+4)
            str += ' '*depth + '  </ul>\n'
        return str

    def _write_class_tree(self, public, private):
        """
        @return: The HTML code for the class hierarchy tree.  This is
            used by L{_trees_to_html} to construct the hierarchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        public.write(str); private.write(str)

        for uid in self._docmap.keys():
            doc = self._docmap[uid]
            if not isinstance(doc, ClassDoc): continue
            hasbase = 0
            for base in doc.bases():
                if self._docmap.has_key(base.target()):
                    hasbase = 1
            if not hasbase:
                public.write(self._class_tree_item(uid, filter_private=0))
                private.write(self._class_tree_item(uid, filter_private=1))

        str = '</ul>\n'
        public.write(str); private.write(str)

    #////////////////////////////////////////////////////////////
    # Module hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _write_module_tree(self, public, private):
        """
        @return: The HTML code for the module hierarchy tree.  This is
            used by L{_trees_to_html} to construct the hiearchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        public.write(str); private.write(str)
        # Find all top-level packages.
        for (uid, doc) in self._docmap.items():
            if not isinstance(doc, ModuleDoc): continue
            pkg = doc.package()
            if pkg is None or not self._docmap.has_key(pkg):
                self._write_module_tree_item(public, private, uid)
        str = '</ul>\n'
        public.write(str); private.write(str)

    def _write_module_list(self, public, private, modules, groups):
        """
        @return: The HTML code for the module hierarchy tree,
            containing the given modules.  This is used by
            L{_module_to_html} to list the submodules of a package.
        @rtype: C{string}
        """
        if len(modules) == 0: return

        # Write the table header.
        header = self._table_header('Submodules', 'details')
        _write_if_nonempty(public, private, modules, header)

        for name, group in groups:            
            # Print a group header.
            if name is not None:
                header = self._group_header(name)
                _write_if_nonempty(public, private, group, header)

            # Add lines for each submodule
            _write_if_nonempty(public, private, group, '  <tr><td><ul>\n')
            for module in group:
                self._write_module_tree_item(public, private, module.target())
            _write_if_nonempty(public, private, group, '  </ul></td></tr>\n')

        # Write the table footer.
        _write_if_nonempty(public, private, modules, '</table><br />\n\n')

    def _write_module_tree_item(self, public, private, uid, depth=0):
        """
        Helper function for L{_module_tree} and L{_module_list}.
        
        @rtype: C{string}
        """
        if uid is None: return

        # Write the module itself.
        doc = self._docmap.get(uid, None)
        name = uid.shortname()
        str = ' '*depth + '<li> <b>'
        str += self._uid_to_href(uid, name)+'</b>'
        if doc and doc.descr():
            str += ': <i>' + self._summary(doc, uid) + '</i>'
        str += '\n'
        private.write(str)
        if uid.is_public(): public.write(str)

        # Write the list of submodules.
        if doc and doc.ispackage() and doc.modules():
            modules = [l.target() for l in doc.modules()]
            _write_if_nonempty(public, private, modules,
                               ' '*depth + '  <ul>\n')
            for module in modules:
                self._write_module_tree_item(public, private, module, depth+4)
            _write_if_nonempty(public, private, modules,
                               ' '*depth + '  </ul>\n')
        str = ' '*depth+'</li>\n'
        private.write(str)
        if uid.is_public(): public.write(str)

    #////////////////////////////////////////////////////////////
    # Class tables
    #////////////////////////////////////////////////////////////
    
    def _write_class_summary(self, public, private, classes,
                             groups, heading='Class Summary'):
        """
        @return: The HTML code for the class summary table.  This is
            used by L{_module_to_html} to list the classes in a
            module.
        @rtype: C{string}
        """
        if len(classes) == 0: return

        # Write the table header
        header = self._table_header(heading, 'summary')
        _write_if_nonempty(public, private, classes, header)

        for name, group in groups:
            # Print a group header
            if name is not None:
                header = self._group_header(name)
                _write_if_nonempty(public, private, group, header)

            # Add lines for each class
            for cls in group:
                self._write_class_summary_line(public, private, cls)

        # Write the table footer
        _write_if_nonempty(public, private, classes, '</table><br />\n\n')

    def _write_class_summary_line(self, public, private, link):
        cname = link.name()
        cls = link.target()
        if not self._docmap.has_key(cls): return ''
        cdoc = self._docmap[cls]
        csum = self._summary(cdoc, cls)
        str = '<tr><td width="15%">\n'
        str += '  <b>'+self._link_to_html(link)
        str += '</b></td>\n  <td>' + csum + '</td></tr>\n'
        private.write(str)
        if link.is_public(): public.write(str)

    #////////////////////////////////////////////////////////////
    # Function tables
    #////////////////////////////////////////////////////////////
    
    def _func_summary(self, functions, cls, groups, 
                      heading='Function Summary'):
        return ''
    
    def _write_func_summary(self, public, private, functions, cls, groups, 
                            heading='Function Summary'):
        """
        @return: The HTML code for a function summary table.  This
            is used by L{_module_to_html} to list the functions in a
            module; and by L{_class_to_html} to list member
            functions. 
        @rtype: C{string}
        """
        if len(functions) == 0: return

        # Write the table header
        header = self._table_header(heading, 'summary')
        _write_if_nonempty(public, private, functions, header)

        for name, group in groups:
            # Print a group header
            if name is not None:
                header = self._group_header(name)
                _write_if_nonempty(public, private, group, header)

            # Add lines for each class
            for func in group:
                str = self._func_summary_line(func, cls)
                if str:
                    private.write(str)
                    if func.is_public(): public.write(str)

            # Add an inheritance list, if appropriate
            if self._inheritance == 'listed' and cls is not None:
                self._write_inheritance_list(public, private, group, cls)

        # Write the table footer
        _write_if_nonempty(public, private, functions, '</table><br />\n\n')

    def _func_summary_line(self, link, cls):
        func = link.target()
        fname = link.name()

        if func.is_module() or func.is_class(): container = func
        else: container = func.cls() or func.module()
        inherit = ((func.is_method() or func.is_builtin_method())
                   and container != cls.uid())

        if inherit and self._inheritance == 'listed': return ''

        # If we don't have documentation for the function, then we
        # can't say anything about it.
        if not self._docmap.has_key(func): return ''
        fdoc = self._docmap[func]
        
        # Try to find a documented ancestor.
        while (not fdoc.documented() and fdoc.matches_override() and
               self._docmap.has_key(fdoc.overrides())):
            fdoc = self._docmap[fdoc.overrides()]
        inhfunc = fdoc.uid()

        rval = fdoc.returns()
        if rval.type():
            rtype = self._docstring_to_html(rval.type(), inhfunc, 8)
        else:
            rtype = '&nbsp;'

        descrstr = self._summary(fdoc, inhfunc)
        if descrstr != '&nbsp;':
            fsum = '<br />'+descrstr
        else:
            if inherit: fsum = '<br />\n'
            else: fsum = ''

        # Display any notable attributes.
        attribs = []
        if func.is_classmethod():
            attribs.append('Class method')
        if func.is_staticmethod():
            attribs.append('Static method')
        if inherit and self._inheritance != 'grouped':
            href = self._uid_to_href(container, container.shortname())
            attribs.append('Inherited from %s' % href)
        if attribs:
            fsum += '    <i>(' + '; '.join(attribs) + ')</i>\n'
            
        #if not fdoc.documented():
        #    fsum = '    <br /><i>(undocumented)</i>\n'
        str = '<tr><td align="right" valign="top" width="15%">'
        str += '<font size="-1">'+rtype+'</font></td>\n  <td><code>'
        if fdoc.documented() or inherit:
            str += self._func_signature(fname, fdoc, 1, 0, 'summary-sig')
        else:
            str += '<a name="%s"></a>' % fname
            str += self._func_signature(fname, fdoc, 0, 0, 'summary-sig')
        str += '</code>\n' + fsum + '</td></tr>\n'
        return str

    def _write_func_details(self, public, private, functions,
                            cls, heading='Function Details'):
        """
        @return: The HTML code for a function details table.  This
            is used by L{_module_to_html} to describe the functions in
            a module; and by L{_class_to_html} to describe member
            functions.
        @rtype: C{string}
        """
        # Filter out functions that we have no docs for.
        functions = [f for f in functions
                     if self._docmap.has_key(f.target())]

        # Make sure we have something left.
        if len(functions) == 0: return

        # Write the header
        header = self._table_header(heading, 'details')+'</table>\n'
        _write_if_nonempty(public, private, functions, header)

        # Add entries for each function
        for function in functions:
            str = self._func_details_entry(function, cls)
            if str:
                private.write(str)
                if function.target().is_public(): public.write(str)

        # Write the footer
        _write_if_nonempty(public, private, functions, '<br />\n\n')

    def _func_details_entry(self, function, cls):
        fname = function.name()
        func = function.target()

        if func.is_module() or func.is_class(): container = func
        else: container = func.cls() or func.module()
        inherit = ((func.is_method() or func.is_builtin_method())
                   and container != cls.uid())
            
        # Don't document inherited methods; instead, the method
        # summary points to the details description in the parent
        # class's file.
        if inherit: return ''
        
        fdoc = self._docmap[func]

        # What does this method override?
        foverrides = fdoc.overrides()

        # Try to find a documented ancestor.
        inhdoc = self._docmap.documented_ancestor(func) or fdoc
        inherit_docs = (inhdoc is not fdoc)

        # If we couldn't find a documented ancestor, then we don't
        # have anything else to say.
        if not inhdoc.documented(): return ''

        str = '\n<a name="'+fname+'"></a>\n'
        str += '<table width="100%" class="func-details"'
        str += ' bgcolor="#e0e0e0"><tr><td>\n'

        str += '  <h3>%s\n' % self._func_signature(fname, fdoc)
        if SPECIAL_METHODS.has_key(fname):
            str += '    <br /><i>'
            str += '(%s)</i>\n' % SPECIAL_METHODS[fname]
        str += '  </h3>\n'

        # Use the inherited docs for everything but the signature.
        fdoc = inhdoc
        func = inhdoc.uid()

        fdescr=fdoc.descr()
        fparam = fdoc.parameter_list()[:]
        if fdoc.vararg(): fparam.append(fdoc.vararg())
        if fdoc.kwarg(): fparam.append(fdoc.kwarg())
        freturn = fdoc.returns()
        fraises = fdoc.raises()
        
        # Don't list parameters that don't have any extra info.
        f = lambda p:p.descr() or p.type()
        fparam = filter(f, fparam)

        # Description
        if fdescr:
            str += self._docstring_to_html(fdescr, func, 2)
        str += '  <dl><dt></dt><dd>\n'

        # Parameters
        if fparam:
            str += '    <dl><dt><b>Parameters:</b></dt>\n'
            for param in fparam:
                pname = param.name()
                str += '      <dd><code><b>' + pname +'</b></code>'
                if param.descr():
                    pdescr = self._docstring_to_html(param.descr(),
                                                     func, 8)
                    str += ' -\n %s' % pdescr.rstrip()
                str += '\n'
                if param.type():
                    ptype = self._docstring_to_html(param.type(),
                                                    func, 14)
                    str += '        <br /><i>'+('&nbsp;'*10)+'\n'
                    str += ' '*8+'(type=%s)</i>\n' % ptype.strip()
                str += '      </dd>\n'
            str += '    </dl>\n'

        # Returns
        if freturn.descr() or freturn.type():
            str += '    <dl><dt><b>Returns:</b></dt>\n      <dd>\n'
            if freturn.descr():
                str += self._docstring_to_html(freturn.descr(),
                                               func, 8)
                if freturn.type():
                    rtype = self._docstring_to_html(freturn.type(),
                                                    func,14)
                    str += '        <br /><i>'+('&nbsp;'*10)+'\n'
                    str += ' '*8+'(type=%s)</i>\n' % rtype.strip()
            elif freturn.type():
                str += self._docstring_to_html(freturn.type(),
                                               func, 8)
            str += '      </dd>\n    </dl>\n'

        # Raises
        if fraises:
            str += '    <dl><dt><b>Raises:</b></dt>\n'
            for fraise in fraises:
                str += '      '
                str += '<dd><code><b>'+fraise.name()+'</b></code> -\n'
                str += self._docstring_to_html(fraise.descr(),
                                               func, 8)
                str +'      </dd>\n'
            str += '    </dl>\n'

        # Overrides
        if foverrides:
            str += '    <dl><dt><b>Overrides:</b></dt>\n'
            str += '      <dd>'+self._uid_to_href(foverrides)
            if inherit_docs:
                str += ' <i>(inherited documentation)</i>\n'
            str += '</dd>\n    </dl>\n'

        # Add version, author, warnings, requirements, notes, etc.
        str += self._standard_fields(fdoc)

        str += '  </dd></dl>\n'
        str += '</td></tr></table>\n'

        return str

    def _func_signature(self, fname, fdoc, link=0, show_defaults=1,
                        css_class="sig"):
        """
        @return: The HTML code for the function signature of the
            function with the given name and documentation.
        @param fname: The short name of the function.
        @type fname: C{string}
        @param fdoc: The documentation for the function.
        @type fdoc: L{objdoc.FuncDoc}
        @param link: Whether to create a link from the function's name
            to its details description.
        """
        str = '<span class=%s>' % css_class
        if link: str += self._uid_to_href(fdoc.uid(), fname, css_class+'-name')
        else: str += '<span class=%s-name>%s</span>' % (css_class, fname)
        
        PARAM_JOIN = ',\n'+' '*15
        str += '('
        str += self._params_to_html(fdoc.parameters(), css_class,
                                    show_defaults)
        if fdoc.vararg():
            vararg_name = fdoc.vararg().name()
            if vararg_name != '...': vararg_name = '*%s' % vararg_name
            str += ('<span class=%s-vararg>%s</span>%s' %
                    (css_class, vararg_name, PARAM_JOIN))
        if fdoc.kwarg():
            str += ('<span class=%s-kwarg>**%s</span>%s' %
                    (css_class, fdoc.kwarg().name(), PARAM_JOIN))
        if str[-1] != '(': str = str[:-len(PARAM_JOIN)]

        return str + ')</span>'

    def _params_to_html(self, parameters, css_class, show_defaults):
        PARAM_JOIN = ',\n'+' '*15
        str = ''
        for param in parameters:
            if type(param) in (types.ListType, types.TupleType):
                sublist = self._params_to_html(param, css_class,
                                               show_defaults)
                str += '(%s), ' % sublist[:-len(PARAM_JOIN)]
            else:
                str += ('<span class=%s-arg>%s</span>' %
                        (css_class, param.name()))
                if show_defaults and param.default() is not None:
                    default = param.default()
                    default = re.sub('&', '&amp;', default)
                    default = re.sub('<', '&lt;', default)
                    default = re.sub('>', '&gt;', default)
                    default = re.sub(' ', '&nbsp;', default)
                    if len(default) > 60:
                        default = default[:57]+'...'
                    str += ('=<span class=%s-default>%s</span>' %
                            (css_class, default))
                str += PARAM_JOIN
        return str

    #////////////////////////////////////////////////////////////
    # Property tables
    #////////////////////////////////////////////////////////////
    def _write_property_summary(self, public, private, properties, container,
                                groups, heading='Property Summary'):
        if len(properties) == 0: return

        # Write the table header
        header = self._table_header(heading, 'summary')
        _write_if_nonempty(public, private, properties, header)

        for name, group in groups:
            # Print a group header
            if name is not None:
                header = self._group_header(name)
                _write_if_nonempty(public, private, group, header)

            # Add lines for each class
            for prop in group:
                str = self._property_summary_line(prop, container)
                if str:
                    private.write(str)
                    if prop.is_public(): public.write(str)

            # Add an inheritance list, if appropriate
            if self._inheritance == 'listed':
                self._write_inheritance_list(public, private,
                                             group, container)

        # Write the table footer
        _write_if_nonempty(public, private, properties, '</table><br />\n\n')

    def _property_summary_line(self, link, container):
        prop = link.target()
        pname = link.name()
        
        inherit = (container.is_class() and container != prop.cls())
        if inherit and self._inheritance == 'listed': return ''
        
        # If we don't have documentation for the properties, then we
        # can't say anything about it.
        if not self._docmap.has_key(prop): return ''
        pdoc = self._docmap[prop]

        # Get the property's type, if it has one.
        if pdoc.type():
            ptype = self._docstring_to_html(pdoc.type(), prop, 10).strip()
        else: ptype = '&nbsp;'

        # Get the summary of the description.
        descrstr = self._summary(pdoc, prop)
        if descrstr != '&nbsp;': psum = ': '+descrstr
        else: psum = ''
        
        str = '<tr><td align="right" valign="top" '
        str += 'width="15%"><font size="-1">'+ptype+'</font></td>\n'
        str += '  <td><b>%s</b>%s' % (self._link_to_html(link), psum)
        if (self._inheritance != 'grouped' and inherit):
            cls = prop.cls()
            str += ('    <i>(Inherited from %s)</i>\n' %
                    self._uid_to_href(cls, cls.shortname()))
        str += '</td></tr>'
        return str

    def _write_property_details(self, *args): return
    def _property_details(self, properties, container,
                          heading='Property Details'):
        if len(properties) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'

        numprops = 0
        for link in properties:

            prop = link.target()
            pname = link.name()

            # Don't document inherited properties; instead, the
            # property summary points to the details description in
            # the parent class's file.
            if container != prop.cls(): continue
            
            if not self._docmap.has_key(prop): continue
            pdoc = self._docmap[prop]
            numprops += 1

            str += '<table width="100%" class="func-details"'
            str += ' bgcolor="#e0e0e0"><tr><td>\n'
            str += '\n<a name="%s"></a>\n' % pname
            str += '<h3>'+pname+'</h3>\n'

            if pdoc.descr():
                str += self._docstring_to_html(pdoc.descr(), prop)

            # Print the accessors for the property (fget=get property
            # value; fset=set value, and fdel=delete value).
            if pdoc.fget() or pdoc.fset() or pdoc.fdel():
                str += '<dl>\n  <dt></dt>\n  <dd>\n    <dl>\n'
                for (func,name) in [(pdoc.fget(), 'Get'),
                                    (pdoc.fset(), 'Set'),
                                    (pdoc.fdel(), 'Delete')]:
                    if func:
                        str += '      <dt><b>%s Function:' % name
                        str += '</b></dt>\n      <dd>'
                        if self._docmap.has_key(func):
                            fdoc = self._docmap[func]
                            fname = func.name()
                            str += self._func_signature(fname, fdoc, 1, 0,
                                                    'summary-sig')
                        else:
                            str += self._uid_to_href(func)
                        str += '\n      </dd>\n'
                str += '    </dl>\n  </dd>\n</dl>'

            str += '</td></tr></table>'

        if numprops == 0: return ''
        return str+'<br />'
    
    #////////////////////////////////////////////////////////////
    # Variable tables
    #////////////////////////////////////////////////////////////
    
    def _write_var_summary(self, public, private, variables, container,
                           groups, heading='Variable Summary'):
        """
        @return: The HTML code for a variable summary table.  This
            is used by L{_module_to_html} to list the variables in a
            module; and by L{_class_to_html} to list instance
            variables and class variables.
        @rtype: C{string}
        """
        if len(variables) == 0: return

        # Write the table header
        header = self._table_header(heading, 'summary')
        _write_if_nonempty(public, private, variables, header)

        for name, group in groups:
            # Print a group header
            if name is not None:
                header = self._group_header(name)
                _write_if_nonempty(public, private, group, header)

            # Add lines for each class
            for var in group:
                str = self._var_summary_line(var, container)
                private.write(str)
                if var.is_public(): public.write(str)

            # Add an inheritance list, if appropriate
            if (self._inheritance == 'listed' and container is not None
                and container.is_class()):
                self._write_inheritance_list(public, private,
                                             group, container)
                                             

        # Write the table footer
        _write_if_nonempty(public, private, variables, '</table><br />\n\n')
        
    def _var_summary_line(self, var, container):
        inherit = (container.is_class() and container != var.uid().cls())
        if inherit and self._inheritance == 'listed': return ''
            
        vname = var.name()
        if var.type():
            vtype = self._docstring_to_html(var.type(), var.uid(), 10).strip()
        else: vtype = '&nbsp;'
        if var.descr():
            vsum = ': ' +self._summary(var.descr(), var.uid())
        else:
            title = self._var_value_tooltip(var)
            val = self._pprint_var_value(var, multiline=0)
            vsum = ' = <span title="%s">%s</span>' % (title, val)
        str = '<tr><td align="right" valign="top" '
        str += 'width="15%"><font size="-1">'+vtype+'</font></td>\n'
        str += '  <td><b>'

        # If we don't have any info about it, then just list it in
        # the summary (not the details).
        if (var.descr() is None and var.type() is None and
            not var.has_value()):
            str += '<code><a name="%s">%s</a></code>' % (vname, vname)
        else:
            str += self._uid_to_href(var.uid(), vname)
        str += '</b>' + vsum 
        if (self._inheritance != 'grouped' and inherit):
            str += ('    <i>(Inherited from %s)</i>\n' %
                    self._uid_to_href(container, container.shortname()))
        return str + '</td></tr>\n'

    def _write_var_details(self, public, private, variables,
                           container, heading='Variable Details'):
        """
        @return: The HTML code for a variable details table.  This
            is used by L{_module_to_html} to describe the variables in
            a module; and by L{_class_to_html} to describe instance
            variables and class variables.
        @rtype: C{string}
        """
        # Write the header
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'
        _write_if_nonempty(public, private, variables, str)

        # Add entries for each variable
        for var in variables:
            str = self._var_details_entry(var, container)
            if str:
                private.write(str)
                if var.uid().is_public(): public.write(str)
            
        # Write the footer
        _write_if_nonempty(public, private, variables, '<br />\n\n')

    def _var_details_entry(self, var, container):
        vname = var.name()
        vtyp = var.type()
        hasval = var.has_value()

        # Don't document inherited variables; instead, the
        # property summary points to the details description in
        # the parent class's file.
        if container.is_class() and container != var.uid().cls():
            return ''

        # Don't bother if we don't know anything about it.
        if (var.descr() is None and vtyp is None and not hasval):
            return ''
        
        str = ('<table width="100%" class="var-details"'+
                ' bgcolor="#e0e0e0">'+
                '<tr><td>\n')
        str += '<a name="'+vname+'"></a>\n'
        str += '<h3>'+vname+'</h3>\n'

        # If it's a module, class, method, type, or func, then
        # just link to it.
        if not var.uid().is_variable():
            str += ('<code>%s</code> = %s\n' %
                    (vname, self._uid_to_href(var.uid())))
            if self._documented(var.uid()):
                str += '</td></tr></table>\n'
                return ''

        if var.descr():
            str += self._docstring_to_html(var.descr(), var.uid())
            
        if vtyp is not None or hasval:
            str += '<dl>\n  <dt></dt>\n  <dd>\n    <dl>\n'
            
        if vtyp:
            str += '      <dt><b>Type:</b></dt>\n      <dd>\n' 
            str += self._docstring_to_html(vtyp, var.uid())
            str += '\n      </dd>\n'

        str += '<span title="%s">' % self._var_value_tooltip(var)
        str += '      <dt><b>Value:</b></dt>\n' 
        str += '      <dd><table><tr><td>\n<pre class="variable">\n'
        str += self._pprint_var_value(var)
        str += '</pre>\n        </td></tr></table></dd>\n'
        str += '</span>'

        if vtyp is not None or hasval:
            str += '    </dl>\n  </dd>\n</dl>'
            
        str += '</td></tr></table>\n'
        return str

    def _var_value_tooltip(self, var):
        val = `var.uid().value()`
        if len(val) > self._variable_tooltip_linelen:
            val = val[:self._variable_tooltip_linelen-3]+'...'
        val = val.replace('&', '&amp;').replace('"', '&quot;')
        val = val.replace('<', '&lt;').replace('>', '&gt;')
        return val

    def _pprint_var_value(self, var, multiline=1):
        if not var.has_value(): return ''
        val = var.uid().value()

        # Handle the most common cases first.  The following types
        # will never need any line wrapping, etc; and they cover most
        # variable values (esp int, for constants).  I leave out
        # LongType on purpose, since long values may need line-
        # wrapping.
        if (type(val) is types.IntType or type(val) is types.FloatType or
            type(val) is types.NoneType or type(val) is types.ComplexType):
            # none of these should contain '&', '<' or '>'.
            vstr = repr(val)
            return vstr + '&nbsp;' * (self._variable_linelen-len(vstr))

        # For strings, use repr.  Use tripple-quoted-strings where
        # appropriate.
        elif type(val) is types.StringType:
            vstr = repr(val)
            if vstr.find(r'\n') >= 0 and multiline:
                body = vstr[1:-1].replace(r'\n', '\n')
                vstr = ('<span class="variable-quote">'+vstr[0]*3+'</span>'+
                        markup.plaintext_to_html(body) +
                       '<span class="variable-quote">'+vstr[0]*3+'</span>')
                     
            else:
                vstr = ('<span class="variable-quote">'+vstr[0]+'</span>'+
                        markup.plaintext_to_html(vstr[1:-1])+
                       '<span class="variable-quote">'+vstr[0]+'</span>')

        # For lists, tuples, and dicts, use pprint.  When possible,
        # restrict the amount of stuff that pprint needs to look at,
        # since pprint is surprisingly slow.
        elif type(val) is types.TupleType or type(val) is types.ListType:
            vstr = repr(val)
            if multiline and len(vstr) > self._variable_linelen:
                vstr = pprint.pformat(val[:self._variable_maxlines+1])
        elif type(val) is type({}):
            vstr = repr(val)
            if multiline and len(vstr) > self._variable_linelen:
                if len(val) < self._variable_maxlines+50:
                    vstr = pprint.pformat(val)
                else:
                    shortval = {}
                    for (k,v) in val.items()[:self._variable_maxlines+1]:
                        shortval[k]=v
                    vstr = pprint.pformat(shortval)

        # For regexps, use colorize_re.
        elif type(val).__name__ == 'SRE_Pattern':
            vstr = colorize_re(val)
           
        # For other objects, use repr to generate a representation.
        else:
            try: vstr = markup.plaintext_to_html(repr(val))
            except: vstr = '...'

        # For the summary table, just return the value; don't
        # bother to word-wrap.
        if not multiline:
            vstr = vstr.replace('\n', '')
            # Change spaces to &nbsp; (except spaces in html tags)
            vstr = vstr.replace(' ', '&nbsp;')
            vstr = vstr.replace('<span&nbsp;', '<span ')
            vstr = self._linewrap_html(vstr, self._variable_summary_linelen, 1)
            return '<code>%s</code>\n' % vstr

        # Do line-wrapping.
        return self._linewrap_html(vstr, self._variable_linelen,
                                   self._variable_maxlines)

    def _linewrap_html(self, str, linelen, maxlines):
        """
        Add line-wrapping to the HTML string C{str}.  Line length is
        determined by C{linelen}; and the maximum number of
        lines to display is determined by C{maxlines}.  This
        function treats HTML entities (e.g., C{&amp;}) as single
        characters; and ignores HTML tags (e.g., C{<p>}).
        """
        LINEWRAP_MARKER = r'<span class="variable-linewrap">\</span>'
        ELLIPSIS_MARKER = r'<span class="variable-ellipsis">...</span>'
        
        lines = []
        start = end = cnum = 0
        while len(lines) <= maxlines and end < len(str):
            # Skip over HTML tags.
            if str[end] == '<':
                end = str.find('>', end)
                cnum -= 1

            # HTML entities just count as 1 char.
            elif str[end] == '&':
                end = str.find(';', end)

            # Go on to the next character.
            cnum += 1
            end += 1

            # Check for end-of-line.
            if str[end-1] == '\n':
                lines.append(str[start:end-1])
                cnum = 0
                start = end

            # Check for line-wrap
            if cnum == linelen and end<len(str) and str[end] != '\n':
                if maxlines == 1:
                    return str[start:end]+ELLIPSIS_MARKER
                lines.append(str[start:end]+LINEWRAP_MARKER)
                cnum = 0
                start = end

        # Add on anything that's left.
        if end == len(str):
            lines.append(str[start:end])

        # Use the ellipsis marker if the string is too long.
        if len(lines) > maxlines:
            lines[-1] = ELLIPSIS_MARKER
            cnum = 3

        # Pad the last line to linelen.
        lines[-1] += ' '*(linelen-cnum+1)

        return ('\n').join(lines)
            
    #////////////////////////////////////////////////////////////
    # Term index generation
    #////////////////////////////////////////////////////////////
    
    def _get_index_terms(self, parsed_docstring, link, terms, links):
        if parsed_docstring is None: return
        for term in parsed_docstring.index_terms():
            key = self._term_index_to_anchor(term)
            if not terms.has_key(key):
                terms[key] = term
                links[key] = []
            links[key].append(link)

    def _extract_term_index(self):
        """
        @return: Two dictionaries:
          - the first maps keys to terms
          - the second maks keys to lists of links
        @rtype: C{dictionary}
        """
        terms = {}
        links = {}
        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            
            if uid.is_function():
                link = Link(uid.name(), uid.module())
            elif uid.is_method():
                link = Link(uid.name(), uid.cls())
            else:
                link = Link(uid.name(), uid)

            # Get index items from standard fields.
            for field in self._standard_field_values(doc):
                self._get_index_terms(field, link, terms, links)
            if doc.descr():
                self._get_index_terms(doc.descr(), link, terms, links)

            # Get index items from object-specific fields.
            if isinstance(doc, ModuleDoc):
                for var in doc.variables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_index_terms(var.descr(), link, terms, links)
                    self._get_index_terms(var.type(), link, terms, links)
            elif isinstance(doc, ClassDoc):
                for var in doc.ivariables() + doc.cvariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_index_terms(var.descr(), link, terms, links)
                    self._get_index_terms(var.type(), link, terms, links)
            elif isinstance(doc, FuncDoc):
                extra_p = [v for v in [doc.vararg(), doc.kwarg(),
                                       doc.returns()] if v is not None]
                for param in doc.parameter_list()+extra_p:
                    self._get_index_terms(param.descr(), link, terms, links)
                    self._get_index_terms(param.type(), link, terms, links)
                for fraise in doc.raises():
                    self._get_index_terms(fraise.descr(), link, terms, links)
                    
        return terms, links

    #////////////////////////////////////////////////////////////
    # Identifier index generation
    #////////////////////////////////////////////////////////////

    def _extract_identifier_index(self):
        """
        @rtype: C{list} of L{UID}
        """
        # List of (sort-key, UID), where sort-key is
        # uid.shortname().lower().
        decorated_uids = []

        for (uid, doc) in self._docmap.items():
            decorated_uids.append( (uid.shortname().lower(), uid) )
            if uid.is_module():
                decorated_uids += [(v.name().lower(), v.uid())
                                   for v in doc.variables()
                                   if v.uid().is_public()]
            elif uid.is_class():
                decorated_uids += [(v.name().lower(), v.uid())
                                   for v in doc.ivariables() + doc.cvariables()
                                   if v.uid().is_public()]

        decorated_uids.sort()        
        return [u[1] for u in decorated_uids]

    #////////////////////////////////////////////////////////////
    # Table of contents (frames) generation
    #////////////////////////////////////////////////////////////

    def _toc_section(self, section, links): return ''
    
    def _write_toc_section(self, public, private, section, links):
        if not links: return

        # Write a header
        str = self._start_of(section)
        str += '<font size="+1"><b>%s</b></font><br />\n' % section
        public.write(str); private.write(str)

        # Sort the links by name
        decorated = [(link.name().lower(), link) for link in links]
        decorated.sort()
        links = [d[-1] for d in decorated]

        # Write all the links.
        for link in links:
            str = ('<a target="mainFrame" href="%s">%s</a><br />\n' %
                   (self._uid_to_uri(link.target()), link.name()))
            private.write(str)
            if link.is_public(): public.write(str)

        # Write a footer
        str = '<br />\n'
        public.write(str); private.write(str)

    #////////////////////////////////////////////////////////////
    # Docstring -> HTML Conversion
    #////////////////////////////////////////////////////////////

    def _term_index_to_anchor(self, term):
        """
        Given the name of an inline index item, construct a URI anchor.
        These anchors are used to create links from the index page to each
        index item.
        """
        # Include "-" so we don't accidentally collide with the name
        # of a python identifier.
        s = re.sub(r'\s\s+', '-', term.to_plaintext(None))
        return "index-"+re.sub("[^a-zA-Z0-9]", "_", s)

#    def _docstring_to_html(self, docstring, container=None, indent=0):
    def _docstring_to_html(self, docstring, uid, indent=0):
        """
        @return: A string containing the HTML encoding for the given
            C{ParsedDocstring}
        @rtype: L{markup.ParsedDocstring}
        """
        if docstring is None: return ''
        linker = _HTMLDocstringLinker(self, uid)
        return docstring.to_html(linker, indent=indent)

    #////////////////////////////////////////////////////////////
    # Standard fields
    #////////////////////////////////////////////////////////////

    def _standard_field_values(self, doc):
        """
        @return: A list of epytext field values that includes all
        fields that are common to all L{ObjDoc}s.
        C{_standard_field_values} is used by L{_extract_term_index}.
        @rtype: C{list} of L{markup.ParsedDocstring}
        """
        field_values = []
        for field in doc.fields():
            field_values += doc.field_values(field)
        return field_values

    def _standard_fields(self, doc):
        """
        @return: HTML code containing descriptions of the epytext
        fields that are common to all L{ObjDoc}s (except for C{descr}).
        @rtype: C{string}
        @param doc: The object whose fields should be described.
        """
        uid = doc.uid()
        if uid.is_module() or uid.is_class(): container = uid
        else: container = uid.cls() or uid.module()
        str = ''

        for field in doc.fields():
            values = doc.field_values(field)
            if not values: continue
            items = [self._docstring_to_html(v, uid) for v in values]
            str += self._descrlist(items, field.singular,
                                   field.plural, field.short)

        return str
            
    def _descrlist(self, items, singular, plural=None, short=0):
        """
        @return: The HTML code for a list of description items.
        @param items: The description items.
        @type items: C{list} of C{string}
        @param singular: The name of the list, if there is one
            element. 
        @param plural: The name of the list, if there are multiple
            elements.  
        """
        if plural is None: plural = singular
        if len(items) == 0: return ''
        if len(items) == 1:
            return '<p><b>%s:</b> %s</p>\n\n' % (singular, items[0])
            #return '<p><b>%s:</b> %s<br /></p>\n\n' % (singular, items[0])
        if short:
            str = '<dl><dt><b>%s:</b></dt>\n  <dd>\n    ' % plural
            items = [item.strip() for item in items]
            return str + ',\n    '.join(items) + '\n  </dd>\n</dl>\n\n'
        else:
            str = '<p><b>%s:</b>\n<ul>\n  <li>' % plural
            return (str + '</li>\n  <li>'.join(items) +
                    '\n  </li>\n</ul></p>\n\n')
    
    #////////////////////////////////////////////////////////////
    # Helper functions
    #////////////////////////////////////////////////////////////

    def _find_top_page(self, pagename):
        """
        Find the top page for the API documentation.  This page is
        used as the default page shown in the main frame, when frames
        are used.  When frames are not used, a redirect page is
        created from C{index.html} to the top page.

        @param pagename: The name of the page, as specified by the
            keyword argument C{top} to the constructor.
        @type pagename: C{string}
        @return: The URL of the top page.
        @rtype: C{string}
        """
        # If the top_page is unspecified, find an appropriate page.
        if not pagename:
            top = self._find_toplevel()
            if top: return self._uid_to_uri(top)
            else: return 'trees.html'

        # If it's a URL, then use it directly.
        if pagename.startswith('http:'):
            return pagename

        # Look for it in the docmap.
        for uid in self._docmap.keys():
            if pagename == uid.name():
                if uid.is_module() or uid.is_class():
                    return self._uid_to_uri(uid)
                else:
                    estr = ('Warning: Specified top page object %s' % uid
                            + ' is not a module\n         or a class.')
                    if sys.stderr.softspace: print >>sys.stderr
                    print >>sys.stderr, estr
                    return self._find_top_page(None)
                
        # Try importing it as a module.
        try:
            uid = make_uid(import_module(pagename))
            if self._docmap.has_key(uid):
                return self._uid_to_uri(uid)
            else:
                estr = ('Warning: Specified top page object %s' % uid
                        + ' is not documented.')
                if sys.stderr.softspace: print >>sys.stderr
                print >>sys.stderr, estr
                return self._find_top_page(None)
        except: pass

        # Is it a special page name?  Note that these could, in
        # principle, be shadowed by modules or classes named "html"
        # contained in packages named "index" etc.
        if pagename in ('indices.html', 'help.html',
                        'trees.html'):
            return pagename

        # We didn't find anything.
        estr = ('Warning: Unable to find the specified top_page %s.'
                % pagename)
        if sys.stderr.softspace: print >>sys.stderr
        print >>sys.stderr, estr
        return self._find_top_page(None)
    
    def _find_toplevel(self):
        """
        @return: The UID of the top-level module or package, or

            C{None} if there is no top-level module or package.
        @rtype: L{UID} or C{None}
        """
        modules = []
        packages = []
        for (uid, doc) in self._docmap.items():
            if not isinstance(doc, ModuleDoc): continue
            modules.append(uid)
            if doc.ispackage():
                packages.append(uid)

        # Is there a unique module?
        if len(packages) == 0 and len(modules) == 1:
            return modules[0]
        
        # Is there a unique (top-level) package?
        if len(packages) == 0: return None
        else:
            for pkg in packages:
                for pkg2 in packages:
                    if pkg is pkg2: continue
                    if not pkg2.descendant_of(pkg): break
                else: return pkg

        # There is no top-level object.
        return None

#    def _filter_private(self, items):
#        """
#        If L{_show_private} is true, then return C{items}; otherwise,
#        return a copy of C{items} with all private items removed.
#        """
#        if self._show_private: return items
#        else: return [i for i in items if i.is_public()]

    def _header(self, name):
        """
        @return: The HTML code for the header of a page with the given
            name.
        @rtype: C{string}
        """
        return HEADER % name
               
    def _footer(self):
        """
        @return: The HTML code for the footer of a page.
        @rtype: C{string}
        """
        timestamp = time.asctime(time.localtime(time.time()))
        return FOOTER % (epydoc.__version__, timestamp)

    def _summary(self, doc, uid):
        """
        @return: The HTML code for the summary description of the
            object documented by C{doc}.  A summary description is the
            first sentence of the C{doc}'s 'description' field.  If the
            C{doc} has no 'description' field, but does have a
            'return' field, then the summary is taken from the return
            field instead.
        @rtype: C{string}
        @param doc: The documentation for the object whose summary
            should be returned.
        @type doc: L{objdoc.ObjDoc}
        @type uid: L{uid.UID}
        """
        # Try to find a documented ancestor
        if isinstance(doc, FuncDoc):
            while (not doc.documented() and doc.matches_override() and
                   self._docmap.has_key(doc.overrides())):
                doc = self._docmap[doc.overrides()]
                
        summary = self._docstring_to_html(doc.summary(), uid).strip()
        if not summary:
            if (isinstance(doc, FuncDoc) and
                doc.returns().descr() is not None):
                summary = doc.returns().descr().summary()
                summary = self._docstring_to_html(summary, uid).strip()
                return 'Return '+summary[:1].lower() + summary[1:]
            else:
                return '&nbsp;'
        return summary or '&nbsp;'

    def _write_imports(self, public, private, classes, excepts,
                       functions, variables):
        if not self._show_imports: return

        header = self._start_of('Imports')+'<dl>\n'
        everything=classes+excepts+functions+variables
        _write_if_nonempty(public, private, everything, header)

        if len(classes) > 0:
            header = '  <dt><b>Imported classes:</b></dt>\n  <dd>\n    '
            _write_if_nonempty(public, private, classes, header)
            private_hrefs = [self._link_to_html(c) for c in classes]
            public_hrefs = [self._link_to_html(c) for c in classes
                            if c.is_public()]
            private.write(',\n    '.join(private_hrefs) + '\n  </dd>\n')
            public.write(',\n    '.join(public_hrefs) + '\n  </dd>\n')
        if len(excepts) > 0:
            header = '  <dt><b>Imported exceptions:</b></dt>\n  <dd>\n    '
            _write_if_nonempty(public, private, excepts, header)
            private_hrefs = [self._link_to_html(e) for e in excepts]
            public_hrefs = [self._link_to_html(e) for e in excepts
                            if e.is_public()]
            private.write(',\n    '.join(private_hrefs) + '\n  </dd>\n')
            public.write(',\n    '.join(public_hrefs) + '\n  </dd>\n')
        if len(functions) > 0:
            header = '  <dt><b>Imported functions:</b></dt>\n  <dd>\n    '
            _write_if_nonempty(public, private, functions, header)
            private_hrefs = [self._link_to_html(f) for f in functions]
            public_hrefs = [self._link_to_html(f) for f in functions
                            if f.is_public()]
            private.write(',\n    '.join(private_hrefs) + '\n  </dd>\n')
            public.write(',\n    '.join(public_hrefs) + '\n  </dd>\n')
        if len(variables) > 0:
            header = '  <dt><b>Imported variables:</b></dt>\n  <dd>\n    '
            _write_if_nonempty(public, private, variables, header)
            private_names = ['<code>%s</code>' % v.name()
                             for v in variables]
            public_names = ['<code>%s</code>' % v.name()
                            for v in variables
                            if v.is_public()]
            private.write(',\n    '.join(private_names) + '\n  </dd>\n')
            public.write(',\n    '.join(public_names) + '\n  </dd>\n')
            
        _write_if_nonempty(public, private, everything, '</dl>\n\n')
                                
    def _link_to_html(self, link):
        """
        @return: The HTML code for the given link.  This code consists
            of an anchor with an href to the page for the link's
            target, and with text taken from the link's name. If the
            target is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type link: L{uid.Link}
        """
        return self._uid_to_href(link.target(), link.name())

    def _uid_to_filename(self, uid):
        # Make sure this is consistant w/ _uid_to_uri.
        if uid.is_module():
            return '%s-module.html' % uid.name()
        elif uid.is_class():
            return '%s-class.html' % uid.name()
        else:
            raise AssertionError, 'Bad UID type: %r' % uid

    def _uid_to_uri(self, uid):
        """
        @return: a URI that points to the description of the object
            identified by C{uid}.
        @rtype: C{string}
        @param uid: A unique identifier for the object.
        @type uid: L{UID}
        """
        # Cache the URI, since we re-use these a lot.  (This is a
        # slight hack, but profiling shows that it's worth it.)
        if hasattr(uid, '_uri'): return uid._uri
        if uid.is_module():
            uid._uri = '%s-module.html' % uid.name()
        elif uid.is_class():
            uid._uri = '%s-class.html' % uid.name()
        else:
            parent = uid.parent()
            if parent is None:
                uid._uri = '%s-unknown.html' % uid.name() # Error
            elif parent.is_module():
                uid._uri = '%s-module.html#%s' % (parent.name(),
                                                  uid.shortname())
            elif parent.is_class():
                uid._uri = '%s-class.html#%s' % (parent.name(),
                                                 uid.shortname())
            else:
                uid._uri = '%s-unknown.html' % uid.name() # Error

        # For private UIDs, explicitly link to the private docs.
        if uid.is_private() and self._create_private_docs:
            uid._uri = os.path.join('..', 'private', uid._uri)
            
        return uid._uri
            
    def _documented(self, uid):
        """
        @return: True if the given UID is documented by the
            documentation map for this C{HTMLFormatter}.
        @rtype: C{boolean}
        """
        # Does it have a UID?
        if uid is None:
            return 0

        # Is it private, if we're not showing private?
        if (not self._create_private_docs) and uid.is_private():
            return 0

        # Is it a variable or routine whose parent is not documented?
        if ((uid.is_routine() or uid.is_variable()) and
            (not self._docmap.has_key(uid.parent()))):
            return 0

        # Is it a non-variable that's not documented? (variables are
        # not included in the docmap)
        if (not uid.is_variable() and not self._docmap.has_key(uid)):
            return 0

        # Otherwise, it must be documented.
        return 1
    
    def _uid_to_href(self, uid, label=None, css_class=None, code=1):
        """
        @return: The HTML code to link to the given UID.  This code
            consists of an anchor with an href to the page for C{uid}.
            If C{label} is not C{None}, then it is used as the text
            for the link; otherwise, C{uid} is used as the text.  If
            C{uid} is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type uid: L{uid.UID}
        @type label: C{string}
        @param code: Whether or not to include C{<code>...</code>}
            tags around the label.
        """
        # We shouldn't need this, but include it just in case.
        if uid is None and label is None:
            return '<code>??</code>'
        
        # Find a default value for the label.
        if label is None: label = uid.name()

        if not self._documented(uid):
            if code: return '<code>%s</code>' % label
            else: return '%s' % label

        # Construct an href, using uid_to_uri.
        if css_class and code:
            return ('<a href="%s" class="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif css_class:
            return ('<a href="%s" class="%s">%s</a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif code:
            return ('<a href="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), label))
        else:
            return ('<a href="%s">%s</a>' %
                    (self._uid_to_uri(uid), label))

    def _start_of(self, heading):
        """
        @return: The HTML code for a 'start-of' comment.  These
            comments are used to deliniate sections of the HTML
            output.
        @rtype: C{string}
        @param heading: The name of the section that is starting.
        @type heading: C{string}
        """
        return '\n<!-- =========== START OF '+heading.upper()+\
               ' =========== -->\n'
    
    def _group_header(self, group):
        group = re.sub('&', '&amp;', group)
        group = re.sub('<', '&lt;', group)
        return '<tr bgcolor="#e8f0f8" class="group">\n'+\
               '  <th colspan="2">' + '&nbsp;'*4 + group + '</th></tr>\n'
    
    def _table_header(self, heading, css_class):
        """
        @return: The HTML code for the start of a table.  This is used
            by class tables, function tables, variable tables, etc.
        @rtype: C{string}
        @param heading: The name for the table.
        @type heading: C{string}
        @param css_class: The css class for the table.  This is used
            to allow different tables to be given different styles.
            Currently, the following classes are used: C{'summary'};
            C{'details'}; and C{'index'}.
        """
        return self._start_of(heading)+\
               '<table class="'+css_class+'" border="1" cellpadding="3"' +\
               ' cellspacing="0" width="100%" bgcolor="white">\n' +\
               '<tr bgcolor="#70b0f0" class="'+css_class+'">\n'+\
               '  <th colspan="2">' + heading + '</th></tr>\n'
    
    def _split_classes(self, classes_and_excepts):
        """
        Divide the classes fromt the given module into exceptions and
        non-exceptions.  This is used by L{_module_to_html} to list
        exceptions and non-exceptions separately.

        @param classes_and_excepts: The list of classes to split up.
        @type classes_and_excepts: C{list} of L{uid.Link}
        @return: A list C{(I{classes}, I{excepts})}, where
            C{I{classes}} is the list of non-exception classes, and
            C{I{excepts}} is the list of exception classes.
        @rtype: C{pair} of C{list} of L{uid.Link}
        """
        classes = []
        excepts = []
        for link in classes_and_excepts:
            try:
                if (self._docmap.has_key(link.target()) and
                    self._docmap[link.target()].is_exception()):
                    excepts.append(link)
                else:
                    classes.append(link)
            except:
                classes.append(link)
        return (classes, excepts)
        
    def _write_inheritance_list(self, public, private, links, cls):
        """
        @return: A string containing HTML that lists all objects from
            that were inherited from a base ancestor of C{cls}.
            Only the objects linked to from one of the links in
            C{links} are considered.  The HTML lists the objects in
            one row of a table, grouped by ancestor.
        @type links: C{list} of L{Link}
        @param links: The set of member objects of C{cls}
            that should be listed by ancestor.
        @type cls: L{UID}
        @param cls: The UID of the class whose inherited objects
            should be listed.
        """
        # Group the objects by defining class
        inh_dict = {}
        for link in links:
            if isinstance(link, Link): key = link.target().cls()
            else: key = link.uid().cls()
            if key == cls: continue
            if key is None: continue
            if not inh_dict.has_key(key): inh_dict[key] = []
            inh_dict[key].append(link)

        if not inh_dict: return

        # Write a header
        header = '  <tr><td colspan="2">\n'
        _write_if_nonempty(public, private, links, header)

        # Get the inheritance items, and sort them by base
        inh_items = inh_dict.items()
        inh_items.sort()

        for j in range(len(inh_items)):
            (base, obj_links) = inh_items[j]
            header = '    <b>Inherited from %s:</b>' % base.shortname()
            _write_if_nonempty(public, private, obj_links, header)

            private_str = ''
            public_str = ''
            for link in obj_links:
                if isinstance(link, Link): str = self._link_to_html(link)
                else: str = self._uid_to_href(link.uid(), link.name())
                str = '\n      %s, ' % str
                private_str += str
                if link.is_public(): public_str += str
            private.write(private_str[:-2])
            public.write(public_str[:-2])
                
            if j != len(inh_items)-1:
                str = '\n      <br />\n'
                _write_if_nonempty(public, private, obj_links, str)

        footer = '\n    </td></tr>\n'
        _write_if_nonempty(public, private, links, footer)

def _write_if_nonempty(public, private, links, str):
    """
    Write C{str} to C{public} and C{private}; but only write to
    C{private} if C{links} is nonempty; and only write to
    C{public} if C{links} contains at least one public object.

    This helper function is used to write list headers etc., which
    should only appear if the list will actually contain something.
    """
    if len(links) == 0: return
    private.write(str)
    for link in links:
        if link.is_public():
            public.write(str)
            return

class _HTMLDocstringLinker(markup.DocstringLinker):
    def __init__(self, docformatter, uid):
        self._docformatter = docformatter
        self._uid = uid
        self._docmap = docformatter._docmap
        if uid.is_module() or uid.is_class(): self._container = uid
        else: self._container = uid.cls() or uid.module()
    def translate_indexterm(self, indexterm):
        key = self._docformatter._term_index_to_anchor(indexterm)
        return ('<a name="%s"></a><i class="indexterm">%s</i>' %
                (key, indexterm.to_html(self)))
    def translate_identifier_xref(self, identifier, label=None):
        if label is None: label = markup.plaintext_to_html(identifier)
        uid = findUID(identifier, self._container, self._docmap)
        if uid is None:
            failed_xrefs = self._docformatter._failed_xrefs
            if not failed_xrefs.has_key(identifier):
                failed_xrefs[identifier] = {}
            failed_xrefs[identifier][self._uid] = 1    
        return self._docformatter._uid_to_href(uid, label, 'link')
        
class _DevNull:
    """
    A file-like-object that ignores all input.  Used by L{HTMLFormatter}
    when not generating private docs, to throw away the private docs.
    """
    def write(*args): pass
    def close(*args): pass
    
