#
# epydoc.py: epydoc HTML output generator
# Edward Loper
#
# Created [01/30/01 05:18 PM]
# $Id$
#

"""
Documentation to HTML converter.
"""
__docformat__ = 'epytext en'

##################################################
## Implementation Notes
##################################################

# Index:
#     1. Constants
#     2. Imports
#     3. HTML Formatter
#       - Constructor
#       - Write
#       - HTML page generation
#       - Navigation bar
#       - Base class trees
#       - Class hierarchy trees
#       - Module hierarchy trees
#       - Class tables
#       - Function tables
#       - Variable tables
#       - Term index generation
#       - Identifier index generation
#       - Table of contents (frames)
#       - Docstring->HTML Conversion
#       - Helper functions
#

# I chose to implement the formatter as a class (rather than as a
# group of functions) because it lets me use instance variables to
# remember all the configuration variables.  Passing these around
# manually would be a pain.  Also, I don't have to explicitly pass
# around the docmap, which is used almost everywhere.

##################################################
## Constants
##################################################

# Expects: name
HEADER = '''<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>%s</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
</head>
<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
'''
# Expects: (version, date)
FOOTER = '''
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left"><font size="-2">Generated by Epydoc %s on %s</font></td>
    <td align="right"><a href="http://epydoc.sourceforge.net"
                      ><font size="-2">http://epydoc.sf.net</font></a></td>
  </tr>
</table>
</body>
</html>
'''
# Expects: (name, mainFrame_src)
FRAMES_INDEX = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
  <title> %s </title>
</head>
<frameset cols="20%%,80%%">
  <frameset rows="30%%,70%%">
    <frame src="toc.html" name="moduleListFrame">
    <frame src="toc-everything.html" name="moduleFrame">
  </frameset>
  <frame src="%s" name="mainFrame">
</frameset>
</html>
'''
# Expects (url, url, name)
REDIRECT_INDEX = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
  <title> Redirect </title>
  <meta http-equiv="refresh" content="1;url=%s">
  <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
</head>
<body>
  Redirecting to the API documentation for <a href="%s">%s</a>...
</body>
</html>
'''

# Names for the __special__ methods.
SPECIAL_METHODS ={
    '__init__': 'Constructor',
    '__del__': 'Destructor',
    '__add__': 'Addition operator',
    '__sub__': 'Subtraction operator',
    '__and__': 'And operator',
    '__or__': 'Or operator',
    '__repr__': 'Representation operator',
    '__call__': 'Call operator',
    '__getattr__': 'Qualification operator',
    '__getitem__': 'Indexing operator',
    '__setitem__': 'Index assignment operator',
    '__delitem__': 'Index deletion operator',
    '__delslice__': 'Slice deletion operator',
    '__setslice__': 'Slice assignment operator',
    '__getslice__': 'Slicling operator',
    '__len__': 'Length operator',
    '__cmp__': 'Comparison operator',
    '__eq__': 'Equality operator',
    '__in__': 'Containership operator',
    '__gt__': 'Greater-than operator',
    '__lt__': 'Less-than operator',
    '__ge__': 'Greater-than-or-equals operator',
    '__le__': 'Less-than-or-equals operator',
    '__radd__': 'Right-side addition operator',
    '__hash__': 'Hashing function',
    '__contains__': 'In operator',
    '__nonzero__': 'Boolean test operator',
    '__str__': 'Informal representation operator',
    }

##################################################
## Imports
##################################################

# system imports
import re, sys, os.path, time, pprint
import xml.dom.minidom

# epydoc imports
import epydoc
import epydoc.markup as markup
from epydoc.uid import UID, Link, findUID, make_uid
from epydoc.imports import import_module
from epydoc.objdoc import DocMap, ModuleDoc, FuncDoc
from epydoc.objdoc import ClassDoc, Var, Raise, ObjDoc
from epydoc.css import STYLESHEETS
from epydoc.help import HTML_HELP
from epydoc.colorize import colorize_re

##################################################
## Documentation -> HTML Conversion
##################################################

class HTMLFormatter:
    """
    Documentation to HTML converter.  The API documentation produced
    C{HTMLFormatter} consists of a set of HTML files.  Two
    subdirectories are created for the public and private
    documentation.  Within each subdirectories, every class and module
    is documented in its own file.  An index file, a trees file, a
    help file, and a frames-based table of contents are also created.
    In particular, C{HTMLFormatter} generates the following files:

      - X{index.html}: The standard entry point for the documentation.
        Normally, index.html is a frame index file, which defines
        three frames: two frames on the left side of the browser
        contain a table of contents, and the main frame on the right
        side of the window contains documentation pages.  But if the
        --no-frames option is used, then index.html will redirect the
        user to the project's top page.
      - X{I{module}-module.html}: The API documentation for a module.
        I{module} is the complete dotted name of the module, such as
        sys or epydoc.epytext.
      - X{I{class}-class.html}: The API documentation for a class, exception,
        or type.  I{class} is the complete dotted name of the class,
        such as epydoc.epytext.Token or array.ArrayType.
      - X{trees.html}: The module and class hierarchies.
      - X{indices.html} The term and identifier indices.  
      - X{help.html}: The help page for the project.  This page
        explains how to use and navigate the webpage produced by
        epydoc.
      - X{toc.html}: The top-level table of contents page.  This page
        is displayed in the upper-left frame, and provides links to
        toc-everything.html and the toc-I{module}-module.html files.  toc.html
        is not generated if the --no-frames option is used.
      - X{toc-everything.html}: The table of contents for the entire
        project.  This page is displayed in the lower-left frame, and
        provides links to every class, type, exception, function,
        and variable defined by the project.  toc-everything.html is
        not generated if the --no-frames option is used.
      - X{toc-I{module}-module.html}: The table of contents for a module.
        This page is displayed in the lower-left frame, and provides
        links to every class, type, exception, function, and variable
        defined by the module.  module is the complete dotted name of
        the module, such as sys or epydoc.epytext.  toc-m-module.html
        is not generated if the --no-frames option is used.
      - X{epydoc.css}: The CSS stylesheet used to display all HTML
        pages.

    @type _docmap: L{DocMap}
    @ivar _docmap: The documentation map, encoding the objects that
        should be documented.
    @type _prj_name: C{string}
    @ivar _prj_name: A name for the documentation (for the navbar).
    @type _prj_url: C{string}
    @ivar _prj_url: A URL for the documentation (for the navpar).
    @ivar _module: The UID of the top-level module, if there is one. 
        If there is more than one top-level module, then C{_module} is
        C{'multiple'}; if there is no top-level module, then
        C{_module} is C{None}.
    @ivar _package: The UID of the top-level package, if there is
        one. If there is more than one top-level package, then
        C{_package} is C{'multiple'}; if there is no top-level
        package, then C{_package} is C{None}.
    @ivar _show_private: Whether we are currently writing files that
        show private objects.
    @ivar _css: The name of a file containing a CSS stylesheet; or the
        name of a CSS stylesheet.
    @ivar _cssfile: The name of the CSS stylesheet file.  This should
        be C{'epydoc.css'} when C{_show_private==0} and
        C{'../epydoc.css'} when C{_show_private==1}.
    @ivar _variable_linelen:  The maximum line length used for
        displaying the values of variables in the variable
        details sections.
    @ivar _variable_maxlines: The maximum number of lines that
         should be displayed for the value of a variable in the
         variable details section.
    """

    #////////////////////////////////////////////////////////////
    # Constructor
    #////////////////////////////////////////////////////////////
    
    def __init__(self, docmap, **kwargs):
        """
        Construct a new HTML formatter, using the given documentation map.
        @param docmap: The documentation to output.
        @type docmap: L{DocMap}
        @param kwargs: Keyword arguments:
            - C{prj_name}: The name of the project.  Defaults to
              none.  (type=C{string})
            - C{prj_url}: The target for the project hopeage link on
              the navigation bar.  If C{prj_url} is not specified,
              then no hyperlink is created.  (type=C{string})
            - C{prj_link}: The label for the project link on the
              navigation bar.  This link can contain arbitrary HTML
              code (e.g. images).  By default, a label is constructed
              from C{prj_name}.  (type=C{string})
            - C{top}: The top page for the documentation.  This
              is the default page shown main frame, when frames are
              enabled.  C{top} can be a URL, the name of a
              module, the name of a class, or one of the special
              strings C{"trees.html"}, C{"indices.html"}, or
              C{"help.html"}.  By default, the top-level package or
              module is used, if there is one; otherwise, C{"trees"}
              is used.  (type=C{string})
            - C{css}: The CSS stylesheet file.  If C{css} is a file
              name, then the specified file's conents will be used.
              Otherwise, if C{css} is the name of a CSS stylesheet in
              L{epydoc.css}, then that stylesheet will be used.
              Otherwise, an error is reported.  If no stylesheet is
              specified, then the default stylesheet is used.
              (type=C{string})
            - C{private_css}: The CSS stylesheet file for the private
              API documentation.  If C{css} is a file name, then the
              specified file's conents will be used.  Otherwise, if
              C{css} is the name of a CSS stylesheet in L{epydoc.css},
              then that stylesheet will be used.  Otherwise, an error
              is reported.  If no stylesheet is specified, then the
              private API documentation will use the same stylesheet
              as the public API documentation.  (type=C{string})
            - C{help}: The name of the help file.  If no help file is
              specified, then the default help file will be used.
              (type=C{string})
            - C{private}: Whether to create documentation for private
              objects.  By default, private objects are documented.
              (type=C{boolean})
            - C{frames}: Whether to create a frames-based table of
              contents.  By default, it is produced.
              (type=C{boolean}) 
            - C{show_imports}: Whether or not to display lists of
              imported functions and classes.  By default, they are
              not shown.  (type=C{boolean})
            - C{index_parameters}: Whether or not to include function
              parameters in the identifier index.  By default, they
              are not included.  (type=C{boolean})
            - C{variable_maxlines}: The maximum number of lines that
              should be displayed for the value of a variable in the
              variable details section.  By default, 8 lines are
              displayed.  (type=C{int})
            - C{variable_linelength}: The maximum line length used for
              displaying the values of variables in the variable
              details sections.  If a line is longer than this length,
              then it will be wrapped to the next line.  The default
              line length is 70 characters.  (type=C{int})
            - C{variable_summary_linelength}: The maximum line length
              used for displaying the values of variables in the summary
              section.  If a line is longer than this length, then it
              will be truncated.  The default is 40 characters.
              (type=C{int})
            - C{variable_tooltip_linelength}: The maximum line length
              used for tooltips for the values of variables.  If a
              line is longer than this length, then it will be
              truncated.  The default is 600 characters.  (type=C{int})
            - C{inheritance}: How inherited objects should be displayed.
              If C{inheritance='grouped'}, then inherited objects are
              gathered into groups; if C{inheritance='listed'}, then
              inherited objects are listed in a short list at the
              end of their group; if C{inheritance='included'}, then
              inherited objects are mixed in with non-inherited
              objects.  The default is 'grouped'.  (type=C{string})
        """
        self._docmap = docmap

        # Process keyword arguments.
        self._prj_name = kwargs.get('prj_name', None)
        self._prj_url = kwargs.get('prj_url', None)
        self._prj_link = kwargs.get('prj_link', None)
        self._top_page = self._find_top_page(kwargs.get('top', None))
        self._css = kwargs.get('css')
        self._private_css = kwargs.get('private_css') or self._css
        self._helpfile = kwargs.get('help', None)
        self._create_private_docs = kwargs.get('private', 1)
        self._frames_index = kwargs.get('frames', 1)
        self._show_imports = kwargs.get('show_imports', 0)
        self._index_parameters = kwargs.get('index_parameters', 0)
        self._variable_maxlines = kwargs.get('variable_maxlines', 8)
        self._variable_linelen = kwargs.get('variable_linelength', 70)
        self._variable_summary_linelen = \
                         kwargs.get('variable_summary_linelength', 40)
        self._variable_tooltip_linelen = \
                         kwargs.get('variable_tooltip_linelength', 600)
        self._inheritance = kwargs.get('inheritance', 'grouped')

        # Create the project homepage link, if it was not specified.
        if (self._prj_name or self._prj_url) and not self._prj_link:
            name = self._prj_name or 'Project Homepage'
            name = name.replace('&', '&amp;')
            name = name.replace('<', '&lt;')
            name = name.replace('>', '&gt;')
            name = name.replace(' ', '&nbsp;')
            self._prj_link = name

        # Add a hyperlink to _prj_url, if _prj_link doesn't already
        # contain any hyperlinks.
        if (self._prj_link and self._prj_url and
            not re.search(r'<a[^>]*\shref', self._prj_link)):
            self._prj_link = ('<a class="navbar" target="_top" href="'+
                              self._prj_url+'">'+self._prj_link+'</a>')

    def num_files(self):
        """
        @return: The number of files that this C{HTMLFormatter} will
            generate.
        @rtype: C{int}
        """
        # Basic files (index.html, tree, indices, help, css, toc,
        # toc-everything, frames, base directory index.html, base
        # directory css)
        if self._create_private_docs: n = 18
        else: n = 8

        for uid in self._docmap.keys():
            # Module and class API files
            if not (uid.is_module() or uid.is_class()): continue
            if not uid.is_private(): n += 1
            if self._create_private_docs: n += 1

            # Module TOC files.
            if not uid.is_module(): continue
            if not uid.is_private(): n += 1
            if self._create_private_docs: n += 1
        return n

    #////////////////////////////////////////////////////////////
    # Write (and its helpers)
    #////////////////////////////////////////////////////////////
    
    def write(self, directory=None, progress_callback=None):
        """
        Write the documentation to the given directory.

        @type directory: C{string}
        @param directory: The directory to which output should be
            written.  If no directory is specified, output will be
            written to the current directory.  If the directory does
            not exist, it will be created.
        @type progress_callback: C{function}
        @param progress_callback: A callback function that is called
            before each file is written, with the name of the created
            file.
        @rtype: C{None}
        @raise OSError: If C{directory} cannot be created,
        @raise OSError: If any file cannot be created or written to.
        """
        if not directory: directory = os.curdir
        self._show_private = 0

        # Keep track of failed xrefs, and report them at the end.
        self._failed_xrefs = {}

        # Create dest directories, if necessary
        if not os.path.isdir(directory):
            if os.path.exists(directory):
                raise OSError('%r is not a directory' % directory)
            os.mkdir(directory)
        if self._create_private_docs:
            if not os.path.isdir(os.path.join(directory, 'private/')):
                if os.path.exists(os.path.join(directory, 'private/')):
                    raise OSError('%r is not a directory' %
                                  os.path.join(directory, 'private/'))
                os.mkdir(os.path.join(directory, 'private/'))
            if not os.path.isdir(os.path.join(directory, 'public/')):
                if os.path.exists(os.path.join(directory, 'public/')):
                    raise OSError('%r is not a directory' %
                                  os.path.join(directory, 'public/'))
                os.mkdir(os.path.join(directory, 'public/'))

        if self._create_private_docs:
            # Create the public version of the API docs
            self._epytext_cache = {}
            self._show_private = 0
            self._write(os.path.join(directory, 'public/'),
                        progress_callback)

            # Create the private version of the API docs.
            self._epytext_cache = {}
            self._show_private = 1
            self._write(os.path.join(directory, 'private/'),
                        progress_callback)

            # Create the base directory index.html file.
            self._write_index(directory, progress_callback, 1)
            filename = os.path.join(directory, 'epydoc.css')
            if progress_callback: progress_callback(filename)
            self._show_private = 0
            self._write_css(filename)
        else:
            self._epytext_cache = {}
            self._show_private = 0
            self._write(directory, progress_callback)

        # Report any failed xrefs
        if self._failed_xrefs:
            if sys.stderr.softspace: print >>sys.stderr
            print >>sys.stderr, 'Warning: Failed crossreference links: '
            estr = ', '.join(self._failed_xrefs.keys())
            print >>sys.stderr, markup.wordwrap(estr, indent=9)

    def _write(self, directory, progress_callback):
        """
        A helper for L{write} that writes all documentation to a given
        directory.  This is typically called once for the public
        API documentation, and once for the private API documentation. 
        """
        # Write the object documentation.
        self._write_docs(directory, progress_callback)
        
        # Write the tree file (package & class hierarchies)
        filename = os.path.join(directory, 'trees.html')
        if progress_callback: progress_callback(filename)
        self._write_trees(filename)

        # Write the index file.
        filename = os.path.join(directory, 'indices.html')
        if progress_callback: progress_callback(filename)
        self._write_indices_to_stream(open(filename, 'w'))

        # Write the help file.
        filename = os.path.join(directory, 'help.html')
        if progress_callback: progress_callback(filename)
        self._write_help(filename)
        
        # Write the frames-based table of contents
        self._write_frames(directory, progress_callback)
        
        # Write the index.html file.
        self._write_index(directory, progress_callback, 0)
        
        # Write the CSS file.
        filename = os.path.join(directory, 'epydoc.css')
        if progress_callback: progress_callback(filename)
        self._write_css(filename)

    def _write_docs(self, directory, progress_callback):
        """
        Write the object documentation to the given directory.  The
        object documentation consists of one file for each module and
        class.

        @rtype: C{None}
        """
        for uid in self._filtersort_uids(self._docmap.keys()):
            doc = self._docmap[uid]
            filename = os.path.join(directory, self._uid_to_uri(uid))
            if isinstance(doc, ModuleDoc):
                if progress_callback: progress_callback(filename)
                str = self._module_to_html(uid)
                open(filename, 'w').write(str)
            elif isinstance(doc, ClassDoc):
                if progress_callback: progress_callback(filename)
                str = self._class_to_html(uid)
                open(filename, 'w').write(str)

    def _write_frames(self, directory, progress_callback):
        """
        Write the frames-driven contents files for the project to the
        given directory.

          - C{frames.html}
          - C{toc.html}
          - C{toc-everything.html}
          - C{toc-I{module}-module.html}

        @rtype: C{None}
        """
        # Write the frames index file
        filename = os.path.join(directory, 'frames.html')
        if progress_callback: progress_callback(filename)
        prj_name = self._prj_name or "API Documentation"
        open(filename, 'w').write(FRAMES_INDEX % (prj_name, self._top_page))

        # Write the top-level table of contents.
        filename = os.path.join(directory, 'toc.html')
        if progress_callback: progress_callback(filename)
        open(filename, 'w').write(self._toc_to_html())

        # Classes table of contents
        filename = os.path.join(directory, 'toc-everything.html')
        if progress_callback: progress_callback(filename)
        str = self._project_toc_to_html()
        open(filename, 'w').write(str)

        # Write the table of contents for each module.
        for uid in self._filtersort_uids(self._docmap.keys()):
            if uid.is_module():
                doc = self._docmap[uid]
                filename = os.path.join(directory, 'toc-%s' %
                                        self._uid_to_uri(uid))
                str = self._module_toc_to_html(uid)
                if progress_callback: progress_callback(filename)
                open(filename, 'w').write(str)

    def _write_index(self, directory, progress_callback, frombase):
        """
        Write the C{index.html} file to the given file.
        
        @param frombase: True if this is the index file for the base
            directory when we are generating both public and private
            documentation.  In this case, all hyperlinks should be
            changed to point into the C{public} subdirectory.
        @type frombase: C{boolean}
        """
        filename = os.path.join(directory, 'index.html')
        if progress_callback: progress_callback(filename)
        if self._frames_index: top = 'frames.html'
        else: top = self._top_page

        # Copy the non-frames index file from top, if it's internal.
        if top[:5] != 'http:' and '/' not in top:
            try:
                # Read top into str.
                if frombase:
                    pubdir = os.path.join(directory, 'public')
                    topfile = os.path.join(pubdir, top)
                else:
                    topfile = os.path.join(directory, top)
                str = open(topfile, 'r').read()

                # Redirect links, if appropriate.
                if frombase:
                    INTERNAL_LINK = r'(<a[^>]+href=")([^:">]+"[^>]*>)'
                    FRAME_LINK = r'(<frame[^>]+src=")([^:">]+"[^>]*>)'
                    str = re.sub(INTERNAL_LINK, r'\1public/\2', str)
                    str = re.sub(FRAME_LINK, r'\1public/\2', str)

                # Write the output file.
                open(filename, 'w').write(str)
                return
            except:
                if sys.stderr.softspace: print >>sys.stderr
                estr = 'Warning: error copying index; using a redirect page'
                print >>sys.stderr, estr
                if frombase: top = 'public/%s' % top

        # Use a redirect if top is external, or if we faild to copy.
        name = self._prj_name or 'this project'
        open(filename, 'w').write(REDIRECT_INDEX % (top, top, name))

    def _write_help(self, filename):
        """
        Write the help file to the given file.  If C{self._helpfile}
        contains a help file, then use it; otherwise, use the default
        helpfile.

        @rtype: C{None}
        """
        # Get the contents of the help file.
        if self._helpfile:
            if os.path.exists(self._helpfile):
                try: help = open(self._helpfile).read()
                except: raise IOError("Can't open help file: %r" %
                                      self._helpfile)
            else:
                raise IOError("Can't find help file: %r" % self._helpfile)
        else:
            if self._prj_name: thisprj = self._prj_name
            else: thisprj = 'this project'
            help = HTML_HELP % {'this_project':thisprj}
        
        # Write the help file.
        helpfile = open(filename, 'w')
        helpfile.write(self._header('Help')+self._navbar('help', 1)+
                       help+self._navbar('help', 0)+self._footer())
        helpfile.close()

    def _write_trees(self, filename):
        """
        Write the trees file to the given file.
        """
        open(filename, 'w').write(self._trees_to_html())
        
    def _write_css(self, filename):
        """
        Write the CSS stylesheet to the given file.  If
        C{self._css} contains a stylesheet file or name (from
        L{epydoc.css}), then use that stylesheet; otherwise, if a
        stylesheet file already exists, use that stylesheet.
        Otherwise, use the default stylesheet.

        @rtype: C{None}
        """
        if self._show_private: cssname = self._private_css
        else: cssname = self._css
        
        # Get the contents for the stylesheet file.  If none was
        # specified, and a stylesheet is already present, then don't
        # do anything.
        if cssname is None:
            if os.path.exists(filename):
                return
            else: css = STYLESHEETS['default'][0]
        else:
            if os.path.exists(cssname):
                try: css = open(cssname).read()
                except: raise IOError("Can't open CSS file: %r" % cssname)
            elif STYLESHEETS.has_key(cssname):
                css = STYLESHEETS[cssname][0]
            else:
                raise IOError("Can't find CSS file: %r" % cssname)

        # Write the stylesheet.
        cssfile = open(filename, 'w')
        cssfile.write(css)
        cssfile.close()
                       
    #////////////////////////////////////////////////////////////
    # HTML page generation
    #////////////////////////////////////////////////////////////
    # Each of these functions creates a single HTML file, and returns
    # it as a string.
    
    def _module_to_html(self, uid):
        """
        @return: An HTML page describing the module identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the module that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation.
        doc = self._docmap[uid]

        # Write the header & navigation bar.
        str = self._header(uid.name())
        str += self._navbar(uid, 1)
        if uid.is_package(): str += self._start_of('Package Description')
        else: str += self._start_of('Module Description')
            
        # The breadcrumbs & module  name
        #str += '<h3 class="module">%s</h3>' % self._breadcrumbs(uid)
        if uid.is_package():
            str += '<h2 class="package">Package '+uid.name()+'</h2>\n\n'
        else:
            str += '<h2 class="module">Module '+uid.name()+'</h2>\n\n'

        # Write the module's description.
        if doc.descr():
            str += self._docstring_to_html(doc.descr(), uid) + '<hr/>\n'

        # Add version, author, warnings, requirements, notes, etc.
        str += self._standard_fields(doc)

        # If it's a package, add a list of sub-modules.
        if doc.ispackage():
            str += self._module_list(doc.modules(), doc.sortorder(),
                                     doc.groups())

        # Show the summaries for classes, exceptions, functions, and
        # variables contained in the module.
        (classes,excepts) = self._split_classes(doc.classes())
        str += self._class_summary(classes, doc.sortorder(),
                                   doc.groups(), 'Classes')
        str += self._class_summary(excepts, doc.sortorder(),
                                   doc.groups(), 'Exceptions')
        str += self._func_summary(doc.functions(), doc.sortorder(),
                                  None, doc.groups(), 'Function Summary')
        str += self._var_summary(doc.variables(), doc.sortorder(),
                                 uid, doc.groups(), 'Variable Summary')

        # Show a list of all imported objects.
        (iclasses,iexcepts) = self._split_classes(doc.imported_classes())
        str += self._imports(iclasses, iexcepts, doc.imported_functions(),
                             doc.imported_variables(), doc.sortorder())

        # Show details for the functions and variables.
        str += self._func_details(doc.functions(), None)
        str += self._var_details(doc.variables(), uid)

        # Add another navigation bar and the footer.
        str += self._navbar(uid) + self._footer()
        
        return str

    def _class_to_html(self, uid):
        """
        @return: An HTML page describing the class identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the class that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation
        doc = self._docmap[uid]
        
        # Write the header & navigation bar.
        str = self._header(uid.name())
        str += self._navbar(uid, 1)
        str += self._start_of('Class Description')

        # The breadcrumbs & class name
        #str += '<h3 class="class">%s</h3>' % self._breadcrumbs(uid)
        str += '<h2 class="class">Class ' + uid.shortname()+'</h2>\n\n'

        # Write the base class tree
        if doc.bases():
            str += '<pre class="base-tree">\n' 
            str += self._base_tree(uid) 
            str += '</pre><br />\n\n'

        # Write the class's known subclasses
        if doc.subclasses():
            str += '<dl><dt><b>Known Subclasses:</b></dt>\n<dd>'
            for cls in doc.subclasses():
                str += '    '+self._link_to_html(cls) + ',\n'
            str = str[:-2] + '</dd></dl>\n\n'

        # Write the class's description
        if doc.descr():
            str += '<hr/>\n' + self._docstring_to_html(doc.descr(), uid)
            str += '\n\n'
        str += '<hr/>\n\n'

        # Add version, author, warnings, requirements, notes, etc.
        str += self._standard_fields(doc)

        # Show the summaries for methods, instance variables, and
        # class variables contained in the class.
        allmethods = doc.methods()+doc.staticmethods()+doc.classmethods()
        str += self._func_summary(allmethods, doc.sortorder(),
                                  doc, doc.groups(), 'Method Summary')
        str += self._property_summary(doc.properties(), doc.sortorder(),
                                      uid, doc.groups(), 'Property Summary')
        str += self._var_summary(doc.ivariables(), doc.sortorder(),
                                 uid, doc.groups(),
                                 'Instance Variable Summary')
        str += self._var_summary(doc.cvariables(), doc.sortorder(),
                                 uid, doc.groups(),
                                 'Class Variable Summary')

        # Show details for methods and variables
        if doc.staticmethods() or doc.classmethods():
            str += self._func_details(doc.methods(), doc, 
                                      'Instance Method Details')
            str += self._func_details(doc.staticmethods(), doc, 
                                      'Static Method Details')
            str += self._func_details(doc.classmethods(), doc, 
                                      'Class Method Details')
        else:
            str += self._func_details(doc.methods(), doc, 
                                      'Method Details')
        str += self._property_details(doc.properties(), uid,
                                     'Property Details')
        str += self._var_details(doc.ivariables(), uid,
                                 'Instance Variable Details')
        str += self._var_details(doc.cvariables(), uid,
                                 'Class Variable Details')

        # Add a navigation bar and the footer.
        str += self._navbar(uid) + self._footer()
        
        return str

    def _trees_to_html(self):
        """
        @return: An HTML page containing the module and class
            hierarchies. 
        @rtype: C{string}
        """
        # Header and navigation bar
        str = self._header('Module and Class Hierarchies')
        str += self._navbar('trees', 1)

        # Module hierarchy
        str += self._start_of('Module Hierarchy')
        str += '<h2>Module Hierarchy</h2>\n'
        str += self._module_tree()

        # Does the project define any classes?
        defines_classes = 0
        for uid in self._docmap.keys():
            if uid.is_class(): defines_classes = 1; break

        # Class hierarchy
        if defines_classes:
            str += self._start_of('Class Hierarchy')
            str += '<h2>Class Hierarchy</h2>\n'
            str += self._class_tree()

        # Navigation bar and footer
        str += self._navbar('trees')
        str += self._footer()
        return str

    def _write_indices_to_stream(self, out):
        """
        Write the index to the given file-like object.  I write
        directly to the file (unlike most other pages, which are
        converted to strings, and then written) because the index page
        can be quite large.  For example, for the Python standard
        library, the index page is over 1.5mb.
        @param out: The stream to which the index should be written.
        @type out: C{stream}
        @rtype: C{None}
        """
        # Header and navigation bar.
        out.write(self._header('Index'))
        out.write(self._navbar('indices', 1))
        out.write('<br />\n')

        # Term index
        index_terms, index_links = self._extract_term_index()
        if index_terms:
            out.write(self._start_of('Term Index'))
            out.write(self._table_header('Term Index', 'index'))
            terms = index_terms.keys()
            terms.sort()
            for term in terms:
                termtext = index_terms[term].to_plaintext(None)
                str = '  <tr><td width="15%">'+termtext
                str += '</td>\n    <td>'
                index_links[term].sort()
                for link in index_links[term]:
                    str += ('<i><a href="%s#%s">%s</a></i>, ' %
                            (self._uid_to_uri(link.target()),
                             term, link.name()))
                out.write(str[:-2] + '</tr></td>\n')
            out.write('</table>\n' +  '<br />\n')

        # Identifier index
        identifiers = self._extract_identifier_index()
        if identifiers:
            out.write(self._start_of('Identifier Index'))
            out.write(self._table_header('Identifier Index', 'index'))
            for uid in identifiers:
                href = self._uid_to_href(uid, uid.shortname())

                # Create the description string.
                if uid.is_package(): descr = 'Package'
                elif uid.is_module(): descr = 'Module'
                elif uid.is_class(): descr = 'Class'
                elif uid.is_variable(): descr = 'Variable'
                elif uid.is_method() or uid.is_builtin_method():
                    descr = 'Method'
                elif uid.is_function() or uid.is_builtin_function():
                    descr = 'Function'
                puid = uid.parent()
                if puid:
                    if puid.is_package(): descr +=' in package '
                    elif puid.is_module(): descr +=' in module '
                    elif puid.is_class(): descr +=' in class '
                    else: descr +=' in '
                    descr += self._uid_to_href(uid.parent())

                # Write the index entry.
                out.write('  <tr><td width="15%%">%s</td>\n' % href)
                out.write('    <td>%s</td></tr>\n' % descr)

            out.write('</table>\n' +  '<br />\n')

        # Navigation bar and footer.
        out.write(self._navbar('indices'))
        out.write(self._footer())

    def _toc_to_html(self):
        """
        @return: An HTML page containing the top-level table of
            contents page.  This page is used to select a module table
            of contents page, or the "everything" table of contents
            page. 
        @rtype: C{string}
        """
        uids = self._filtersort_uids(self._docmap.keys())

        # Header
        str = self._header('Table of Contents')
        str += ('<center><font size="+1"><b>Table&nbsp;of&nbsp;'
                 'Contents</b></font></center>\n<hr>\n')

        # Class table of contents (all classes/exceptions)
        str += ('<a target="moduleFrame" href="%s">%s</a><br />\n' %
                ('toc-everything.html', 'Everything'))

        # Package table of contents (individual packages)
        str += self._start_of('Packages')
        str += '<br /><font size="+1"><b>Packages</b></font><br />\n'
        for uid in uids:
            if uid.is_package():
                str += ('<a target="moduleFrame" href="toc-%s">'+
                        '%s</a><br />\n') % (self._uid_to_uri(uid), uid)

        # Module table of contents (individual modules)
        str += self._start_of('Modules')
        str += '<br /><font size="+1"><b>Modules</b></font><br />\n'
        for uid in uids:
            if uid.is_module() and not uid.is_package():
                str += ('<a target="moduleFrame" href="toc-%s">'+
                        '%s</a><br />\n') % (self._uid_to_uri(uid), uid)
                
        # The private/public link.
        str += '\n<br /><hr>\n'
        str += self._public_private_link('toc')
        
        return str + '\n</body>\n</html>\n'

    def _project_toc_to_html(self):
        """
        @return: An HTML page containing the table of contents page
            for the whole project.  This page lists the classes,
            exceptions, functions, and variables defined by any module
            or package in the project.
        @rtype: C{string}
        """
        # Header and name.
        str = self._header('Everything')
        str += ('<center><font size="+1"><b>Everything</b>' +
                 '</font></center>\n<hr>\n')

        # Find classes & exceptions
        classes = [Link(c.name(),c) for c in self._docmap.keys()
                   if c.is_class()]
        (classes,excepts) = self._split_classes(classes)

        # Find functions & variables
        funcs = []; vars = []
        for (uid, doc) in self._docmap.items():
            if isinstance(doc, ModuleDoc):
                funcs += doc.functions()
                vars += doc.variables()
        
        # Only include objects that come from modules that we
        # documented.  In particular, do not include base classes,
        # inherited methods, and imported objects from other modules
        # in the index.
        documented_modules = [uid for uid in self._docmap.keys()
                              if uid.is_module()]
        documented_modules.append(None)
        classes = [c for c in classes
                   if c.target().module() in documented_modules]
        excepts = [e for e in excepts
                   if e.target().module() in documented_modules]
        funcs = [f for f in funcs
                 if f.target().module() in documented_modules]
        vars = [v for v in vars
                if v.uid().module() in documented_modules]

        # Class and excpetion lists.
        str += self._start_of('All Classes')
        str += self._toc_section('All&nbsp;Classes', classes)
        str += self._start_of('All Exceptions')
        str += self._toc_section('All&nbsp;Exceptions', excepts)
        str += self._start_of('All Functions')
        str += self._toc_section('All&nbsp;Functions', funcs)
        str += self._start_of('All Variables')
        str += self._toc_var_section('All&nbsp;Variables', vars)
        
        str += '\n<hr>\n'
        str += self._public_private_link('toc-everything')
        return str + '\n</body>\n</html>\n'

    def _module_toc_to_html(self, uid):
        """
        @return: An HTML page containing the table of contents page
            for the given module.  This page lists the modules,
            classes, exceptions, functions, and variables defined by
            the module. 
        @rtype: C{string}
        """
        doc = self._docmap[uid]
        (classes,excepts) = self._split_classes(doc.classes())

        # Header and name.
        str = self._header(uid.name())
        str += (('<center><font size="+1"><b><a target="mainFrame" '+
                'href="%s">%s</a></b></font></center>\n<hr>\n')
                % (self._uid_to_uri(uid), uid.shortname()))
        
        # Lists of modules, classes, exceptions, functions, and variables.
        if uid.is_package():
            str += self._toc_section('Modules', doc.modules())
        str += self._toc_section('Classes', classes)
        str += self._toc_section('Exceptions', excepts)
        str += self._toc_section('Functions', doc.functions())
        str += self._toc_var_section('Variables', doc.variables())
                                 
        # The private/public link.
        str += '\n<hr>\n'
        str += self._public_private_link(uid, 1)
        return str + '\n</body>\n</html>\n'
    
    #////////////////////////////////////////////////////////////
    # Navigation bar
    #////////////////////////////////////////////////////////////
    # The navigation bar is placed at the top & bottom of every HTML
    # page.
    
    def _navbar(self, where=None, top=0):
        """
        @return: The HTML code for a navigation bar on the given type
            of page.  The navigation bar typically looks like::
            
                [ Package Module Class Tree Index Help ]
                
        @rtype: C{string}
        @param where: An identifier indicating what page we're
            creating a navigation bar for.  This is either a UID
            (for an object documentation page); or one of the strings
            C{'tree'}, C{'index'}, and C{'help'}.
        @type where: C{UID} or C{string}
        @param top: Whether this is the navigation bar at the top of
            the page.
        @type top: C{boolean}
        """
        str = self._start_of('Navbar')
        str += '<table class="navbar" border="0" width="100%"'
        str += ' cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">\n'
        str += '  <tr valign="center">\n'

        # The "Home" link
        if self._top_page in ('trees.html', 'indices.html',
                              'help.html'):
            pass # We already have a link for these.
        elif (isinstance(where, UID) and
            self._uid_to_uri(where) == self._top_page):
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Home&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;<a '
            str += 'class="navbar" href="%s">Home</a>' % self._top_page
            str += '&nbsp;&nbsp;&nbsp;</th>\n' 

        # The "Tree" link
        if where == 'trees':
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Trees&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="trees.html">Trees</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Index" link
        if where == 'indices':
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="indices.html">Index</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Help" link
        if where == 'help':
            str += '    <th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Help&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += '    <th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="help.html">Help</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        if self._prj_link:
            str += '    <th class="navbar" align="right" width="100%">\n'
            str += '      <table border="0" cellpadding="0" cellspacing="0">\n'
            str += '      <tr><th class="navbar" align="center">\n'
            str += '        <p class="nomargin">\n          '
            str += self._prj_link
            str += '\n      </p></th></tr></table>\n'
            str += '    </th>\n'
        else:
            str += '    <th class="navbar" width="100%"></th>\n'
        str += '  </tr>\n</table>\n'

        # Breadcrumb, frames, and private/public link
        if top:
            str += '<table width="100%" cellpadding="0" cellspacing="0">\n'
            str += '  <tr valign="top">\n    <td width="100%">\n'
            if isinstance(where, UID): str += self._breadcrumbs(where)
            str += '    </td>\n    <td>'
            str += '<table cellpadding="0" cellspacing="0">\n'
            if self._create_private_docs:
                str += ('      <tr><td align="right">%s</td></tr>\n' %
                        self._public_private_link(where))
            str += ('      <tr><td align="right">%s</td></tr>\n' %
                    self._frames_link(where))
            str += '    </table></td>'
            str += '</tr></table>\n'
            
        return str

    def _frames_link(self, where):
        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        return ('<font size="-2">[<a href="frames.html"'+
                'target="_top">frames</a>&nbsp;|&nbsp;<a href="'+uri+
                '" target="_top">no&nbsp;frames</a>]</font>')
    
    def _public_private_link(self, where, toc=0):
        """
        @return: The HTML code for a link between the public & private
            copies of the documentation.
        @rtype: C{string}
        """
        # For private pages, there's no corresponding public page..
        if isinstance(where, UID) and where.is_private():
            return ('<font size="-2">[<b>show&nbsp;private</b>' +
                    '&nbsp;|&nbsp;hide&nbsp;private]</font>')

        if isinstance(where, UID): uri = self._uid_to_uri(where)
        else: uri = where+'.html'
        if toc: uri = 'toc-'+uri
        
        if self._show_private:
            return ('<font size="-2">[show&nbsp;private&nbsp;|&nbsp;' +
                    '<a href="../public/' + uri + '">hide&nbsp;private' +
                    '</a>]</font>')
        else:
            return ('<font size="-2">[<a href="../private/' + uri +
                    '">show&nbsp;private</a>&nbsp;|&nbsp;hide&nbsp;' +
                    'private]</font>')
    
    def _breadcrumbs(self, uid):
        """
        @return: The HTML code for a series of links to the parents of
            C{uid}.
        @rtype: C{string}
        """
        #if not uid.parent(): return '</br>\n'
        if uid.is_package(): crumbs = ['Package&nbsp;%s' % uid.shortname()]
        elif uid.is_module(): crumbs = ['Module&nbsp;%s' % uid.shortname()]
        elif uid.is_class(): crumbs = ['Class&nbsp;%s' % uid.shortname()]
        uid = uid.parent()
        while uid is not None:
            if uid.is_package(): label = 'Package&nbsp;%s' % uid.shortname()
            elif uid.is_module(): label = 'Module&nbsp;%s' % uid.shortname()
            elif uid.is_class(): label = 'Class&nbsp;%s' % uid.shortname()
            else: raise ValueError('Bad uid type for breadcrumbs')
            crumbs.append(self._uid_to_href(uid, label, code=0))
            uid = uid.parent()
        crumbs.reverse()
        str = '<font size="-1"><b class="breadcrumbs">\n  '
        str += ' ::\n  '.join(crumbs)
        str += '</b></font></br>\n'
        return str

    #////////////////////////////////////////////////////////////
    # Base class trees
    #////////////////////////////////////////////////////////////
    
    def _find_tree_width(self, uid):
        """
        @return: The width of a base tree, when drawn
            right-justified.  This is used by L{_base_tree} to
            determine how far to indent lines of the base tree.
        @rtype: C{int}
        """
        width = 2
        if self._docmap.has_key(uid):
            for base in self._docmap[uid].bases():
                width = max(width, len(base.name())+4)
                width = max(width, self._find_tree_width(base.target())+4)

        return width
        
    def _base_tree(self, uid, width=None, postfix=''):
        """
        @return: The HTML code for a class's base tree.  The tree is
            drawn 'upside-down' and right justified, to allow for
            multiple inheritance.
        @rtype: C{string}
        """
        if not self._docmap.has_key(uid): return ''
        if width == None:
            width = self._find_tree_width(uid)
        
        bases = self._docmap[uid].bases()
        
        if postfix == '':
            str = ' '*(width-2) + '<b>'+uid.shortname()+'</b>\n'
        else: str = ''
        for i in range(len(bases)-1, -1, -1):
            base = bases[i]
            str = (' '*(width-4-len(base.name())) +
                   self._link_to_html(base)+' --+'+postfix+'\n' + 
                   ' '*(width-4) +
                   '   |'+postfix+'\n' +
                   str)
            (t,w) = (base.target(), width)
            if i != 0:
                str = (self._base_tree(t, w-4, '   |'+postfix)+str)
            else:
                str = (self._base_tree(t, w-4, '    '+postfix)+str)
        ss = re.sub('<[^<>]+>','',str)
        return str
                
    #////////////////////////////////////////////////////////////
    # Class hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _class_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_class_tree}.
        """
        if uid is not None:
            doc = self._docmap.get(uid, None)
            str = ' '*depth + '<li> <b>' + self._uid_to_href(uid)+'</b>'
            if doc and doc.descr():
                str += ': <i>' + self._summary(doc, uid.module()) + '</i>'
            str += '\n'
            if doc and doc.subclasses():
                str += ' '*depth + '  <ul>\n'
                children = [l.target() for l
                            in self._filtersort_links(doc.subclasses())]
                for child in children:
                    str += self._class_tree_item(child, depth+4)
                str += ' '*depth + '  </ul>\n'
        return str

    def _class_tree(self, sortorder=None):
        """
        @return: The HTML code for the class hierarchy tree.  This is
            used by L{_trees_to_html} to construct the hierarchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        uids = self._filtersort_uids(self._docmap.keys())
        #docs.sort(lambda a,b: cmp(a[0], b[0]))
        for uid in uids:
            doc = self._docmap[uid]
            if not isinstance(doc, ClassDoc): continue
            hasbase = 0
            for base in doc.bases():
                if self._docmap.has_key(base.target()):
                    hasbase = 1
            if not hasbase:
                str += self._class_tree_item(uid)
        return str +'</ul>\n'

    #////////////////////////////////////////////////////////////
    # Module hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _module_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_module_tree} and L{_module_list}.
        
        @rtype: C{string}
        """
        if uid is None: return ''

        doc = self._docmap.get(uid, None)
        name = uid.shortname()
        str = ' '*depth + '<li> <b>'
        str += self._uid_to_href(uid, name)+'</b>'
        if doc and doc.descr():
            str += ': <i>' + self._summary(doc, uid) + '</i>'
        str += '\n'
        if doc and doc.ispackage() and doc.modules():
            str += ' '*depth + '  <ul>\n'
            modules = [l.target() for l in 
                       self._filtersort_links(doc.modules(), doc.sortorder())]
            for module in modules:
                str += self._module_tree_item(module, depth+4)
            str += ' '*depth + '  </ul>\n'
        str += ' '*depth+'</li>\n'
        return str

    def _module_tree(self, sortorder=None):
        """
        @return: The HTML code for the module hierarchy tree.  This is
            used by L{_trees_to_html} to construct the hiearchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        uids = self._filtersort_uids(self._docmap.keys())
        #docs.sort(lambda a,b: cmp(a[0], b[0]))
        # Find all top-level packages. (what about top-level
        # modules?)
        for uid in uids:
            doc = self._docmap[uid]
            if not isinstance(doc, ModuleDoc): continue
            if not doc.package():
                str += self._module_tree_item(uid)
        return str +'</ul>\n'

    def _module_list(self, modules, sortorder, groups):
        """
        @return: The HTML code for the module hierarchy tree,
            containing the given modules.  This is used by
            L{_module_to_html} to list the submodules of a package.
        @rtype: C{string}
        """
        if len(modules) == 0: return ''
        str = self._table_header('Submodules', 'details')
        modules = self._filtersort_links(modules, sortorder)
        groupstr = ''
        
        # Create the portion of the list containing the group
        # entries.  Do this first, so we can see what's not in any
        # group; but add it to the string last, so the groupless
        # modules are at the top.
        for groupname, groupmembers in groups:
            # Extract the group
            group = [m for m in modules if m.target() in groupmembers]
            if not group: continue
            modules = [m for m in modules if m not in group]
            # Print a header within the list
            groupstr += self._group_header(groupname)
            #groupstr += ('  <tr rowspan="2" class="group"><td>\n'+
            #             '%s\n  </td></tr>\n' % groupname)
            groupstr += '  <tr><td><ul>\n\n'
            # Add the lines for each func
            for link in group:
                groupstr += self._module_tree_item(link.target())
            groupstr += '  </ul></td></tr>\n\n'

        if modules:
            str += '  <tr><td><ul>\n'
            for link in modules:
                str += self._module_tree_item(link.target())
            str += '  </ul></td></tr>\n'
        str += groupstr
        str += '</table><br />\n\n'
        return str

    #////////////////////////////////////////////////////////////
    # Class tables
    #////////////////////////////////////////////////////////////
    
    def _class_summary(self, classes, sortorder,
                       groups, heading='Class Summary'):
        """
        @return: The HTML code for the class summary table.  This is
            used by L{_module_to_html} to list the classes in a
            module.
        @rtype: C{string}
        """
        classes = self._filtersort_links(classes, sortorder)
        if len(classes) == 0: return ''
        
        # Create the portion of the table containing the group
        # entries.  Do this first, so we can see what's not in any
        # group; but add it to the string last, so the groupless
        # classs are at the top.
        groupstr = ''
        for groupname, groupmembers in groups:
            # Extract the group
            group = [c for c in classes if c.target() in groupmembers]
            if not group: continue
            classes = [c for c in classes if c not in group]
            # Print a header within the table
            groupstr += self._group_header(groupname)
            # Add the lines for each func
            for link in group:
                groupstr += self._class_summary_line(link)

        str = self._table_header(heading, 'summary')
        for link in classes:
            str += self._class_summary_line(link)
        return str + groupstr + '</table><br />\n\n'

    def _class_summary_line(self, link):
        cname = link.name()
        cls = link.target()
        if not self._docmap.has_key(cls): return ''
        cdoc = self._docmap[cls]
        csum = self._summary(cdoc, cls.module())
        str = '<tr><td width="15%">\n'
        str += '  <b>'+self._link_to_html(link)
        str += '</b></td>\n  <td>' + csum + '</td></tr>\n'
        return str

    #////////////////////////////////////////////////////////////
    # Function tables
    #////////////////////////////////////////////////////////////
    
    def _func_summary(self, functions, sortorder, cls, groups, 
                      heading='Function Summary'):
        """
        @return: The HTML code for a function summary table.  This
            is used by L{_module_to_html} to list the functions in a
            module; and by L{_class_to_html} to list member
            functions. 
        @rtype: C{string}
        """
        functions = self._filtersort_links(functions, sortorder)
        if len(functions) == 0: return ''

        # Create the portion of the table containing the group
        # entries.  Do this first, so we can see what's not in any
        # group; but add it to the string last, so the groupless
        # functions are at the top.
        groupstr = ''
        for groupname, groupmembers in groups:
            # Extract the group
            group = [f for f in functions if f.target() in groupmembers]
            if not group: continue
            functions = [f for f in functions if f not in group]
            # Print a header within the table
            groupstr += self._group_header(groupname)
            # Add the lines for each func
            for link in group:
                groupstr += self._func_summary_line(link, cls)
            if self._inheritance == 'listed' and cls is not None:
                groupstr += self._inheritance_list(group, cls.uid())

        str = self._table_header(heading, 'summary')
        for link in functions:
            str += self._func_summary_line(link, cls)
        if self._inheritance == 'listed' and cls is not None:
            str += self._inheritance_list(functions, cls.uid())
        return str + groupstr + '</table><br />\n\n'

    def _func_summary_line(self, link, cls):
        func = link.target()
        fname = link.name()
        if func.is_method() or func.is_builtin_method():
            container = func.cls()
            inherit = (container != cls.uid())
        else:
            inherit = 0
            try: container = func.module()
            except TypeError: container = None

        if inherit and self._inheritance == 'listed': return ''

        # If we don't have documentation for the function, then we
        # can't say anything about it.
        if not self._docmap.has_key(func): return ''
        fdoc = self._docmap[func]
        
        # Try to find a documented ancestor.
        while (not fdoc.documented() and fdoc.matches_override() and
               self._docmap.has_key(fdoc.overrides())):
            fdoc = self._docmap[fdoc.overrides()]

        rval = fdoc.returns()
        if rval.type():
            rtype = self._docstring_to_html(rval.type(), container, 8)
        else:
            rtype = '&nbsp;'

        descrstr = self._summary(fdoc, container)
        if descrstr != '&nbsp;':
            fsum = '<br />'+descrstr
        else:
            if inherit: fsum = '<br />\n'
            else: fsum = ''

        # Display any notable attributes.
        attribs = []
        if func.is_classmethod():
            attribs.append('Class method')
        if func.is_staticmethod():
            attribs.append('Static method')
        if inherit and self._inheritance != 'grouped':
            href = self._uid_to_href(container, container.shortname())
            attribs.append('Inherited from %s' % href)
        if attribs:
            fsum += '    <i>(' + '; '.join(attribs) + ')</i>\n'
            
        #if not fdoc.documented():
        #    fsum = '    <br /><i>(undocumented)</i>\n'
        str = '<tr><td align="right" valign="top" width="15%">'
        str += '<font size="-1">'+rtype+'</font></td>\n  <td><code>'
        if fdoc.documented() or inherit:
            str += self._func_signature(fname, fdoc, 1, 0, 'summary-sig')
        else:
            str += '<a name="%s"></a>' % fname
            str += self._func_signature(fname, fdoc, 0, 0, 'summary-sig')
        str += '</code>\n' + fsum + '</td></tr>\n'
        return str

    def _func_details(self, functions, cls, heading='Function Details'):
        """
        @return: The HTML code for a function details table.  This
            is used by L{_module_to_html} to describe the functions in
            a module; and by L{_class_to_html} to describe member
            functions.
        @rtype: C{string}
        """
        functions = self._filtersort_links(functions)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'

        numfuncs = 0
        for link in functions:
            fname = link.name()
            func = link.target()
            if func.is_method() or func.is_builtin_method():
                container = func.cls()
                inherit = (container != cls.uid())
            else:
                inherit = 0
                try: container = func.module()
                except TypeError: container = None
            if not self._docmap.has_key(func):
                continue

            # Don't document inherited methods; instead, the method
            # summary points to the details description in the parent
            # class's file.
            if inherit: continue
            
            # If we don't have documentation for the function, then we
            # can't say anything about it.
            if not self._docmap.has_key(func): continue
            fdoc = self._docmap[func]

            # What does this method override?
            foverrides = fdoc.overrides()

            # Try to find a documented ancestor.
            inhdoc = self._docmap.documented_ancestor(func) or fdoc
            inherit_docs = (inhdoc is not fdoc)

            # If we couldn't find a documented ancestor, then we don't
            # have anything else to say.
            if not inhdoc.documented(): continue

            numfuncs += 1
            str += '\n<a name="'+fname+'"></a>\n'
            str += '<table width="100%" class="func-details"'
            str += ' bgcolor="#e0e0e0"><tr><td>\n'

            str += '  <h3>%s\n' % self._func_signature(fname, fdoc)
            if SPECIAL_METHODS.has_key(fname):
                str += '    <br /><i>'
                str += '(%s)</i>\n' % SPECIAL_METHODS[fname]
            str += '  </h3>\n'

            # Use the inherited docs for everything but the signature.
            fdoc = inhdoc

            fdescr=fdoc.descr()
            fparam = fdoc.parameter_list()[:]
            if fdoc.vararg(): fparam.append(fdoc.vararg())
            if fdoc.kwarg(): fparam.append(fdoc.kwarg())
            freturn = fdoc.returns()
            fraises = fdoc.raises()
            
            # Don't list parameters that don't have any extra info.
            f = lambda p:p.descr() or p.type()
            fparam = filter(f, fparam)

            # Description
            if fdescr:
                str += self._docstring_to_html(fdescr, container, 2)
            str += '  <dl><dt></dt><dd>\n'

            # Parameters
            if fparam:
                str += '    <dl><dt><b>Parameters:</b></dt>\n'
                for param in fparam:
                    pname = param.name()
                    str += '      <dd><code><b>' + pname +'</b></code>'
                    if param.descr():
                        pdescr = self._docstring_to_html(param.descr(),
                                                         container, 8)
                        str += ' -\n %s' % pdescr.rstrip()
                    str += '\n'
                    if param.type():
                        ptype = self._docstring_to_html(param.type(),
                                                        container, 14)
                        str += '        <br /><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % ptype.strip()
                    str += '      </dd>\n'
                str += '    </dl>\n'

            # Returns
            if freturn.descr() or freturn.type():
                str += '    <dl><dt><b>Returns:</b></dt>\n      <dd>\n'
                if freturn.descr():
                    str += self._docstring_to_html(freturn.descr(),
                                                   container, 8)
                    if freturn.type():
                        rtype = self._docstring_to_html(freturn.type(),
                                                        container,14)
                        str += '        <br /><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % rtype.strip()
                elif freturn.type():
                    str += self._docstring_to_html(freturn.type(),
                                                   container, 8)
                str += '      </dd>\n    </dl>\n'

            # Raises
            if fraises:
                str += '    <dl><dt><b>Raises:</b></dt>\n'
                for fraise in fraises:
                    str += '      '
                    str += '<dd><code><b>'+fraise.name()+'</b></code> -\n'
                    str += self._docstring_to_html(fraise.descr(),
                                                   container, 8)
                    str +'      </dd>\n'
                str += '    </dl>\n'

            # Overrides
            if foverrides:
                str += '    <dl><dt><b>Overrides:</b></dt>\n'
                str += '      <dd>'+self._uid_to_href(foverrides)
                if inherit_docs:
                    str += ' <i>(inherited documentation)</i>\n'
                str += '</dd>\n    </dl>\n'

            # Add version, author, warnings, requirements, notes, etc.
            str += self._standard_fields(fdoc)

            str += '  </dd></dl>\n'
            str += '</td></tr></table>\n'

        if numfuncs == 0: return ''

        str += '<br />\n\n'
        return str

    def _func_signature(self, fname, fdoc, link=0, show_defaults=1,
                        css_class="sig"):
        """
        @return: The HTML code for the function signature of the
            function with the given name and documentation.
        @param fname: The short name of the function.
        @type fname: C{string}
        @param fdoc: The documentation for the function.
        @type fdoc: L{objdoc.FuncDoc}
        @param link: Whether to create a link from the function's name
            to its details description.
        """
        str = '<span class=%s>' % css_class
        if link: str += self._uid_to_href(fdoc.uid(), fname, css_class+'-name')
        else: str += '<span class=%s-name>%s</span>' % (css_class, fname)
        
        PARAM_JOIN = ',\n'+' '*15
        str += '('
        str += self._params_to_html(fdoc.parameters(), css_class,
                                    show_defaults)
        if fdoc.vararg():
            vararg_name = fdoc.vararg().name()
            if vararg_name != '...': vararg_name = '*%s' % vararg_name
            str += ('<span class=%s-vararg>%s</span>%s' %
                    (css_class, vararg_name, PARAM_JOIN))
        if fdoc.kwarg():
            str += ('<span class=%s-kwarg>**%s</span>%s' %
                    (css_class, fdoc.kwarg().name(), PARAM_JOIN))
        if str[-1] != '(': str = str[:-len(PARAM_JOIN)]

        return str + ')</span>'

    def _params_to_html(self, parameters, css_class, show_defaults):
        PARAM_JOIN = ',\n'+' '*15
        str = ''
        for param in parameters:
            if type(param) in (type([]), type(())):
                sublist = self._params_to_html(param, css_class,
                                               show_defaults)
                str += '(%s), ' % sublist[:-len(PARAM_JOIN)]
            else:
                str += ('<span class=%s-arg>%s</span>' %
                        (css_class, param.name()))
                if show_defaults and param.default() is not None:
                    default = param.default()
                    default = re.sub('&', '&amp;', default)
                    default = re.sub('<', '&lt;', default)
                    default = re.sub('>', '&gt;', default)
                    default = re.sub(' ', '&nbsp;', default)
                    if len(default) > 60:
                        default = default[:57]+'...'
                    str += ('=<span class=%s-default>%s</span>' %
                            (css_class, default))
                str += PARAM_JOIN
        return str

    #////////////////////////////////////////////////////////////
    # Property tables
    #////////////////////////////////////////////////////////////
    def _property_summary(self, properties, sortorder, container,
                          groups, heading='Property Summary'):
        properties = self._filtersort_links(properties, sortorder)
        if len(properties) == 0: return ''

        # Create the portion of the table containing the group
        # entries.  Do this first, so we can see what's not in any
        # group; but add it to the string last, so the groupless
        # properties are at the top.
        groupstr = ''
        for groupname, groupmembers in groups:
            # Extract the group
            group = [p for p in properties if p.target() in groupmembers]
            if not group: continue
            properties = [p for p in properties if p not in group]
            # Print a header within the table
            groupstr += self._group_header(groupname)
            # Add the lines for each func
            for property in group:
                groupstr += self._property_summary_line(property, container)
                if self._inheritance == 'listed':
                    groupstr += self._inheritance_list(group, container)

        str = self._table_header(heading, 'summary')
        for property in properties:
            str += self._property_summary_line(property, container)
        if self._inheritance == 'listed':
            str += self._inheritance_list(properties, container)
        return str + groupstr + '</table><br />\n\n'

    def _property_summary_line(self, link, container):
        prop = link.target()
        pname = link.name()
        
        inherit = (container.is_class() and container != prop.cls())
        if inherit and self._inheritance == 'listed': return ''
        
        # If we don't have documentation for the properties, then we
        # can't say anything about it.
        if not self._docmap.has_key(prop): return ''
        pdoc = self._docmap[prop]

        # Get the property's type, if it has one.
        if pdoc.type():
            ptype = self._docstring_to_html(pdoc.type(), container, 10).strip()
        else: ptype = '&nbsp;'

        # Get the summary of the description.
        descrstr = self._summary(pdoc, container)
        if descrstr != '&nbsp;': psum = ': '+descrstr
        else: psum = ''
        
        str = '<tr><td align="right" valign="top" '
        str += 'width="15%"><font size="-1">'+ptype+'</font></td>\n'
        str += '  <td><b>%s</b>%s' % (self._link_to_html(link), psum)
        if (self._inheritance != 'grouped' and inherit):
            cls = prop.cls()
            str += ('    <i>(Inherited from %s)</i>\n' %
                    self._uid_to_href(cls, cls.shortname()))
        str += '</td></tr>'
        return str

    def _property_details(self, properties, container,
                          heading='Property Details'):
        properties = self._filtersort_links(properties)
        if len(properties) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'

        numprops = 0
        for link in properties:

            prop = link.target()
            pname = link.name()

            # Don't document inherited properties; instead, the
            # property summary points to the details description in
            # the parent class's file.
            if container != prop.cls(): continue
            
            if not self._docmap.has_key(prop): continue
            pdoc = self._docmap[prop]
            numprops += 1

            str += '<table width="100%" class="func-details"'
            str += ' bgcolor="#e0e0e0"><tr><td>\n'
            str += '\n<a name="%s"></a>\n' % pname
            str += '<h3>'+pname+'</h3>\n'

            if pdoc.descr():
                str += self._docstring_to_html(pdoc.descr(), container)

            # Print the accessors for the property (fget=get property
            # value; fset=set value, and fdel=delete value).
            if pdoc.fget() or pdoc.fset() or pdoc.fdel():
                str += '<dl>\n  <dt></dt>\n  <dd>\n    <dl>\n'
                for (func,name) in [(pdoc.fget(), 'Get'),
                                    (pdoc.fset(), 'Set'),
                                    (pdoc.fdel(), 'Delete')]:
                    if func:
                        str += '      <dt><b>%s Function:' % name
                        str += '</b></dt>\n      <dd>'
                        if self._docmap.has_key(func):
                            fdoc = self._docmap[func]
                            fname = func.name()
                            str += self._func_signature(fname, fdoc, 1, 0,
                                                    'summary-sig')
                        else:
                            str += self._uid_to_href(func)
                        str += '\n      </dd>\n'
                str += '    </dl>\n  </dd>\n</dl>'

            str += '</td></tr></table>'

        if numprops == 0: return ''
        return str+'<br />'
    
    #////////////////////////////////////////////////////////////
    # Variable tables
    #////////////////////////////////////////////////////////////
    
    def _var_summary(self, variables, sortorder, container,
                     groups, heading='Variable Summary'):
        """
        @return: The HTML code for a variable summary table.  This
            is used by L{_module_to_html} to list the variables in a
            module; and by L{_class_to_html} to list instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._filtersort_vars(variables, sortorder)
        if len(variables) == 0: return ''

        # Create the portion of the table containing the group
        # entries.  Do this first, so we can see what's not in any
        # group; but add it to the string last, so the groupless
        # variables are at the top.
        groupstr = ''
        for groupname, groupmembers in groups:
            # Extract the group
            group = [v for v in variables if v.uid() in groupmembers]
            if not group: continue
            variables = [v for v in variables if v not in group]
            # Print a header within the table
            groupstr += self._group_header(groupname)
            # Add the lines for each func
            for var in group:
                groupstr += self._var_summary_line(var, container)
            if self._inheritance == 'listed' and container.is_class():
                groupstr += self._inheritance_list(group, container)

        str = self._table_header(heading, 'summary')
        for var in variables:
            str += self._var_summary_line(var, container)
        if self._inheritance == 'listed' and container.is_class():
            str += self._inheritance_list(variables, container)
        return str + groupstr + '</table><br />\n\n'

    def _var_summary_line(self, var, container):
        inherit = (container.is_class() and container != var.uid().cls())
        if inherit and self._inheritance == 'listed': return ''
            
        vname = var.name()
        if var.type():
            vtype = self._docstring_to_html(var.type(), container, 10).strip()
        else: vtype = '&nbsp;'
        if var.descr():
            vsum = ': ' +self._summary(var.descr(), container)
        else:
            title = self._var_value_tooltip(var)
            val = self._pprint_var_value(var, context='summary')
            vsum = ' = <span title="%s">%s</span>' % (title, val)
        str = '<tr><td align="right" valign="top" '
        str += 'width="15%"><font size="-1">'+vtype+'</font></td>\n'
        str += '  <td><b>'

        # If we don't have any info about it, then just list it in
        # the summary (not the details).
        if (var.descr() is None and var.type() is None and
            not var.has_value()):
            str += '<code><a name="%s">%s</a></code>' % (vname, vname)
        else:
            str += self._uid_to_href(var.uid(), vname)
        str += '</b>' + vsum 
        if (self._inheritance != 'grouped' and inherit):
            str += ('    <i>(Inherited from %s)</i>\n' %
                    self._uid_to_href(container, container.shortname()))
        return str + '</td></tr>\n'

    def _var_details(self, variables, container, heading='Variable Details'):
        """
        @return: The HTML code for a variable details table.  This
            is used by L{_module_to_html} to describe the variables in
            a module; and by L{_class_to_html} to describe instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._filtersort_vars(variables)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'

        numvars = 0
        for var in variables:
            vname = var.name()
            vtyp = var.type()
            hasval = var.has_value()

            # Don't document inherited variables; instead, the
            # property summary points to the details description in
            # the parent class's file.
            if container.is_class() and container != var.uid().cls():
                continue

            # Don't bother if we don't know anything about it.
            if (var.descr() is None and vtyp is None and not hasval):
                continue
            numvars += 1
            
            str += ('<table width="100%" class="var-details"'+
                    ' bgcolor="#e0e0e0">'+
                    '<tr><td>\n')
            str += '<a name="'+vname+'"></a>\n'
            str += '<h3>'+vname+'</h3>\n'

            # If it's a module, class, method, type, or func, then
            # just link to it.
            if not var.uid().is_variable():
                str += ('<code>%s</code> = %s\n' %
                        (vname, self._uid_to_href(var.uid())))
                if self._documented(var.uid()):
                    str += '</td></tr></table>\n'
                    continue

            if var.descr():
                str += self._docstring_to_html(var.descr(), container)
                
            if vtyp is not None or hasval:
                str += '<dl>\n  <dt></dt>\n  <dd>\n    <dl>\n'
                
            if vtyp:
                str += '      <dt><b>Type:</b></dt>\n      <dd>\n' 
                str += self._docstring_to_html(vtyp, container)
                str += '\n      </dd>\n'

            str += '<span title="%s">' % self._var_value_tooltip(var)
            str += self._pprint_var_value(var)
            str += '</span>'

            if vtyp is not None or hasval:
                str += '    </dl>\n  </dd>\n</dl>'
                
            str += '</td></tr></table>\n'

        # If we didn't get any variables, don't print anything.
        if numvars == 0: return ''
        return str+'<br />'

    def _var_value_tooltip(self, var):
        val = `var.uid().value()`
        if len(val) > self._variable_tooltip_linelen:
            val = val[:self._variable_tooltip_linelen-3]+'...'
        val = val.replace('&', '&amp;').replace('"', '&quot;')
        val = val.replace('<', '&lt;').replace('>', '&gt;')
        return val

    def _pprint_var_value(self, var, context='details'):
        if not var.has_value(): return ''
        val = var.uid().value()
        do_quoting = 1

        # For regexps, use colorize_re.
        if type(val).__name__ == 'SRE_Pattern':
            val = colorize_re(val)
            do_quoting = 0
            
        # For strings, use repr.  Use tripple-quoted-strings where
        # appropriate.
        elif type(val) is type(''):
            val = `val`
            val = re.sub('&', '&amp;', val)
            val = re.sub('<', '&lt;', val)
            val = re.sub('>', '&gt;', val)
            do_quoting = 0
            if val.find(r'\n') >= 0 and context != 'summary':
                val = ('<span class="variable-quote">'+val[0]*3+'</span>'+
                        val[1:-1].replace(r'\n', '\n') +
                       '<span class="variable-quote">'+val[0]*3+'</span>')
                       
            else:
                val = ('<span class="variable-quote">'+val[0]+'</span>'+
                       val[1:-1]+
                       '<span class="variable-quote">'+val[0]+'</span>')

        # For lists, tuples, and dicts, use pprint.
        elif type(val) in (type(()), type([]), type({})):
            val = pprint.pformat(val)

        # For other objects, use repr to generate a representation.
        else:
            try: val = `val`
            except: val = '...'

        # Quote characters, where appropriate.
        if do_quoting:
            val = re.sub('&', '&amp;', val)
            val = re.sub('<', '&lt;', val)
            val = re.sub('>', '&gt;', val)

        # For the summary table, just return the value; don't
        # bother to word-wrap.
        if context == 'summary':
            val = re.sub(r'\n', '', val)
            if val.startswith('<span class='):
                val = val[:12] + re.sub(' ', '&nbsp;', val[12:])
            else:
                val = re.sub(' ', '&nbsp;', val)
            val = self._linewrap_html(val, self._variable_summary_linelen, 1)
            return '<code>%s</code>\n' % val

        # Do line-wrapping.
        val = self._linewrap_html(val, self._variable_linelen,
                                  self._variable_maxlines)

        # Construct the value box.
        str = '      <dt><b>Value:</b></dt>\n' 
        str += '      <dd><table><tr><td>\n'
        str += '<pre class="variable">\n%s</pre>\n' % val
        str += '        </td></tr></table></dd>\n'
        return str

    def _linewrap_html(self, str, linelen, maxlines):
        """
        Add line-wrapping to the HTML string C{str}.  Line length is
        determined by C{linelen}; and the maximum number of
        lines to display is determined by C{maxlines}.  This
        function treats HTML entities (e.g., C{&amp;}) as single
        characters; and ignores HTML tags (e.g., C{<p>}).
        """
        LINEWRAP_MARKER = r'<span class="variable-linewrap">\</span>'
        ELLIPSIS_MARKER = r'<span class="variable-ellipsis">...</span>'
        
        lines = []
        start = end = cnum = 0
        while len(lines) <= maxlines and end < len(str):
            # Skip over HTML tags.
            if str[end] == '<':
                end = str.find('>', end)
                cnum -= 1

            # HTML entities just count as 1 char.
            elif str[end] == '&':
                end = str.find(';', end)

            # Go on to the next character.
            cnum += 1
            end += 1

            # Check for end-of-line.
            if str[end-1] == '\n':
                lines.append(str[start:end-1])
                cnum = 0
                start = end

            # Check for line-wrap
            if cnum == linelen and end<len(str) and str[end] != '\n':
                if maxlines == 1:
                    return str[start:end]+ELLIPSIS_MARKER
                lines.append(str[start:end]+LINEWRAP_MARKER)
                cnum = 0
                start = end

        # Add on anything that's left.
        if end == len(str):
            lines.append(str[start:end])

        # Use the ellipsis marker if the string is too long.
        if len(lines) > maxlines:
            lines[-1] = ELLIPSIS_MARKER
            cnum = 3

        # Pad the last line to linelen.
        lines[-1] += ' '*(linelen-cnum+1)

        return ('\n').join(lines)
            
    #////////////////////////////////////////////////////////////
    # Term index generation
    #////////////////////////////////////////////////////////////
    
    def _get_index_terms(self, parsed_docstring, link, terms, links):
        if parsed_docstring is None: return
        for term in parsed_docstring.index_terms():
            key = self._term_index_to_anchor(term)
            if not terms.has_key(key):
                terms[key] = term
                links[key] = []
            links[key].append(link)

    def _extract_term_index(self):
        """
        @return: Two dictionaries:
          - the first maps keys to terms
          - the second maks keys to lists of links
        @rtype: C{dictionary}
        """
        terms = {}
        links = {}
        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            
            if uid.is_function():
                link = Link(uid.name(), uid.module())
            elif uid.is_method():
                link = Link(uid.name(), uid.cls())
            else:
                link = Link(uid.name(), uid)

            # Get index items from standard fields.
            for field in self._standard_field_values(doc):
                self._get_index_terms(field, link, terms, links)
            if doc.descr():
                self._get_index_terms(doc.descr(), link, terms, links)

            # Get index items from object-specific fields.
            if isinstance(doc, ModuleDoc):
                for var in doc.variables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_index_terms(var.descr(), link, terms, links)
                    self._get_index_terms(var.type(), link, terms, links)
            elif isinstance(doc, ClassDoc):
                for var in doc.ivariables() + doc.cvariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    self._get_index_terms(var.descr(), link, terms, links)
                    self._get_index_terms(var.type(), link, terms, links)
            elif isinstance(doc, FuncDoc):
                extra_p = [v for v in [doc.vararg(), doc.kwarg(),
                                       doc.returns()] if v is not None]
                for param in doc.parameter_list()+extra_p:
                    self._get_index_terms(param.descr(), link, terms, links)
                    self._get_index_terms(param.type(), link, terms, links)
                for fraise in doc.raises():
                    self._get_index_terms(fraise.descr(), link, terms, links)
                    
        return terms, links

    #////////////////////////////////////////////////////////////
    # Identifier index generation
    #////////////////////////////////////////////////////////////

    def _extract_identifier_index(self):
        """
        @rtype: C{list} of C{(string, string)}
        """
        # List of (sort-key, UID), where sort-key is
        # uid.shortname().lower().
        uids = []

        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            
            uids.append( (uid.shortname().lower(), uid) )
            if uid.is_module():
                uids += [(v.name().lower(), v.uid())
                         for v in doc.variables()
                         if not v.uid().is_private()]
            elif uid.is_class():
                uids += [(v.name().lower(), v.uid())
                         for v in doc.ivariables() + doc.cvariables()
                         if not v.uid().is_private()]

        uids.sort()
        return [u[1] for u in uids]

        # list of (name, href, descr) tripples
        identifiers = []
        
        for (uid, doc) in self._docmap.items():
            if (not self._show_private) and uid.is_private():
                continue
            if uid.is_module():
                # Add the module to the index.
                if uid.is_package() and uid.package():
                    descr = 'Subpackage in package '
                    descr += self._uid_to_href(uid.package())
                elif uid.package():
                    descr = 'Module in package '
                    descr += self._uid_to_href(uid.package())
                else: descr = 'Module'
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add all of the module's variables to the index.
                descr = ' Variable in module %s' % self._uid_to_href(uid)
                for var in doc.variables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )
                    
            elif uid.is_class():
                # Add the class to the index.
                descr = ('Class in module %s' %
                         self._uid_to_href(uid.module()))
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add all the class variables to the index.
                descr = ('Class variable in class %s' %
                         self._uid_to_href(uid))
                for var in doc.cvariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )

                # Add all the instance variables to the index.
                descr = ('Instance variable in class %s' %
                         self._uid_to_href(uid))
                for var in doc.ivariables():
                    if ((not self._show_private) and var.uid().is_private()):
                        continue
                    href = ('<a href="%s#%s">%s</a>' %
                            (self._uid_to_uri(uid), var.name(), var.name()))
                    identifiers.append( (var.name(), href, descr) )

            elif uid.is_routine():
                # Add the function/method to the index.
                if uid.is_function() or uid.is_builtin_function():
                    descr = ('Function in module %s' %
                             self._uid_to_href(uid.module()))
                else:
                    descr = ('Method in class %s' %
                             self._uid_to_href(uid.cls()))
                href = self._uid_to_href(uid, uid.shortname())
                identifiers.append( (uid.shortname(), href, descr) )

                # Add the parameters to the index.
                if self._index_parameters:
                    if uid.is_function() or uid.is_builtin_function():
                        descr = 'Parameter to function '
                        dsecr += self._uid_to_href(uid)
                    else:
                        descr = 'Parameter to method '
                        dsecr += self._uid_to_href(uid)
                    extra_p = [v for v in [doc.vararg(), doc.kwarg()]
                               if v is not None]
                    for var in doc.parameter_list()+extra_p:
                        href = self._uid_to_href(uid, var.name())
                        identifiers.append( (var.name(), href, descr) )
            else:
                raise AssertionError, 'fix me'

        identifiers.sort(lambda a,b: cmp(a[0].lower(),b[0].lower()))
        return [id[1:3] for id in identifiers]

    #////////////////////////////////////////////////////////////
    # Table of contents (frames) generation
    #////////////////////////////////////////////////////////////

    def _toc_section(self, section, links):
        # Sort & filter the links
        if not self._show_private:
            links = [o for o in links if not o.target().is_private()]
        links.sort(lambda x,y: cmp(x.name().lower(), y.name().lower()))

        if not links: return ''
        str = self._start_of(section)
        str += '<font size="+1"><b>%s</b></font><br />\n' % section
        for link in links:
            str += ('<a target="mainFrame" href="%s">%s</a><br />\n' %
                    (self._uid_to_uri(link.target()), link.name()))
        return str+'<br />\n'

    def _toc_var_section(self, section, vars):
        # Sort & filter the vars.
        if not self._show_private:
            vars = [v for v in vars if not v.uid().is_private()]
        vars.sort(lambda v1, v2: cmp(v1.name().lower(),
                                     v2.name().lower()))

        if not vars: return ''
        str = self._start_of(section)
        str += '<font size="+1"><b>%s</b></font><br />\n' % section
        for var in vars:
            str += ('<a target="mainFrame" href="%s">%s</a><br />\n' %
                    (self._uid_to_uri(var.uid()), var.name()))
        return str+'<br />\n'

    #////////////////////////////////////////////////////////////
    # Docstring -> HTML Conversion
    #////////////////////////////////////////////////////////////

    def _term_index_to_anchor(self, term):
        """
        Given the name of an inline index item, construct a URI anchor.
        These anchors are used to create links from the index page to each
        index item.
        """
        # Include "-" so we don't accidentally collide with the name
        # of a python identifier.
        s = re.sub(r'\s\s+', '-', term.to_plaintext(None))
        return "index-"+re.sub("[^a-zA-Z0-9]", "_", s)

    class _HTMLDocstringLinker(markup.DocstringLinker):
        def __init__(self, docformatter, container):
            self._docformatter = docformatter
            self._container = container
            self._docmap = docformatter._docmap
        def translate_indexterm(self, indexterm):
            key = self._docformatter._term_index_to_anchor(indexterm)
            return ('<a name="%s"></a><i class="indexterm">%s</i>' %
                    (key, indexterm.to_html(self)))
        def translate_identifier_xref(self, identifier, label=None):
            if label is None: label = markup.plaintext_to_html(identifier)
            uid = findUID(identifier, self._container, self._docmap)
            if uid is None:
                failure = identifier #'%s->%s' % (self._container, identifier)
                self._docformatter._failed_xrefs[failure] = 1
            return self._docformatter._uid_to_href(uid, label, 'link')
            
    def _docstring_to_html(self, docstring, container=None, indent=0):
        """
        @return: A string containing the HTML encoding for the given
            C{ParsedDocstring}
        @rtype: L{markup.ParsedDocstring}
        """
        if docstring is None: return ''
        linker = self._HTMLDocstringLinker(self, container)
        return docstring.to_html(linker, indent=indent)

    #////////////////////////////////////////////////////////////
    # Standard fields
    #////////////////////////////////////////////////////////////

    def _standard_field_values(self, doc):
        """
        @return: A list of epytext field values that includes all
        fields that are common to all L{ObjDoc}s.
        C{_standard_field_values} is used by L{_extract_term_index}.
        @rtype: C{list} of L{markup.ParsedDocstring}
        """
        field_values = []
        for field in doc.fields():
            field_values += doc.field_values(field)
        return field_values

    def _standard_fields(self, doc):
        """
        @return: HTML code containing descriptions of the epytext
        fields that are common to all L{ObjDoc}s (except for C{descr}).
        @rtype: C{string}
        @param doc: The object whose fields should be described.
        """
        uid = doc.uid()
        if uid.is_module() or uid.is_class(): container = uid
        else: container = uid.cls() or uid.module()
        str = ''

        for field in doc.fields():
            values = doc.field_values(field)
            if not values: continue
            items = [self._docstring_to_html(v, container) for v in values]
            str += self._descrlist(items, field.singular,
                                   field.plural, field.short)

        return str
            
    def _descrlist(self, items, singular, plural=None, short=0):
        """
        @return: The HTML code for a list of description items.
        @param items: The description items.
        @type items: C{list} of C{string}
        @param singular: The name of the list, if there is one
            element. 
        @param plural: The name of the list, if there are multiple
            elements.  
        """
        if plural is None: plural = singular
        if len(items) == 0: return ''
        if len(items) == 1:
            return '<p><b>%s:</b> %s</p>\n\n' % (singular, items[0])
            #return '<p><b>%s:</b> %s<br /></p>\n\n' % (singular, items[0])
        if short:
            str = '<dl><dt><b>%s:</b></dt>\n  <dd>\n    ' % plural
            items = [item.strip() for item in items]
            return str + ',\n    '.join(items) + '\n  </dd>\n</dl>\n\n'
        else:
            str = '<p><b>%s:</b>\n<ul>\n  <li>' % plural
            return (str + '</li>\n  <li>'.join(items) +
                    '\n  </li>\n</ul></p>\n\n')
    
    #////////////////////////////////////////////////////////////
    # Helper functions
    #////////////////////////////////////////////////////////////

    def _is_private(self, str):
        """
        @return: true if C{str} is the name of a private Python object.
        @rtype: C{boolean}
        """
        if str == '...': return 0
        for piece in str.split('.'):
            if piece[:1] == '_' and piece[-1:] != '_': return 1
        return 0

    def _find_top_page(self, pagename):
        """
        Find the top page for the API documentation.  This page is
        used as the default page shown in the main frame, when frames
        are used.  When frames are not used, a redirect page is
        created from C{index.html} to the top page.

        @param pagename: The name of the page, as specified by the
            keyword argument C{top} to the constructor.
        @type pagename: C{string}
        @return: The URL of the top page.
        @rtype: C{string}
        """
        # If the top_page is unspecified, find an appropriate page.
        if not pagename:
            top = self._find_toplevel()
            if top: return self._uid_to_uri(top)
            else: return 'trees.html'

        # If it's a URL, then use it directly.
        if pagename.startswith('http:'):
            return pagename

        # Look for it in the docmap.
        for uid in self._docmap.keys():
            if pagename == uid.name():
                if uid.is_module() or uid.is_class():
                    return self._uid_to_uri(uid)
                else:
                    estr = ('Warning: Specified top page object %s' % uid
                            + ' is not a module\n         or a class.')
                    if sys.stderr.softspace: print >>sys.stderr
                    print >>sys.stderr, estr
                    return self._find_top_page(None)
                
        # Try importing it as a module.
        try:
            uid = make_uid(import_module(pagename))
            if self._docmap.has_key(uid):
                return self._uid_to_uri(uid)
            else:
                estr = ('Warning: Specified top page object %s' % uid
                        + ' is not documented.')
                if sys.stderr.softspace: print >>sys.stderr
                print >>sys.stderr, estr
                return self._find_top_page(None)
        except: pass

        # Is it a special page name?  Note that these could, in
        # principle, be shadowed by modules or classes named "html"
        # contained in packages named "index" etc.
        if pagename in ('indices.html', 'help.html',
                        'trees.html'):
            return pagename

        # We didn't find anything.
        estr = ('Warning: Unable to find the specified top_page %s.'
                % pagename)
        if sys.stderr.softspace: print >>sys.stderr
        print >>sys.stderr, estr
        return self._find_top_page(None)
    
    def _find_toplevel(self):
        """
        @return: The UID of the top-level module or package, or

            C{None} if there is no top-level module or package.
        @rtype: L{UID} or C{None}
        """
        modules = []
        packages = []
        for (uid, doc) in self._docmap.items():
            if not isinstance(doc, ModuleDoc): continue
            modules.append(uid)
            if doc.ispackage():
                packages.append(uid)

        # Is there a unique module?
        if len(packages) == 0 and len(modules) == 1:
            return modules[0]
        
        # Is there a unique (top-level) package?
        if len(packages) == 0: return None
        else:
            for pkg in packages:
                for pkg2 in packages:
                    if pkg is pkg2: continue
                    if not pkg2.descendant_of(pkg): break
                else: return pkg

        # There is no top-level object.
        return None

    def _cmp_name(self, name1, name2):
        """
        Compare uid1 and uid2 by their names, using the following rules: 
          - C{'__init__'} < anything.
          - public < private.
          - otherwise, sort alphabetically by name (ignoring case)
    
        @return: -1 if C{uid1<uid2}; 0 if C{uid1==uid2}; and 1 if
            C{uid1>uid2}.
        @rtype: C{int}
        """
        if (name2 == '__init__'): return 1
        if (name1 == '__init__'): return -1
        if name1 == name2: return 0
        if self._is_private(name1) and not self._is_private(name2): return 1
        if self._is_private(name2) and not self._is_private(name1): return -1
        return cmp(name1.lower(), name2.lower())

    def _filtersort_links(self, links, sortorder=None):
        """
        Sort and filter a list of C{Link}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param links: The list of C{Link}s to be sorted and filtered.
        @type links: C{list} of L{Link}
        @param sortorder: A list of link names, typically generated
            from C{__epydoc__sort__}, and returned by
            L{ObjDoc.sortorder}.  Links whose name are in C{sortorder}
            are placed at the beginning of the sorted list, in the
            order that they appear in C{sortorder}.
        @type sortorder: C{list} of C{string}
        @return: The sorted list of links.
        @rtype: C{list} of L{Link}
        """
        # Filter out private objects.
        if not self._show_private:
            links = [l for l in links if not l.target().is_private()]
        else:
            links = list(links)

        # Check the sortorder.  If available, then use it to sort the
        # objects.
        if (type(sortorder) not in (type(()), type([]))):
            so_links = []
        else:
            if type(sortorder) == type(()): sortorder = list(sortorder)
            so_links = sortorder[:]
            for link in links:
                try: so_links[sortorder.index(link.name())] = link 
                except ValueError: continue
            so_links = [l for l in so_links if type(l) != type('')]
            for link in so_links: links.remove(link)

        # Sort any links not contained in sortorder.
        links.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        
        return so_links + links

    def _filtersort_uids(self, uids):
        """
        Sort and filter a list of C{UID}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param uids: The list of C{UID}s to be sorted and filtered.
        @type uids: C{list} of L{UID}
        @return: The sorted list of UIDs.
        @rtype: C{list} of L{UID}
        """
        # Filter out private objects
        if not self._show_private:
            uids = [u for u in uids if not u.is_private()]

        # Sort and return the UIDs.
        uids.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        return uids

    def _filtersort_vars(self, vars, sortorder=None):
        """
        Sort and filter a list of C{Var}s.  If L{_show_private} is
        false, then filter out all private objects; otherwise, perform
        no filtering.

        @param vars: The list of C{Var}s to be sorted and filtered.
        @type vars: C{list} of L{Var}
        @param sortorder: A list of variable names, typically generated
            from C{__epydoc__sort__}, and returned by
            L{ObjDoc.sortorder}.  Vars whose name are in C{sortorder}
            are placed at the beginning of the sorted list, in the
            order that they appear in C{sortorder}.
        @type sortorder: C{list} of C{string}
        @return: The sorted list of variables.
        @rtype: C{list} of L{Var}
        """
        # Filter out private objects.
        if not self._show_private:
            vars = [v for v in vars if not v.uid().is_private()]
        else:
            vars = list(vars)

        # Check the sortorder.  If available, then use it to sort the
        # objects.
        if (type(sortorder) not in (type(()), type([]))):
            so_vars = []
        else:
            if type(sortorder) == type(()): sortorder = list(sortorder)
            so_vars = sortorder[:]
            for var in vars:
                try: so_vars[sortorder.index(var.name())] = var
                except ValueError: continue
            so_vars = [v for v in so_vars if type(v) != type('')]
            for var in so_vars: vars.remove(var)

        # Sort any variables not contained in sortorder.
        vars.sort(lambda x,y,c=self._cmp_name: c(x.name(), y.name()))
        
        return so_vars + vars
        
    def _header(self, name):
        """
        @return: The HTML code for the header of a page with the given
            name.
        @rtype: C{string}
        """
        return HEADER % name
               
    def _footer(self):
        """
        @return: The HTML code for the footer of a page.
        @rtype: C{string}
        """
        timestamp = time.asctime(time.localtime(time.time()))
        return FOOTER % (epydoc.__version__, timestamp)

    def _summary(self, doc, container):
        """
        @return: The HTML code for the summary description of the
            object documented by C{doc}.  A summary description is the
            first sentence of the C{doc}'s 'description' field.  If the
            C{doc} has no 'description' field, but does have a
            'return' field, then the summary is taken from the return
            field instead.
        @rtype: C{string}
        @param doc: The documentation for the object whose summary
            should be returned.
        @type doc: L{objdoc.ObjDoc}
        @param container: The container object for C{doc}, or C{None}
            if there is none.  This container object is used to
            resolve links (E{L}{...}) in the epytext.
        @type container: L{uid.UID}
        """
        # Try to find a documented ancestor
        if isinstance(doc, FuncDoc):
            while (not doc.documented() and doc.matches_override() and
                   self._docmap.has_key(doc.overrides())):
                doc = self._docmap[doc.overrides()]
                
        summary = self._docstring_to_html(doc.summary(), container).strip()
        if not summary:
            if (isinstance(doc, FuncDoc) and
                doc.returns().descr() is not None):
                summary = doc.returns().descr().summary()
                summary = self._docstring_to_html(summary, container).strip()
                return 'Return '+summary[:1].lower() + summary[1:]
            else:
                return '&nbsp;'
        return summary or '&nbsp;'

    def _imports(self, classes, excepts, functions, variables, sortorder):
        if not self._show_imports: return ''
        class_items = [self._link_to_html(c)
                       for c in self._filtersort_links(classes, sortorder)]
        except_items = [self._link_to_html(e)
                        for e in self._filtersort_links(excepts, sortorder)]
        func_items = [self._link_to_html(f)
                      for f in self._filtersort_links(functions, sortorder)]
        var_items = ['<code>%s</code>' % v.name()
                     for v in self._filtersort_vars(variables, sortorder)]
        if not (class_items or except_items or func_items):
            return ''
        str = self._start_of('Imports')+'<dl>\n'
        if len(class_items) > 0:
            str += '  <dt><b>Imported classes:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(class_items) + '\n  </dd>\n'
        if len(except_items) > 0:
            str += '  <dt><b>Imported exceptions:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(except_items) + '\n  </dd>\n'
        if len(func_items) > 0:
            str += '  <dt><b>Imported functions:</b></dt>\n  <dd>\n    '
            str += ',\n    '.join(func_items) + '\n  </dd>\n'
        if len(var_items) > 0:
            str += '  <dt><b>Imported variables:</b></dt>\n <dd>\n    '
            str += ',\n    '.join(var_items) + '\n  </dd>\n'
        return str + '</dl>\n\n'
                                
    def _link_to_html(self, link):
        """
        @return: The HTML code for the given link.  This code consists
            of an anchor with an href to the page for the link's
            target, and with text taken from the link's name. If the
            target is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type link: L{uid.Link}
        """
        return self._uid_to_href(link.target(), link.name())

    def _uid_to_uri(self, uid):
        """
        @return: a URI that points to the description of the object
            identified by C{uid}.
        @rtype: C{string}
        @param uid: A unique identifier for the object.
        @type uid: L{UID}
        """
        if uid.is_module():
            return '%s-module.html' % uid.name()
        elif uid.is_class():
            return '%s-class.html' % uid.name()
        else:
            parent = uid.parent()
            if parent is None:
                return '%s-unknown.html' % uid.name() # Error
            elif parent.is_module():
                return '%s-module.html#%s' % (parent.name(), uid.shortname())
            elif parent.is_class():
                return '%s-class.html#%s' % (parent.name(), uid.shortname())
            else:
                return '%s-unknown.html' % uid.name() # Error
            
    def _documented(self, uid):
        """
        @return: True if the given UID is documented by the
            documentation map for this C{HTMLFormatter}.  If C{uid} is the
            UID for a private object, and C{_show_private=0}, then
            this method will also return false.
        @rtype: C{boolean}
        """
        # Does it have a UID?
        if uid is None:
            return 0

        # Is it private, if we're not showing private?
        if (not self._show_private) and uid.is_private():
            return 0

        # Is it a variable or routine whose parent is not documented?
        if ((uid.is_routine() or uid.is_variable()) and
            (not self._docmap.has_key(uid.parent()))):
            return 0

        # Is it a non-variable that's not documented? (variables are
        # not included in the docmap)
        if (not uid.is_variable() and not self._docmap.has_key(uid)):
            return 0

        # Otherwise, it must be documented.
        return 1
    
    def _uid_to_href(self, uid, label=None, css_class=None, code=1):
        """
        @return: The HTML code to link to the given UID.  This code
            consists of an anchor with an href to the page for C{uid}.
            If C{label} is not C{None}, then it is used as the text
            for the link; otherwise, C{uid} is used as the text.  If
            C{uid} is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type uid: L{uid.UID}
        @type label: C{string}
        @param code: Whether or not to include C{<code>...</code>}
            tags around the label.
        """
        # We shouldn't need this, but include it just in case.
        if uid is None and label is None:
            return '<code>??</code>'
        
        # Find a default value for the label.
        if label is None: label = uid.name()

        if not self._documented(uid):
            if code: return '<code>%s</code>' % label
            else: return '%s' % label

        # Construct an href, using uid_to_uri.
        if css_class and code:
            return ('<a href="%s" class="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif css_class:
            return ('<a href="%s" class="%s">%s</a>' %
                    (self._uid_to_uri(uid), css_class, label))
        elif code:
            return ('<a href="%s"><code>%s</code></a>' %
                    (self._uid_to_uri(uid), label))
        else:
            return ('<a href="%s">%s</a>' %
                    (self._uid_to_uri(uid), label))

    def _start_of(self, heading):
        """
        @return: The HTML code for a 'start-of' comment.  These
            comments are used to deliniate sections of the HTML
            output.
        @rtype: C{string}
        @param heading: The name of the section that is starting.
        @type heading: C{string}
        """
        return '\n<!-- =========== START OF '+heading.upper()+\
               ' =========== -->\n'
    
    def _group_header(self, group):
        group = re.sub('&', '&amp;', group)
        group = re.sub('<', '&lt;', group)
        return '<tr bgcolor="#e8f0f8" class="group">\n'+\
               '  <th colspan="2">' + '&nbsp;'*4 + group + '</th></tr>\n'
    
    def _table_header(self, heading, css_class):
        """
        @return: The HTML code for the start of a table.  This is used
            by class tables, function tables, variable tables, etc.
        @rtype: C{string}
        @param heading: The name for the table.
        @type heading: C{string}
        @param css_class: The css class for the table.  This is used
            to allow different tables to be given different styles.
            Currently, the following classes are used: C{'summary'};
            C{'details'}; and C{'index'}.
        """
        return self._start_of(heading)+\
               '<table class="'+css_class+'" border="1" cellpadding="3"' +\
               ' cellspacing="0" width="100%" bgcolor="white">\n' +\
               '<tr bgcolor="#70b0f0" class="'+css_class+'">\n'+\
               '  <th colspan="2">' + heading + '</th></tr>\n'
    
    def _split_classes(self, classes_and_excepts):
        """
        Divide the classes fromt the given module into exceptions and
        non-exceptions.  This is used by L{_module_to_html} to list
        exceptions and non-exceptions separately.

        @param classes_and_excepts: The list of classes to split up.
        @type classes_and_excepts: C{list} of L{uid.Link}
        @return: A list C{(I{classes}, I{excepts})}, where
            C{I{classes}} is the list of non-exception classes, and
            C{I{excepts}} is the list of exception classes.
        @rtype: C{pair} of C{list} of L{uid.Link}
        """
        classes = []
        excepts = []
        for link in classes_and_excepts:
            try:
                if (self._docmap.has_key(link.target()) and
                    self._docmap[link.target()].is_exception()):
                    excepts.append(link)
                else:
                    classes.append(link)
            except:
                classes.append(link)
        return (classes, excepts)
        
    def _inheritance_list(self, links, cls):
        """
        @return: A string containing HTML that lists all objects from
            that were inherited from a base ancestor of C{cls}.
            Only the objects linked to from one of the links in
            C{links} are considered.  The HTML lists the objects in
            one row of a table, grouped by ancestor.
        @type links: C{list} of L{Link}
        @param links: The set of member objects of C{cls}
            that should be listed by ancestor.
        @type cls: L{UID}
        @param cls: The UID of the class whose inherited objects
            should be listed.
        """
        # Group the objects by defining class
        inh_dict = {}
        for link in links:
            if isinstance(link, Link): key = link.target().cls()
            else: key = link.uid().cls()
            if key == cls: continue
            if key is None: continue
            if not inh_dict.has_key(key): inh_dict[key] = []
            inh_dict[key].append(link)

        if not inh_dict: return ''
        
        str = '  <tr><td colspan="2">\n'
        inh_items = inh_dict.items()
        inh_items.sort(lambda a,b: cmp(a[0], b[0]))
        for (base, obj_links) in inh_items:
            str += '    <b>Inherited from %s:</b>\n' % base.shortname()
            for link in obj_links:
                str += '      '
                if isinstance(link, Link): str += self._link_to_html(link)
                else: str += self._uid_to_href(link.uid(), link.name())
                str += ',\n'
            str = str[:-2] + '\n      <br />\n'
        return str[:-13] + '\n    </td></tr>\n'

