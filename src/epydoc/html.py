#
# epydoc.html: epydoc HTML output generator
# Edward Loper
#
# Created [01/30/01 05:18 PM]
# $Id$
#

"""
Documentation to HTML converter.
"""

# Improvements I'd like to make:
#    - Better CSS support
#    - List exceptions separately from other classes


##################################################
## Constants
##################################################

WARN_MISSING = 0

HELP = '''
    <h2> Help </h2>

    <p> (No help available) </p>
'''

# Expects: (name, css)
HEADER = '''
<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title> %s</title>
    <link rel="stylesheet" href="%s" type="text/css"></link>
  </head>
  <body bgcolor="white" text="black" link="blue" vlink="#204080"
        alink="#204080">
'''
# Expects: date
FOOTER = '''
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left"><font size="-2">Generated by Epydoc on %s</font></td>
    <td align="right"><a href="http://epydoc.sf.net"
                      ><font size="-2">http://epydoc.sf.net</font></a></td>
  </tr>
</table>
</body>
</html>'''

# Names for the __special__ methods.
SPECIAL_METHODS ={
    '__init__': 'Constructor',
    '__del__': 'Destructor',
    '__add__': 'Addition operator',
    '__sub__': 'Subtraction operator',
    '__and__': 'And operator',
    '__or__': 'Or operator',
    '__repr__': 'Representation operator',
    '__call__': 'Call operator',
    '__getattr__': 'Qualification operator',
    '__getitem__': 'Indexing operator',
    '__setitem__': 'Index assignment operator',
    '__delitem__': 'Index deletion operator',
    '__delslice__': 'Slice deletion operator',
    '__setslice__': 'Slice assignment operator',
    '__getslice__': 'Slicling operator',
    '__len__': 'Length operator',
    '__cmp__': 'Comparison operator',
    '__eq__': 'Equality operator',
    '__in__': 'Containership operator',
    '__gt__': 'Greater-than operator',
    '__lt__': 'Less-than operator',
    '__ge__': 'Greater-than-or-equals operator',
    '__le__': 'Less-than-or-equals operator',
    '__radd__': 'Right-side addition operator',
    '__hash__': 'Hashing function',
    '__contains__': 'In operator',
    '__str__': 'Informal representation operator',
    }

##################################################
## Imports
##################################################

# system imports
import re, sys, os.path, string, time
from xml.dom.minidom import Text as _Text

# epydoc imports
import epydoc.epytext as epytext
from epydoc.uid import UID, Link, findUID
from epydoc.objdoc import Documentation, ModuleDoc, FuncDoc
from epydoc.objdoc import ClassDoc, Var, Raise, ObjDoc
import epydoc.css

##################################################
## Helper functions.
##################################################

def _is_private(str):
    """
    @return: true if C{str} is the name of a private Python object.
    @rtype: C{boolean}
    """
    str = string.split(str, '.')[-1]
    return (str and str[0]=='_' and str[-1]!='_')

def _cmp_name(uid1, uid2):
    """
    Compare uid1 and uid2 by their names, using the following rules: 
      - C{'__init__'} < anything.
      - public < private.
      - otherwise, sort alphabetically by name.

    @return: -1 if C{uid1<uid2}; 0 if C{uid1==uid2}; and 1 if
        C{uid1>uid2}.
    @rtype: C{int}
    """
    x = uid1.name()
    y = uid2.name()
    if (y == '__init__'): return 1
    if (x == '__init__'): return -1
    if x == y: return 0
    if _is_private(x) and not _is_private(y): return 1
    if _is_private(y) and not _is_private(x): return -1
    return cmp(x, y)

def _uid_to_uri(uid):
    """
    @return: a URI that points to the description of the object
        identified by C{uid}.
    @rtype: C{string}
    @param uid: A unique identifier for the object.
    @type uid: L{UID}
    """
    if uid.is_function():
        return '%s.html#%s' % (uid.module(), uid.shortname())
    elif uid.is_method():
        return '%s.html#%s' % (uid.cls(), uid.shortname())
    else:
        return '%s.html' % uid

##################################################
## Docstring -> HTML Conversion
##################################################

def index_to_anchor(str):
    """
    Given the name of an inline index item, construct a URI anchor.
    These anchors are used to create links from the index page to each
    index item.
    """
    return "_index_"+re.sub("[^a-zA-Z0-9]", "_", str)

# Use a cache to avoid converting epytext->HTML repeatedly (e.g., when
# creating the versions of pages that do and don't include private
# objects).  
_dom_to_html_cache = {}

def dom_to_html(tree, container=None, **kwargs):
    """
    Given the DOM tree for an epytext string (as returned by
    L{epytext.parse}), return a string encoding it in HTML.  This
    string does not include C{<html>} or C{<body>} tags.

    To do:
      - honor ordered list bullets
      - implement more advanced uri links

    @param tree: The DOM tree for an epytext string.
    @type tree: C{xml.dom.minidom.Element}
    @param container: The container in which to look up objects by name
        (e.g., for link directives).
    @type container: Python module
    @param kwargs: Keyword arguments.
        - para = whether to keep 'extra' para tags.  These 'extra' 
          para tags can cause extra unwanted space on some browsers
          (e.g., between list items).
          Default: C{false} (i.e., don't keep them).
    """
    global _dom_to_html_cache
    if not _dom_to_html_cache.has_key( (tree,container) ):
        html = _dom_to_html(tree, container, 0, 0, **kwargs)
        _dom_to_html_cache[tree, container] = html
    return _dom_to_html_cache[tree,container]

def _dom_to_html(tree, container, indent, seclevel, **kwargs):
    """
    Helper function for L{dom_to_html}, that does the real work of
    converting a DOM tree for an epytext string to HTML.

    @param tree: The DOM tree for an epytext string.
    @type tree: C{xml.dom.minidom.Element}
    @param container: The container in which to look up objects by name
        (e.g., for link directives).
    @type container: Python module
    @param indent: The number of characters indentation that should be
        used for HTML tags.
    @type indent: C{int}
    @param seclevel: The current section level.
    @type seclevel: int
    @param kwargs: Keyword arguments (see L{dom_to_html} for
        details). 
    """
    # This takes care of converting > to &gt;, etc.:
    if isinstance(tree, _Text): return tree.toxml()

    if tree.tagName == 'epytext': indent -= 2
    if tree.tagName == 'section': seclevel += 1

    # Process the children first.
    children = [_dom_to_html(c, container, indent+2, seclevel, **kwargs) 
                for c in tree.childNodes]

    # Get rid of unnecessary <P>...</P> tags; they introduce extra
    # space on most browsers that we don't want.
    if kwargs.get('para', 0) == 0:
        for i in range(len(children)-1):
            if (not isinstance(tree.childNodes[i], _Text) and
                tree.childNodes[i].tagName == 'para' and
                (isinstance(tree.childNodes[i+1], _Text) or
                 tree.childNodes[i+1].tagName != 'para')):
                children[i] = children[i][5+indent:-5]
        if (tree.hasChildNodes() and
            not isinstance(tree.childNodes[-1], _Text) and
            tree.childNodes[-1].tagName == 'para'):
            children[-1] = children[-1][5+indent:-5]

    # Construct the HTML string for the children.
    childstr = ''.join(children)

    # Perform the approriate action for the DOM tree type.
    if tree.tagName == 'para':
        return epytext.wordwrap('<p>%s</p>' % childstr, indent)
    elif tree.tagName == 'code':
        return '<code>%s</code>' % childstr
    elif tree.tagName == 'uri':
        if re.match('\w+:.+', childstr): uri = childstr
        else: uri = 'http://'+childstr
        return '<a href="%s">%s</a>' % (uri, childstr)
    elif tree.tagName == 'link':
        childstr = re.sub('[^a-zA-Z0-9.]', '_', childstr)
        uid = findUID(childstr, container)
        if uid is not None:
            return ('<a href="%s">' % _uid_to_uri(uid) +
                    '<code class="link">%s</code></a>' % childstr)
        else:
            print ('Warning: could not find UID for %r in %r' %
                   (childstr, container))
            return '<code class="link">%s</code>' % childstr
    elif tree.tagName == 'italic':
        return '<i>%s</i>' % childstr
    elif tree.tagName == 'math':
        return '<i class="math">%s</i>' % childstr
    elif tree.tagName == 'index':
        return ('<a name="%s"></a>' % index_to_anchor(childstr) +
                '<i class="indexterm">%s</i>' % childstr)
    elif tree.tagName == 'bold':
        return '<b>%s</b>' % childstr
    elif tree.tagName == 'ulist':
        return indent*' '+'<ul>\n%s%s</ul>\n' % (childstr, indent*' ')
    elif tree.tagName == 'olist':
        return indent*' '+'<ol>\n%s%s</ol>\n' % (childstr, indent*' ')
    elif tree.tagName == 'li':
        return indent*' '+'<li>\n%s%s</li>\n' % (childstr, indent*' ')
    elif tree.tagName == 'heading':
        return ('%s<h%s class="heading">%s</h%s>\n' %
                ((indent-2)*' ', seclevel, childstr, seclevel))
    elif tree.tagName == 'literalblock':
        return '<pre class="literalblock">\n%s\n</pre>\n' % childstr
    elif tree.tagName == 'doctestblock':
        childstr = _colorize_doctestblock(childstr)
        return '<pre class="doctestblock">\n%s\n</pre>\n' % childstr
    elif tree.tagName == 'fieldlist':
        raise AssertionError("There should not be any field lists left")
    elif tree.tagName in ('epytext', 'section', 'tag', 'arg'):
        return childstr
    else:
        raise NotImplementedError, tree.tagName

def _colorize_doctestblock(str):
    """
    Do some colorization for a doctest block (minor for now).

    @type str: C{string}
    @param str: The contents of the doctest block to be colorized.
    @rtype: C{string}
    @return: The colorized doctest block.
    """
    regexp = re.compile(r'^(\s*)(&gt;&gt;&gt;|\.\.\.)(\s*)(.*)$',
                        re.MULTILINE)
    return regexp.sub(r'\1<span class="pyprompt">\2</span>\3'+
                      r'<span class="pycode">\4</span>', str)

##################################################
## Documentation -> HTML Conversion
##################################################
# Index of HTML_Doc:
#   - Constructor
#   - Write
#   - HTML page generation
#   - Navigation bar
#   - Base class trees
#   - Class hierarchy trees
#   - Module hierarchy trees
#   - Class tables
#   - Function tables
#   - Variable tables
#   - Index generation
#   - Helper functions



class HTML_Doc:
    """
    Documentation to HTML converter.

    For each module/package, create a file containing:
      - Navbar
      - Module Name
      - Description
      - See-also
      - Module list
      - Class summary
      - Function summary
      - Variable summary
      - Function details
      - Variable details
      - Navbar

    For each class, create a file containing:
      - Navbar
      - Module name
      - Class Name
      - Base tree
      - Known subclasses
      - Description
      - See-also
      - Method summary
      - Instance Variable summary
      - Class Variable summary
      - Method details
      - Instance Variable details
      - Class Variable details
      - Navbar

    Also, generate an index file, a help file, and a tree file.

    @type docmap: L{Documentation}
    @ivar docmap: The documentation object, encoding the objects that
        should be documented.
    @type _pkg_name: C{string}
    @ivar _pkg_name: A name for the documentation (for the navbar).
    @type _pkg_url: C{string}
    @ivar _pkg_url: A URL for the documentation (for the navpar).
    
    @ivar _module: The UID of the top-level module, if there is one.
        If there is more than one top-level module, then C{_module} is
        C{'multiple'}; if there is no top-level module, then
        C{_module} is C{None}.
    @ivar _package: The UID of the top-level package, if there is one.
        If there is more than one top-level package, then C{_package} is
        C{'multiple'}; if there is no top-level package, then
        C{_package} is C{None}.
    @ivar _show_private: Whether we are currently writing files that
        show private objects.
    @ivar _css: The name of a file containing a CSS stylesheet; or the
        name of a CSS stylesheet.
    @ivar _cssfile: The name of the CSS stylesheet file.  This should be
        C{'epydoc.css'} when C{_show_private==0} and C{'../epydoc.css'}
        when C{_show_private==1}.
    """

    #////////////////////////////////////////////////////////////
    # Constructor
    #////////////////////////////////////////////////////////////
    
    def __init__(self, docmap, **kwargs):
        """
        Construct a new HTML outputter, using the given
        L{Documentation} object.
        
        @param docmap: The documentation to output.
        @type docmap: L{objdoc.Documentation}
        @param kwargs: Keyword arguments:
            - C{pkg_name}: A name for the documentation (for the
              navbar).  This name can contain arbitrary HTML code
              (e.g., images or tables). (type=C{string})
            - C{pkg_url}: A URL for the documentation (for the
              navbar).  (type=C{string})
            - C{css}: The CSS stylesheet file.  If C{css} is a file,
              then its conents will be used.  Otherwise, if C{css} is
              the name of a CSS stylesheet in L{epydoc.css}, then that
              stylesheet will be used.  Otherwise, an error is
              reported. 
        """
        self._docmap = docmap

        # Process keyword arguments.
        self._pkg_name = kwargs.get('pkg_name', '')
        self._pkg_url = kwargs.get('pkg_url', None)
        self._css = kwargs.get('css')

        # Find the top-level object (if any)
        self._find_toplevel()

    #////////////////////////////////////////////////////////////
    # Write (and its helpers)
    #////////////////////////////////////////////////////////////
    
    def write(self, directory=None, verbose=1):
        """
        Write the documentation to the given directory.

        @type directory: C{string}
        @param directory: The directory to which output should be
            written.  If no directory is specified, output will be
            written to the current directory.  If the directory does
            not exist, it will be created.
        @type verbose: C{int}
        @param verbose: The level of verbosity output when writing the
            documentation.  A verbosity of zero will only generate
            output on errors.  A verbosity of one will output a single
            period for each file written.  Higher values give more
            verbose output.
        """
        if directory in ('', None): directory = './'
        if directory[-1] != '/': directory = directory + '/'
        self._show_private = 0
        
        # Write the CSS file.
        self._cssfile = 'epydoc.css'
        self._write_css(directory)
        
        # Write the tree file (package & class hierarchies)
        str = self._tree_to_html()
        open(directory+'epydoc-tree.html', 'w').write(str)

        # Write the index file.
        str = self._index_to_html()
        open(directory+'epydoc-index.html', 'w').write(str)

        # Write the help file.
        self._write_help(directory)

        # Write the private & public versions of the docs.
        self._show_private = 0
        self._write_docs(directory, verbose)
        self._show_private = 1
        self._cssfile = '../epydoc.css'
        self._write_docs(os.path.join(directory, 'private/'), verbose)

    def _write_css(self, directory):
        """
        Write the CSS stylesheet for the documentation.  If a
        stylesheet file or name (from L{epydoc.css}) is specified,
        then use that stylesheet; otherwise, if a stylesheet file
        already exists, use that stylesheet.  Otherwise, use the
        default stylesheet.

        @rtype: C{None}
        """
        filename = os.path.join(directory, 'epydoc.css')
        
        # Get the contents for the stylesheet file.  If none was
        # specified, and a stylesheet is already present, then don't
        # do anything.
        if self._css is None:
            if os.path.exists(filename):
                return
            else: css = epydoc.css.STYLESHEETS['default']
        else:
            if os.path.exists(self._css):
                css = open(self._css).read()
            elif epydoc.css.STYLESHEETS.has_key(self._css):
                css = epydoc.css.STYLESHEETS[self._css]
            else:
                raise IOError("Can't find CSS file: %r" % self._css)

        # Write the stylesheet.
        cssfile = open(filename, 'w')
        cssfile.write(css)
        cssfile.close()

    def _write_help(self, directory):
        """
        Write a default help file for the documentation, unless a
        help file is already present.

        @rtype: C{None}
        """
        filename = os.path.join(directory, 'epydoc-help.html')
        if os.path.exists(filename): return
        helpfile = open(filename, 'w')
        navbar = self._navbar('help')
        helpfile.write(self._header('Help')+navbar+HELP+navbar+self._footer())
        helpfile.close()
        
    def _write_docs(self, directory, verbose):
        """
        A helper for L{write} that does the work of writing the
        documentation to the given directory.
        
        @param directory: Testing L{_find_toplevel}.
        """
        # Create dest directory, if necessary
        if not os.path.isdir(directory):
            if os.path.exists(directory):
                raise ValueError('%r is not a directory' % directory)
            os.mkdir(directory)

        for (n, d) in self._docmap.items():
            if isinstance(d, ModuleDoc):
                if verbose==1:
                    sys.stdout.write('.')
                    sys.stdout.flush()
                elif verbose>1: print 'Writing docs for module: ', n
                str = self._module_to_html(n)
                open(directory+`n`+'.html', 'w').write(str)
            elif isinstance(d, ClassDoc):
                if verbose==1:
                    sys.stdout.write('.')
                    sys.stdout.flush()
                elif verbose>1: print 'Writing docs for class:  ', n
                str = self._class_to_html(n)
                open(directory+`n`+'.html', 'w').write(str)

    #////////////////////////////////////////////////////////////
    # HTML page generation
    #////////////////////////////////////////////////////////////
    # Each of these functions creates a single HTML file, and returns
    # it as a string.
    
    def _module_to_html(self, uid):
        """
        @return: An HTML page describing the module identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the module that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation.
        doc = self._docmap[uid]

        # Check if it's a package or a module.
        if uid.is_package(): moduletype = 'package'
        else: moduletype = 'module'

        # Write the header & navigation bar.
        str = self._header(`uid`)
        str += self._navbar(moduletype, uid)
        str += self._public_private_link(uid)

        # Write the module's name.
        if moduletype == 'package':
            str += self._start_of('Package Description')
            str += '<h2>Package '+uid.name()+'</h2>\n\n'
        else:
            str += self._start_of('Module Description')
            str += '<h2>Module '+uid.name()+'</h2>\n\n'

        # Write the module's description.
        if doc.descr():
            str += dom_to_html(doc.descr(), uid) + '<hr/>\n'

        # Add any see-also links.
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # If it's a package, add a list of sub-modules.
        if doc.ispackage():
            str += self._module_list(doc.modules(), doc.sort_order())

        # Show the summaries for classes, exceptions, functions, and
        # variables contained in the module.
        (classes,excepts) = self._split_classes_and_excepts(doc)
        str += self._class_summary(classes, doc.sort_order(), 'Classes')
        str += self._class_summary(excepts, doc.sort_order(), 'Exceptions')
        str += self._func_summary(doc.functions(), doc.sort_order())
        str += self._var_summary(doc.variables(), doc.sort_order(), uid)

        # Show details for the functions and variables.
        str += self._func_details(doc.functions(), None)
        str += self._var_details(doc.variables(), uid)

        # Add another navigation bar and the footer.
        str += self._navbar(moduletype, uid) + self._footer()
        
        return str

    def _class_to_html(self, uid):
        """
        @return: An HTML page describing the class identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the class that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation
        doc = self._docmap[uid]
        
        # Write the header & navigation bar.
        str = self._header(`uid`)
        str += self._navbar('class', uid)
        str += self._public_private_link(uid)

        # Write the class's module and its name.
        str += self._start_of('Class Description')
        str += '<h2><font size="-1">\n'+uid.module().name()+'</font><br>\n' 
        str += 'Class ' + `uid`+'</h2>\n\n'

        # Write the base class tree
        if doc.bases():
            str += '<pre class="base-tree">\n' 
            str += self._base_tree(uid) 
            str += '</pre><br>\n\n'

        # Write the class's known subclasses
        if doc.children():
            str += '<dl><dt><b>Known Subclasses:</b></dt>\n<dd>'
            for cls in doc.children():
                str += '    '+self._link_to_html(cls) + ',\n'
            str = str[:-2] + '</dd></dl>\n\n'

        # Write the class's description
        if doc.descr():
            str += '<hr/>\n' + dom_to_html(doc.descr(), uid)
            str += '\n\n'
        str += '<hr/>\n\n'

        # Add any see-also links
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # Show the summaries for methods, instance variables, and
        # class variables contained in the class.
        str += self._func_summary(doc.methods(), doc.sort_order(),
                                  'Method Summary')
        str += self._var_summary(doc.ivariables(), doc.sort_order(),
                                 uid, 'Instance Variable Summary')
        str += self._var_summary(doc.cvariables(), doc.sort_order(),
                                 uid, 'Class Variable Summary')

        # Show details for methods and variables
        str += self._func_details(doc.methods(), doc, 
                                  'Method Details')
        str += self._var_details(doc.ivariables(), uid,
                                 'Instance Variable Details')
        str += self._var_details(doc.cvariables(), uid,
                                 'Class Variable Details')

        # Add a navigation bar and the footer.
        str += self._navbar('class', uid) + self._footer()
        
        return str

    def _tree_to_html(self):
        """
        @return: An HTML page containing the module and class
            hierarchies. 
        @rtype: C{string}
        """
        # Header and navigation bar
        str = self._header('Module and Class Hierarchies')
        str += self._navbar('tree')

        # Module hierarchy
        str += self._start_of('Module Hierarchy')
        str += '<h2>Module Hierarchy</h2>\n'
        str += self._module_tree()

        # Class hierarchy
        str += self._start_of('Class Hierarchy')
        str += '<h2>Class Hierarchy</h2>\n'
        str += self._class_tree()

        # Navigation bar and footer
        str += self._navbar('tree')
        str += self._footer()
        return str

    def _index_to_html(self):
        """
        @return: An HTML page containing the index terms.
        @rtype: C{string}
        """
        # Header and navigation bar.
        str = self._header('Index')
        str += self._navbar('index') + '<br>\n'

        # Index table.
        str += self._start_of('Index')
        str += self._table_header('Index', 'index')
        index = self._extract_index().items()
        index.sort()
        for (term, sources) in index:
            str += '  <tr><td width="10%">'+term+'</td>\n    <td>'
            sources.sort()
            for source in sources:
                target = source+'.html#'+epytext.index_to_anchor(term)
                str += '<i><a href="' + target + '">'
                str += source + '</a></i>, '
            str = str[:-2] + '</tr></td>\n'
        str += '</table>\n' +  '<br>\n'

        # Navigation bar and footer.
        str += self._navbar('index')
        str += self._footer()
        return str
    
    #////////////////////////////////////////////////////////////
    # Navigation bar
    #////////////////////////////////////////////////////////////
    # The navigation bar is placed at the top & bottom of every HTML
    # page. 
    
    def _navbar(self, where, uid=None):
        """
        @return: The HTML code for a navigation bar on the given type
            of page.
        @rtype: C{string}
        @param where: The type of page for which a navigation bar
            should be generated.  Possible values are C{'class'},
            C{'module'}, C{'package'}, C{'tree'}, C{'index'}, and
            C{'help'}.
        @type where: C{string}
        """
        str = self._start_of('Navbar')
        str += '<table class="navbar" border="0" width="100%"'
        str += ' cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">\n'
        str += '  <tr>\n'
        str += '    <td width="100%">\n'
        str += '      <table border="0" cellpadding="0" cellspacing="0">\n'
        str += '        <tr valign="top">\n'

        I = '          ' # indentation
        
        # The "Go to Package" link
        if self._package is None: pass
        elif where in ('class', 'module'):
            pkg = uid.package()
            if pkg is not None:
                str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
                str += '<a class="navbar" href="'+`pkg`+'.html">'
                str += 'Package</a>&nbsp;&nbsp;&nbsp;</th>\n'
            else:
                str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
                str += 'Package&nbsp;&nbsp;&nbsp;</th>\n'
        elif where=='package':
            str += I+'<th bgcolor="#70b0f0" class="navselect">'
            str += '&nbsp;&nbsp;&nbsp;'
            str += 'Package&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(self._package, UID):
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'+`self._package`+'.html">'
            str += 'Package</a>&nbsp;&nbsp;&nbsp;</th>\n'
        elif 'multiple' == self._package:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += 'Package&nbsp;&nbsp;&nbsp;</th></b>\n'
        
        # The "Go to Module" link
        if self._module is None: pass
        elif where=='class':
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'+`uid.module()`+'.html">'
            str += 'Module</a>&nbsp;&nbsp;&nbsp;</th>\n'
        elif where=='module':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;' 
            str += '&nbsp;&nbsp;Module&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(self._module, UID):
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'+`self._module`+'.html">'
            str += 'Module</a>&nbsp;&nbsp;&nbsp;</th>\n'
        elif 'multiple' == self._module:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += 'Module&nbsp;&nbsp;&nbsp;</th>\n'
        
        # The "Go to Class" link
        if where == 'class':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Class&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;Class' 
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Tree" link
        if where == 'tree':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Trees&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'
            if self._show_private: str += '../'
            str += 'epydoc-tree.html">Trees</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Index" link
        if where == 'index':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'
            if self._show_private: str += '../'
            str += 'epydoc-index.html">Index</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Help" link
        if where == 'help':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Help&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'
            if self._show_private: str += '../'
            str += 'epydoc-help.html">Help</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        str += '        </tr>\n      </table>\n    </td>\n'
        str += '    <td>\n'
        str += '      <table border="0" cellpadding="0" cellspacing="0">\n'
        str += '        <tr valign="top">\n'
        str += '          <th class="navbar">'
        if self._pkg_name:
            if self._pkg_url:
                str += ('<a class="navbar" href="%s">%s</a>' %
                          (self._pkg_url, self._pkg_name))
            else:
                str += I+self._pkg_name

        str += '</th>\n        </tr>\n'
        str += '      </table>\n    </td>\n  </tr>\n</table>\n'
        return str

    def _public_private_link(self, uid):
        """
        @return: The HTML code for a link between the public & private
            copies of the documentation.
        @rtype: C{string}
        """
        if self._show_private and _is_private(uid.name()):
            return ''

        str = '<table width="100%"><tr>\n  <td width="100%"></td>\n'
        if self._show_private:
            str += '  <td><font size="-2">[show&nbsp;private&nbsp;|'
            str += '&nbsp;<a href="../' + _uid_to_uri(uid)
            str += '">hide&nbsp;private</a>]</font></td>\n'
        else:
            str += '  <td><font size="-2">[<a href="private/'
            str += _uid_to_uri(uid) + '">show&nbsp;private</a>'
            str += '&nbsp;|&nbsp;hide&nbsp;private]</font></td>\n'
        return str + '</tr></table>\n'
    
    #////////////////////////////////////////////////////////////
    # Base class trees
    #////////////////////////////////////////////////////////////
    
    def _find_tree_width(self, uid):
        """
        @return: The width of a base tree, when drawn
            right-justified.  This is used by L{_base_tree} to
            determine how far to indent lines of the base tree.
        @rtype: C{int}
        """
        width = 2
        if self._docmap.has_key(uid):
            for base in self._docmap[uid].bases():
                width = max(width, len(base.name())+4)
                width = max(width, self._find_tree_width(base.target())+4)

        return width
        
    def _base_tree(self, uid, width=None, postfix=''):
        """
        @return: The HTML code for a class's base tree.  The tree is
            drawn 'upside-down' and right justified, to allow for
            multiple inheritence.
        @rtype: C{string}
        """
        if not self._docmap.has_key(uid): return ''
        if width == None:
            width = self._find_tree_width(uid)
        
        bases = self._docmap[uid].bases()
        
        if postfix == '':
            str = ' '*(width-2) + '<b>'+uid.shortname()+'</b>\n'
        else: str = ''
        for i in range(len(bases)-1, -1, -1):
            base = bases[i]
            str = (' '*(width-4-len(base.name())) +
                   self._link_to_html(base)+' --+'+postfix+'\n' + 
                   ' '*(width-4) +
                   '   |'+postfix+'\n' +
                   str)
            (t,w) = (base.target(), width)
            if i != 0:
                str = (self._base_tree(t, w-4, '   |'+postfix)+str)
            else:
                str = (self._base_tree(t, w-4, '    '+postfix)+str)
        ss = re.sub('<[^<>]+>','',str)
        return str
                
    #////////////////////////////////////////////////////////////
    # Class hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _class_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_class_tree}.
        """
        if uid is not None:
            doc = self._docmap.get(uid, None)
            str = ' '*depth + '<li> <b>' + self._uid_to_href(uid)+'</b>'
            if doc and doc.descr():
                str += ': <i>' + self._summary(doc, uid.module()) + '</i>'
            str += '\n'
            if doc and doc.children():
                str += ' '*depth + '  <ul>\n'
                children = [l.target() for l
                            in self._sort(doc.children())]
                for child in children:
                    str += self._class_tree_item(child, depth+4)
                str += ' '*depth + '  </ul>\n'
        return str

    def _class_tree(self, sort_order=None):
        """
        @return: The HTML code for the class hierarchy tree.  This is
            used by L{_tree_to_html} to construct the hierarchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        docs = self._docmap.items()
        docs.sort(lambda a,b: cmp(a[0], b[0]))
        for (uid, doc) in docs:
            if not isinstance(doc, ClassDoc): continue
            hasbase = 0
            for base in doc.bases():
                if self._docmap.has_key(base.target()):
                    hasbase = 1
            if not hasbase:
                str += self._class_tree_item(uid)
        return str +'</ul>\n'

    #////////////////////////////////////////////////////////////
    # Module hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _module_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_module_tree} and L{_module_list}.
        @rtype: C{string}
        """
        if uid is None: return ''

        doc = self._docmap.get(uid, None)
        name = `uid`.split('.')[-1]
        str = ' '*depth + '<li> <b>'
        str += self._uid_to_href(uid, name)+'</b>'
        if doc and doc.descr():
            str += ': <i>' + self._summary(doc, uid) + '</i>'
        str += '\n'
        if doc and doc.ispackage() and doc.modules():
            str += ' '*depth + '  <ul>\n'
            modules = [l.target() for l
                       in self._sort(doc.modules(), doc.sort_order())]
            for module in modules:
                str += self._module_tree_item(module, depth+4)
            str += ' '*depth + '  </ul>\n'
        str += ' '*depth+'</li>'
        return str

    def _module_tree(self, sort_order=None):
        """
        @return: The HTML code for the module hierarchy tree.  This is
            used by L{_tree_to_html} to construct the hiearchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        docs = self._docmap.items()
        docs.sort(lambda a,b: cmp(a[0], b[0]))
        # Find all top-level packages. (what about top-level
        # modules?)
        for (uid, doc) in docs:
            if not isinstance(doc, ModuleDoc): continue
            if not doc.package():
                str += self._module_tree_item(uid)
        return str +'</ul>\n'

    def _module_list(self, modules, sort_order):
        """
        @return: The HTML code for the module hierarchy tree,
            containing the given modules.  This is used by
            L{_module_to_html} to list the submodules of a package.
        @rtype: C{string}
        """
        if len(modules) == 0: return ''
        str = '<h3>Modules</h3>\n<ul>\n'
        modules = self._sort(modules, sort_order)
        
        for link in modules:
            str += self._module_tree_item(link.target())
        return str + '</ul>\n'

    #////////////////////////////////////////////////////////////
    # Class tables
    #////////////////////////////////////////////////////////////
    
    def _class_summary(self, classes, sort_order, heading='Class Summary'):
        """
        @return: The HTML code for the class summary table.  This is
            used by L{_module_to_html} to list the classes in a
            module.
        @rtype: C{string}
        """
        classes = self._sort(classes, sort_order)
        if len(classes) == 0: return ''
        str = self._table_header(heading, 'summary')

        for link in classes:
            cname = link.name()
            cls = link.target()
            if not self._docmap.has_key(cls): continue
            cdoc = self._docmap[cls]
            csum = self._summary(cdoc, cls.module())
            str += '<tr><td width="15%">\n'
            str += '  <b><i>'+self._link_to_html(link)
            str += '</i></b></td>\n  <td>' + csum + '</td></tr>\n'
        return str + '</table><br>\n\n'

    #////////////////////////////////////////////////////////////
    # Function tables
    #////////////////////////////////////////////////////////////
    
    def _func_summary(self, functions, sort_order, heading='Function Summary'):
        """
        @return: The HTML code for a function summary table.  This
            is used by L{_module_to_html} to list the functions in a
            module; and by L{_class_to_html} to list member
            functions. 
        @rtype: C{string}
        """
        functions = self._sort(functions, sort_order)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'summary')
        
        for link in functions:
            func = link.target()
            fname = link.name()
            if func.is_method(): container = func.cls()
            else:
                try: container = func.module()
                except TypeError: container = None
            if not self._docmap.has_key(func):
                if WARN_MISSING:
                    print 'WARNING: MISSING', func
                continue
            
            fdoc = self._docmap[func]
            
            # Try to find a documented ancestor.
            inheritdoc = 0
            while (not fdoc.documented() and
                   fdoc.overrides() and
                   self._docmap.has_key(fdoc.overrides())):
                fdoc = self._docmap[fdoc.overrides()]
                inheritdoc = 1
                
            rval = fdoc.returns()
            if rval.type():
                rtype = dom_to_html(rval.type(), container)
            else: rtype = '&nbsp;'

            pstr = '('
            for param in fdoc.parameters():
                pstr += param.name()+', '
            if fdoc.vararg():
                pstr += '*'+fdoc.vararg().name()+', '
            if fdoc.kwarg():
                pstr += '**'+fdoc.kwarg().name()+', '
            if pstr == '(': pstr = '()'
            else: pstr = pstr[:-2]+')'

            descrstr = self._summary(fdoc, container)
            if descrstr != '&nbsp;':
                fsum = '<br>'+descrstr
            else: fsum = ''
            str += '<tr><td align="right" valign="top" '
            str += 'width="15%"><font size="-1">'
            str += rtype+'</font></td>\n'
            str += '  <td><code><b><a href="#'+fname+'">'
            str += fname+'</a>'
            str += '</b>'+pstr+'</code>\n  '
            str += fsum+'</td></tr>\n'
        return str + '</table><br>\n\n'
    
    def _func_details(self, functions, cls, heading='Function Details'):
        """
        @return: The HTML code for a function details table.  This
            is used by L{_module_to_html} to describe the functions in
            a module; and by L{_class_to_html} to describe member
            functions.
        @rtype: C{string}
        """
        functions = self._sort(functions)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>'

        for link in functions:
            fname = link.name()
            func = link.target()
            if func.is_method(): container = func.cls()
            else:
                try: container = func.module()
                except TypeError: container = None
            if not self._docmap.has_key(func):
                if WARN_MISSING:
                    print 'WARNING: MISSING', func
                continue
            
            str += ('<table width="100%" class="func-details"'+
                    ' bgcolor="#e0e0e0">'+
                    '<tr><td>\n')
            
            fdoc = self._docmap[func]

            str += '<a name="'+fname+'"></a>\n'
            if SPECIAL_METHODS.has_key(fname):
                str += '<h3 class="func-details"><i>'
                str += SPECIAL_METHODS[fname]+'</i></h3>\n'
            else:
                str += '<h3 class="func-details">'+fname+'</h3>\n'

            str += self._func_signature(fname, fdoc)

            foverrides = fdoc.overrides()

            # Try to find a documented ancestor.
            inheritdoc = 0
            while (not fdoc.documented() and
                   fdoc.overrides() and
                   self._docmap.has_key(fdoc.overrides())):
                fdoc = self._docmap[fdoc.overrides()]
                inheritdoc = 1
                
            fdescr=fdoc.descr()
            fparam = fdoc.parameters()[:]
            if fdoc.vararg(): fparam.append(fdoc.vararg())
            if fdoc.kwarg(): fparam.append(fdoc.kwarg())
            freturn = fdoc.returns()
            fraises = fdoc.raises()
            
            # Don't list parameters that don't have any extra info.
            f = lambda p:p.descr() or p.type()
            fparam = filter(f, fparam)

            # Description
            if fdescr:
                str += '\n'+dom_to_html(fdescr, container, para=1)+'\n'
            str += '<dl><dt></dt><dd>\n'

            # Parameters
            if fparam:
                str += '    <dl><dt><b>Parameters:</b></dt>\n'
                for param in fparam:
                    pname = param.name()
                    str += '      <dd><code><b>' + pname +'</b></code>'
                    if param.descr():
                        str += ' - ' + dom_to_html(param.descr(),
                                                   container)
                    if param.type():
                        str += ' <br>\n        <i>'+('&nbsp;'*10)
                        str += '(type=' + dom_to_html(param.type(),
                                                      container)
                        str += ')</i>'
                    str += '</dd>\n'
                str += '    </dl>\n'

            # Returns
            if freturn.descr() or freturn.type():
                str += '    <dl><dt><b>Returns:</b></dt>\n      <dd>'
                if freturn.descr():
                    str += dom_to_html(freturn.descr(), container)
                    if freturn.type():
                        str += ' <br>' + '<i>'+('&nbsp;'*10)
                        str += '(type=' 
                        str += dom_to_html(freturn.type(), container) 
                        str += ')</i>'
                elif freturn.type():
                    str += dom_to_html(freturn.type(), container)
                str += '</dd>\n    </dl>\n'

            # Raises
            if fraises:
                str += '    <dl><dt><b>Raises:</b></dt>\n'
                for fraise in fraises:
                    str += '      '
                    str += '<dd><code><b>'+fraise.name()+'</b></code> - '
                    str += dom_to_html(fraise.descr(), container)+'</dd>\n'
                str += '    </dl>\n'

            # Overrides
            if foverrides:
                cls = foverrides.cls()
                str += '    <dl><dt><b>Overrides:</b></dt>\n'
                if self._docmap.has_key(cls):
                    str += ('      <dd><code><a href="' +
                            _uid_to_uri(cls) + '#' +
                            foverrides.shortname() +
                            '">' + `foverrides` + '</a></code>')
                else:
                    str += '      <dd><code>'+`func`+'</code>'
                if inheritdoc:
                    str += ' <i>(inherited documentation)</i>\n'
                str += '</dd>\n    </dl>\n'
                
            str += '</dd></dl>\n'
            str += '</td></tr></table>\n'

        str += '<br>\n\n'
        return str

    def _func_signature(self, fname, fdoc, cssclass="sig"):
        """
        @return: The HTML code for the function signature of the
            function with the given name and documentation.
        @param fname: The short name of the function.
        @type fname: C{string}
        @param fdoc: The documentation for the function.
        @type fdoc: L{objdoc.FuncDoc}
        """
        str = '<b><code class=%s>' % cssclass
        str += '<span class=%s-name>%s</span>(' % (cssclass, fname)
        
        for param in fdoc.parameters():
            str += '<span class=%s-arg>%s</span>' % (cssclass, param.name())
            if param.default():
                default = param.default()
                if len(default) > 60:
                    default = default[:57]+'...'
                str += '=<span class=%s-default>%s</span>' % (cssclass,
                                                              default)
            str += ', '
        if fdoc.vararg():
            str += '<span class=%s-vararg>*%s</span>, ' % (cssclass,
                                                   fdoc.vararg().name())
        if fdoc.kwarg():
            str += '<span class=%s-kwarg>**%s</span>, ' % (cssclass,
                                                   fdoc.kwarg().name())
        if str[-1] != '(': str = str[:-2]

        return str + ')</code></b>'

    #////////////////////////////////////////////////////////////
    # Variable tables
    #////////////////////////////////////////////////////////////
    
    def _var_summary(self, variables, sort_order, container,
                     heading='Variable Summary'):
        """
        @return: The HTML code for a variable summary table.  This
            is used by L{_module_to_html} to list the variables in a
            module; and by L{_class_to_html} to list instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._sort(variables, sort_order)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'summary')

        for var in variables:
            vname = var.name()
            if var.type(): vtype = dom_to_html(var.type(), container)
            else: vtype = '&nbsp;'
            if var.descr():
                vsum = '<br>'+self._summary(var, container)
            else: vsum = ''
            str += '<tr><td align="right" valign="top" '
            str += 'width="15%"><font size="-1">'+vtype+'</font></td>\n'
            str += '  <td><code><b><a href="#'+vname+'">'+vname
            str += '</a>'+'</b></code>\n  ' + vsum+'</td></tr>\n'
        return str + '</table><br>\n\n'

    def _var_details(self, variables, container, heading='Variable Details'):
        """
        @return: The HTML code for a variable details table.  This
            is used by L{_module_to_html} to describe the variables in
            a module; and by L{_class_to_html} to describe instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._sort(variables)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>'

        numvars = 0
        for var in variables:
            # Don't bother if we don't know anything about it.
            if not (var.descr() or var.type()): continue
            numvars += 1
            
            str += ('<table width="100%" class="var-details"'+
                    ' bgcolor="#e0e0e0">'+
                    '<tr><td>\n')
            
            vname = var.name()

            str += '<a name="'+vname+'"></a>\n'
            str += '<h3>'+vname+'</h3>\n'
            str += '<dl>\n'

            if var.descr():
                str += '  <dd>'
                str += dom_to_html(var.descr(), container)+'<br>\n'
                
            if var.type():
                str += '  <dl><dt><b>Type:</b>\n' 
                str += '<code>'+dom_to_html(var.type(), container)
                str += '</code>'+'</dt></dl>\n'

            #if var.overrides():
            #    str += '  <dl><dt><b>Overrides:</b></dt>\n'
            #    for target in var.overrides():
            #        str += '    <dd>' +\
                  #        self._link_to_html(target.data[0]) + '\n'
            #    str += '  </dl>\n'
            
            str += '</dd></dl></td></tr></table>\n'

        # If we didn't get any variables, don't print anything.
        if numvars == 0: return ''
        return str+'<br>'

    #////////////////////////////////////////////////////////////
    # Index generation
    #////////////////////////////////////////////////////////////
    
    def get_index_items(self, tree, base, dict=None):
        if dict == None: dict = {}
    
        if isinstance(tree, _Text): return dict
        elif tree.tagName != 'index':
            for child in tree.childNodes:
                self.get_index_items(child, base, dict)
        else:
            children = [dom_to_html(c) for c in tree.childNodes]
            key = ''.join(children).lower().strip()
            if dict.has_key(key):
                dict[key].append(base)
            else:
                dict[key] = [base]
        return dict

    def _extract_index(self):
        """
        @return: A dictionary mapping from terms to lists of source
            documents. 
        """
        index = {}
        for (uid, doc) in self._docmap.items():
            if uid.is_function(): uid = uid.module()
            if uid.is_method(): uid = uid.cls()
            base = `uid`
            descr = doc.descr()
            if descr:
                self.get_index_items(descr, base, index)
        return index

    #////////////////////////////////////////////////////////////
    # Helper functions
    #////////////////////////////////////////////////////////////
    
    def _header(self, name):
        """
        @return: The HTML code for the header of a page with the given
            name.
        @rtype: C{string}
        """
        return HEADER % (name, self._cssfile)
               
    def _footer(self):
        """
        @return: The HTML code for the footer of a page.
        @rtype: C{string}
        """
        return FOOTER % time.asctime(time.localtime(time.time()))
    
    def _find_toplevel(self):
        """
        Try to find a unique module/package for this set of docs.
        Update the member variables L{_package} and L{_module} to
        contain the top-level module/package.
        """
        modules = []
        packages = []
        for (uid, doc) in self._docmap.items():
            if not isinstance(doc, ModuleDoc): continue
            modules.append(uid)
            if doc.ispackage():
                packages.append(uid)

        # Is there a unique module?
        if len(modules) == 0: self._module = None
        elif len(modules) == 1: self._module = modules[0]
        else: self._module = 'multiple'

        # Is there a unique (top-level) package?
        if len(packages) == 0: self._package = None
        else:
            self._package = 'multiple'
            for pkg in packages:
                toplevel = 1
                for p2 in packages:
                    if pkg != p2 and not p2.descendant_of(pkg):
                        toplevel = 0
                if toplevel:
                    self._package = pkg

    def _sort(self, docs, sort_order=None):
        """
        Sort and filter a list of C{ObjDoc}s.  In particular, if
        C{sort_order} is not C{None}, then sort according to its
        contents; otherwise, sort using L{_cmp_name}.  If
        L{_show_private} is true, then filter out all private objects;
        otherwise, perform no filtering.

        @param docs: The list of C{ObjDoc}s to be sorted and filtered.
        @type docs: C{list} of L{ObjDoc}
        @param sort_order: A list of object names, typically generated
            from __epydoc__sort__, and returned by {doc.sort_order()},
            where C{doc} is the object that contains the objects
            documented by C{docs}.
        @type sort_order: C{list} of C{string}
        """
        docs = list(docs)

        # First, sort by __epydoc_sort__
        if sort_order is None:
            sortdocs = []
        else:
            sort_order = list(sort_order)
            sortdocs = sort_order[:]
            for doc in docs:
                try: index = sort_order.index(doc.name())
                except ValueError: continue
                sortdocs[index] = doc
            sortdocs = [d for d in sortdocs if type(d) != type('')]
            for doc in sortdocs: docs.remove(doc)
        
        # Then, sort by _cmp_name.
        docs.sort(lambda x,y: _cmp_name(x, y))
        if not self._show_private:
            docs = filter(lambda x:not _is_private(x.name()), docs)

        return sortdocs + docs

    def _seealso(self, seealso, container):
        """
        @return: The HTML code for a see-also field.
        """
        if not seealso: return ''
        str = '<dl><dt><b>See also:</b>\n  </dt><dd>'
        for see in seealso:
            str += dom_to_html(see, container)
        return str[:-2] + '</dd>\n</dl>\n\n'

    def _summary(self, doc, container):
        """
        @return: The HTML code for the summary description of the
            object documented by C{doc}.  A summary description is the
            first sentence of the C{doc}'s 'description' field.  If the
            C{doc} has no 'description' field, but does have a
            'return' field, then the summary is taken from the return
            field instead.
        @rtype: C{string}
        @param doc: The documentation for the object whose summary
            should be returned.
        @type doc: C{objdoc.ObjDoc}
        @param container: The container object for C{doc}, or C{None}
            if there is none.  This container object is used to
            resolve links (E{L}{...}) in the epytext.
        @type container: C{uid.UID}
        """
        descr = doc.descr()

        # Try to find a documented ancestor.
        if isinstance(doc, FuncDoc):
            while (not doc.documented() and
                   doc.overrides() and
                   self._docmap.has_key(doc.overrides())):
                doc = self._docmap[doc.overrides()]

        if descr != None:
            str = dom_to_html(epytext.summary(descr), container).strip()
            if str == '': str = '&nbsp;'
            return str
        elif (isinstance(doc, FuncDoc) and
              doc.returns().descr() is not None):
            summary = epytext.summary(doc.returns().descr())
            summary = dom_to_html(summary, container).strip()
            summary = summary[:1].lower() + summary[1:]
            return ('Return '+ summary)
        else:
            return '&nbsp;'

    def _link_to_html(self, link):
        """
        @return: The HTML code for the given link.  This code consists
            of an anchor with an href to the page for the link's
            target, and with text taken from the link's name. If the
            target is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type link: L{uid.Link}
        """
        return self._uid_to_href(link.target(), link.name())

    def _uid_to_href(self, uid, label=None):
        """
        @return: The HTML code to link to the given UID.  This code
            consists of an anchor with an href to the page for C{uid}.
            If C{label} is not C{None}, then it is used as the text
            for the link; otherwise, C{uid} is used as the text.  If
            C{uid} is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type uid: L{uid.UID}
        @type label: C{string}
        """
        if label==None: label = `uid`
        if self._docmap.has_key(uid):
            str = ('<a href="' + _uid_to_uri(uid) +
                   '">' + label + '</a>')
            if not isinstance(self._docmap[uid], ModuleDoc):
                str = '<code>'+str+'</code>'
        else:
            str = label
        return str

    def _start_of(self, heading):
        """
        @return: The HTML code for a 'start-of' comment.  These
            comments are used to deliniate sections of the HTML
            output.
        @rtype: C{string}
        @param heading: The name of the section that is starting.
        @type heading: C{string}
        """
        return '\n<!-- =========== START OF '+string.upper(heading)+\
               ' =========== -->\n'
    
    def _table_header(self, heading, css_class):
        """
        @return: The HTML code for the start of a table.  This is used
            by class tables, function tables, variable tables, etc.
        @rtype: C{string}
        @param heading: The name for the table.
        @type heading: C{string}
        @param css_class: The css class for the table.  This is used
            to allow different tables to be given different styles.
            Currently, the following classes are used: C{'summary'};
            C{'details'}; and C{'index'}.
        """
        return self._start_of(heading)+\
               '<table class="'+css_class+'" border="1" cellpadding="3"' +\
               ' cellspacing="0" width="100%" bgcolor="white">\n' +\
               '<tr bgcolor="#70b0f0" class="'+css_class+'">\n'+\
               '<th colspan="2">\n' + heading +\
               '</th></tr>\n'
    
    def _split_classes_and_excepts(self, doc):
        """
        Divide the classes fromt the given module into exceptions and
        non-exceptions.  This is used by L{_module_to_html} to list
        exceptions and non-exceptions separately.

        @param doc: The documentation for the module whose classes
            should be split up.
        @type doc: C{objdoc.ModuleDoc}
        @return: A list C{(I{classes}, I{excepts})}, where
            C{I{classes}} is the list of non-exception classes, and
            C{I{excepts}} is the list of exception classes.
        @rtype: C{pair} of C{list} of C{objdoc.ClassDoc}
        """
        classes = []
        excepts = []
        for link in doc.classes():
            try:
                if (self._docmap.has_key(link.target()) and
                    self._docmap[link.target()].is_exception()):
                    excepts.append(link)
                else:
                    classes.append(link)
            except:
                classes.append(link)
        return (classes, excepts)
        
