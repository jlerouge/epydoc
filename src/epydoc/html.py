#
# epydoc.html: epydoc HTML output generator
# Edward Loper
#
# Created [01/30/01 05:18 PM]
# $Id$
#

"""
Documentation to HTML converter.
"""

# To do:
#   - Control over whether you link to non-documented objects
#   - Better help

##################################################
## Implementation Notes
##################################################

# Index:
#     1. Constants
#     2. Imports
#     3. HTML Formatter
#       - Constructor
#       - Write
#       - HTML page generation
#       - Navigation bar
#       - Base class trees
#       - Class hierarchy trees
#       - Module hierarchy trees
#       - Class tables
#       - Function tables
#       - Variable tables
#       - Index generation
#       - Docstring->HTML Conversion
#       - Helper functions
#

# I chose to implement the formatter as a class (rather than as a
# group of functions) because it lets me use instance variables to
# remember all the configuration variables, that might have
# far-reaching consequences.  Passing these around manually would be a
# pain.  Also, I don't have to explicitly pass around the docmap,
# which is used almost everywhere.

##################################################
## Constants
##################################################

HELP = '''
    <h2> Help </h2>

    <p> (No help available) </p>
'''

# Expects: (name, css)
HEADER = '''
<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title> %s</title>
    <link rel="stylesheet" href="%s" type="text/css"></link>
  </head>
  <body bgcolor="white" text="black" link="blue" vlink="#204080"
        alink="#204080">
'''
# Expects: date
FOOTER = '''
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left"><font size="-2">Generated by Epydoc on %s</font></td>
    <td align="right"><a href="http://epydoc.sf.net"
                      ><font size="-2">http://epydoc.sf.net</font></a></td>
  </tr>
</table>
</body>
</html>'''

# Names for the __special__ methods.
SPECIAL_METHODS ={
    '__init__': 'Constructor',
    '__del__': 'Destructor',
    '__add__': 'Addition operator',
    '__sub__': 'Subtraction operator',
    '__and__': 'And operator',
    '__or__': 'Or operator',
    '__repr__': 'Representation operator',
    '__call__': 'Call operator',
    '__getattr__': 'Qualification operator',
    '__getitem__': 'Indexing operator',
    '__setitem__': 'Index assignment operator',
    '__delitem__': 'Index deletion operator',
    '__delslice__': 'Slice deletion operator',
    '__setslice__': 'Slice assignment operator',
    '__getslice__': 'Slicling operator',
    '__len__': 'Length operator',
    '__cmp__': 'Comparison operator',
    '__eq__': 'Equality operator',
    '__in__': 'Containership operator',
    '__gt__': 'Greater-than operator',
    '__lt__': 'Less-than operator',
    '__ge__': 'Greater-than-or-equals operator',
    '__le__': 'Less-than-or-equals operator',
    '__radd__': 'Right-side addition operator',
    '__hash__': 'Hashing function',
    '__contains__': 'In operator',
    '__str__': 'Informal representation operator',
    }

##################################################
## Imports
##################################################

# system imports
import re, sys, os.path, string, time
from xml.dom.minidom import Text as _Text

# epydoc imports
import epydoc.epytext as epytext
from epydoc.uid import UID, Link, findUID
from epydoc.objdoc import DocMap, ModuleDoc, FuncDoc
from epydoc.objdoc import ClassDoc, Var, Raise, ObjDoc
import epydoc.css

##################################################
## Documentation -> HTML Conversion
##################################################

class HTML_Doc:
    """
    Documentation to HTML converter.

    For each module/package, create a file containing:
      - Navbar
      - Module Name
      - Description
      - See-also
      - Module list
      - Class summary
      - Function summary
      - Variable summary
      - Function details
      - Variable details
      - Navbar

    For each class, create a file containing:
      - Navbar
      - Module name
      - Class Name
      - Base tree
      - Known subclasses
      - Description
      - See-also
      - Method summary
      - Instance Variable summary
      - Class Variable summary
      - Method details
      - Instance Variable details
      - Class Variable details
      - Navbar

    Also, generate an index file, a help file, and a tree file.

    @type docmap: L{DocMap}
    @ivar docmap: The documentation object, encoding the objects that
        should be documented.
    @type _pkg_name: C{string}
    @ivar _pkg_name: A name for the documentation (for the navbar).
    @type _pkg_url: C{string}
    @ivar _pkg_url: A URL for the documentation (for the navpar).
    
    @ivar _module: The UID of the top-level module, if there is one.
        If there is more than one top-level module, then C{_module} is
        C{'multiple'}; if there is no top-level module, then
        C{_module} is C{None}.
    @ivar _package: The UID of the top-level package, if there is one.
        If there is more than one top-level package, then C{_package} is
        C{'multiple'}; if there is no top-level package, then
        C{_package} is C{None}.
    @ivar _show_private: Whether we are currently writing files that
        show private objects.
    @ivar _css: The name of a file containing a CSS stylesheet; or the
        name of a CSS stylesheet.
    @ivar _cssfile: The name of the CSS stylesheet file.  This should be
        C{'epydoc.css'} when C{_show_private==0} and C{'../epydoc.css'}
        when C{_show_private==1}.
    """

    #////////////////////////////////////////////////////////////
    # Constructor
    #////////////////////////////////////////////////////////////
    
    def __init__(self, docmap, **kwargs):
        """
        Construct a new HTML outputter, using the given
        L{DocMap} object.
        
        @param docmap: The documentation to output.
        @type docmap: L{DocMap}
        @param kwargs: Keyword arguments:
            - C{pkg_name}: A name for the documentation (for the
              navbar).  This name can contain arbitrary HTML code
              (e.g., images or tables). (type=C{string})
            - C{pkg_url}: A URL for the documentation (for the
              navbar).  (type=C{string})
            - C{css}: The CSS stylesheet file.  If C{css} is a file,
              then its conents will be used.  Otherwise, if C{css} is
              the name of a CSS stylesheet in L{epydoc.css}, then that
              stylesheet will be used.  Otherwise, an error is
              reported. 
        """
        self._docmap = docmap

        # Process keyword arguments.
        self._pkg_name = kwargs.get('pkg_name', '')
        self._pkg_url = kwargs.get('pkg_url', None)
        self._css = kwargs.get('css')

        # Find the top-level object (if any)
        self._find_toplevel()

        # Cache the HTML that we generate for each docstring.
        self._dom_to_html_cache = {}

    #////////////////////////////////////////////////////////////
    # Write (and its helpers)
    #////////////////////////////////////////////////////////////
    
    def write(self, directory=None, progress_callback=None):
        """
        Write the documentation to the given directory.

        @type directory: C{string}
        @param directory: The directory to which output should be
            written.  If no directory is specified, output will be
            written to the current directory.  If the directory does
            not exist, it will be created.
        @type progress_callback: C{function}
        @param progress_callback: A callback function that is called
            before each file is written, with two arguments: the name
            of the created file (C{string}); and the object documented
            by the file, if any (L{ObjDoc}).
        @rtype: C{None}
        """
        if directory in ('', None): directory = './'
        if directory[-1] != '/': directory = directory + '/'
        self._show_private = 0
        
        # Create dest directories, if necessary
        if not os.path.isdir(directory):
            if os.path.exists(directory):
                raise ValueError('%r is not a directory' % directory)
            os.mkdir(directory)
        if not os.path.isdir(os.path.join(directory, 'private/')):
            if os.path.exists(os.path.join(directory, 'private/')):
                raise ValueError('%r is not a directory' %
                                 os.path.join(directory, 'private/'))
            os.mkdir(os.path.join(directory, 'private/'))

        # Write the private version of the docs.
        self._show_private = 1
        self._cssfile = '../epydoc.css'
        self._write_docs(os.path.join(directory, 'private/'),
                         progress_callback)

        # Write the public version of the docs.
        self._show_private = 0
        self._cssfile = 'epydoc.css'
        self._write_docs(directory, progress_callback)
        
        # Write the tree file (package & class hierarchies)
        progress_callback(os.path.join(directory, 'epydoc-tree.html'), None)
        str = self._tree_to_html()
        open(directory+'epydoc-tree.html', 'w').write(str)

        # Write the index file.
        progress_callback(os.path.join(directory, 'epydoc-index.html'), None)
        str = self._index_to_html()
        open(directory+'epydoc-index.html', 'w').write(str)

        # Write the help file.
        progress_callback(os.path.join(directory, 'epydoc-help.html'), None)
        self._write_help(directory)

        # Write the CSS file.
        progress_callback(os.path.join(directory, self._cssfile), None)
        self._write_css(directory)

    def _write_docs(self, directory, progress_callback):
        """
        A helper for L{write} that does the work of writing the
        documentation to the given directory.
        
        @param directory: Testing L{_find_toplevel}.
        """
        for (n, d) in self._docmap.items():
            filename = os.path.join(directory, `n`+'.html')
            if isinstance(d, ModuleDoc):
                if progress_callback: progress_callback(filename, d)
                str = self._module_to_html(n)
                open(filename, 'w').write(str)
            elif isinstance(d, ClassDoc):
                if progress_callback: progress_callback(filename, d)
                str = self._class_to_html(n)
                open(filename, 'w').write(str)

    def _write_help(self, directory):
        """
        Write a default help file for the documentation, unless a
        help file is already present.

        @rtype: C{None}
        """
        filename = os.path.join(directory, 'epydoc-help.html')
        if os.path.exists(filename): return
        helpfile = open(filename, 'w')
        navbar = self._navbar('help')
        helpfile.write(self._header('Help')+navbar+HELP+navbar+self._footer())
        helpfile.close()
        
    def _write_css(self, directory):
        """
        Write the CSS stylesheet for the documentation.  If a
        stylesheet file or name (from L{epydoc.css}) is specified,
        then use that stylesheet; otherwise, if a stylesheet file
        already exists, use that stylesheet.  Otherwise, use the
        default stylesheet.

        @rtype: C{None}
        """
        filename = os.path.join(directory, 'epydoc.css')
        
        # Get the contents for the stylesheet file.  If none was
        # specified, and a stylesheet is already present, then don't
        # do anything.
        if self._css is None:
            if os.path.exists(filename):
                return
            else: css = epydoc.css.STYLESHEETS['default'][0]
        else:
            if os.path.exists(self._css):
                css = open(self._css).read()
            elif epydoc.css.STYLESHEETS.has_key(self._css):
                css = epydoc.css.STYLESHEETS[self._css][0]
            else:
                raise IOError("Can't find CSS file: %r" % self._css)

        # Write the stylesheet.
        cssfile = open(filename, 'w')
        cssfile.write(css)
        cssfile.close()

    #////////////////////////////////////////////////////////////
    # HTML page generation
    #////////////////////////////////////////////////////////////
    # Each of these functions creates a single HTML file, and returns
    # it as a string.
    
    def _module_to_html(self, uid):
        """
        @return: An HTML page describing the module identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the module that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation.
        doc = self._docmap[uid]

        # Check if it's a package or a module.
        if uid.is_package(): moduletype = 'package'
        else: moduletype = 'module'

        # Write the header & navigation bar.
        str = self._header(`uid`)
        str += self._navbar(moduletype, uid)
        str += self._public_private_link(uid)

        # Write the module's name.
        if moduletype == 'package':
            str += self._start_of('Package Description')
            str += '<h2>Package '+uid.name()+'</h2>\n\n'
        else:
            str += self._start_of('Module Description')
            str += '<h2>Module '+uid.name()+'</h2>\n\n'

        # Add any author links.
        if doc.authors():
            str += self._author(doc.authors(), uid)

        # Write the module's description.
        if doc.descr():
            str += self._dom_to_html(doc.descr(), uid) + '<hr/>\n'

        # Add any see-also links.
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # If it's a package, add a list of sub-modules.
        if doc.ispackage():
            str += self._module_list(doc.modules(), doc.sortorder())

        # Show the summaries for classes, exceptions, functions, and
        # variables contained in the module.
        (classes,excepts) = self._split_classes_and_excepts(doc)
        str += self._class_summary(classes, doc.sortorder(), 'Classes')
        str += self._class_summary(excepts, doc.sortorder(), 'Exceptions')
        str += self._func_summary(doc.functions(), doc.sortorder(), None)
        str += self._var_summary(doc.variables(), doc.sortorder(), uid)

        # Show details for the functions and variables.
        str += self._func_details(doc.functions(), None)
        str += self._var_details(doc.variables(), uid)

        # Add another navigation bar and the footer.
        str += self._navbar(moduletype, uid) + self._footer()
        
        return str

    def _class_to_html(self, uid):
        """
        @return: An HTML page describing the class identified by
            C{uid}.
        @rtype: C{string}
        @param uid: The unique identifier for the class that should
            be documented.
        @type uid: L{UID}
        """
        # Get the module's documentation
        doc = self._docmap[uid]
        
        # Write the header & navigation bar.
        str = self._header(`uid`)
        str += self._navbar('class', uid)
        str += self._public_private_link(uid)

        # Add any author links.
        if doc.authors():
            str += self._author(doc.authors(), uid)

        # Write the class's module and its name.
        str += self._start_of('Class Description')
        str += '<h2><font size="-1">\n'+uid.module().name()+'</font><br>\n' 
        str += 'Class ' + `uid`+'</h2>\n\n'

        # Write the base class tree
        if doc.bases():
            str += '<pre class="base-tree">\n' 
            str += self._base_tree(uid) 
            str += '</pre><br>\n\n'

        # Write the class's known subclasses
        if doc.subclasses():
            str += '<dl><dt><b>Known Subclasses:</b></dt>\n<dd>'
            for cls in doc.subclasses():
                str += '    '+self._link_to_html(cls) + ',\n'
            str = str[:-2] + '</dd></dl>\n\n'

        # Write the class's description
        if doc.descr():
            str += '<hr/>\n' + self._dom_to_html(doc.descr(), uid)
            str += '\n\n'
        str += '<hr/>\n\n'

        # Add any see-also links
        if doc.seealsos():
            str += self._seealso(doc.seealsos(), uid)

        # Show the summaries for methods, instance variables, and
        # class variables contained in the class.
        str += self._func_summary(doc.methods(), doc.sortorder(),
                                  doc, 'Method Summary')
        str += self._var_summary(doc.ivariables(), doc.sortorder(),
                                 uid, 'Instance Variable Summary')
        str += self._var_summary(doc.cvariables(), doc.sortorder(),
                                 uid, 'Class Variable Summary')

        # Show details for methods and variables
        str += self._func_details(doc.methods(), doc, 
                                  'Method Details')
        str += self._var_details(doc.ivariables(), uid,
                                 'Instance Variable Details')
        str += self._var_details(doc.cvariables(), uid,
                                 'Class Variable Details')

        # Add a navigation bar and the footer.
        str += self._navbar('class', uid) + self._footer()
        
        return str

    def _tree_to_html(self):
        """
        @return: An HTML page containing the module and class
            hierarchies. 
        @rtype: C{string}
        """
        # Header and navigation bar
        str = self._header('Module and Class Hierarchies')
        str += self._navbar('tree')

        # Module hierarchy
        str += self._start_of('Module Hierarchy')
        str += '<h2>Module Hierarchy</h2>\n'
        str += self._module_tree()

        # Class hierarchy
        str += self._start_of('Class Hierarchy')
        str += '<h2>Class Hierarchy</h2>\n'
        str += self._class_tree()

        # Navigation bar and footer
        str += self._navbar('tree')
        str += self._footer()
        return str

    def _index_to_html(self):
        """
        @return: An HTML page containing the index terms.
        @rtype: C{string}
        """
        # Header and navigation bar.
        str = self._header('Index')
        str += self._navbar('index') + '<br>\n'

        # Index table.
        str += self._start_of('Index')
        str += self._table_header('Index', 'index')
        index = self._extract_index().items()
        index.sort()
        for (term, links) in index:
            str += '  <tr><td width="15%">'+term+'</td>\n    <td>'
            links.sort()
            for link in links:
                str += ('<i><a href="%s#%s">%s</a></i>, ' %
                        (self._uid_to_uri(link.target()),
                         self._index_to_anchor(term), link.name()))
            str = str[:-2] + '</tr></td>\n'
        str += '</table>\n' +  '<br>\n'

        # Navigation bar and footer.
        str += self._navbar('index')
        str += self._footer()
        return str
    
    #////////////////////////////////////////////////////////////
    # Navigation bar
    #////////////////////////////////////////////////////////////
    # The navigation bar is placed at the top & bottom of every HTML
    # page. 
    
    def _navbar(self, where, uid=None):
        """
        @return: The HTML code for a navigation bar on the given type
            of page.
        @rtype: C{string}
        @param where: The type of page for which a navigation bar
            should be generated.  Possible values are C{'class'},
            C{'module'}, C{'package'}, C{'tree'}, C{'index'}, and
            C{'help'}.
        @type where: C{string}
        """
        str = self._start_of('Navbar')
        str += '<table class="navbar" border="0" width="100%"'
        str += ' cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">\n'
        str += '  <tr>\n'
        str += '    <td width="100%">\n'
        str += '      <table border="0" cellpadding="0" cellspacing="0">\n'
        str += '        <tr valign="top">\n'

        I = '          ' # indentation
        
        # The "Go to Package" link
        if self._package is None: pass
        elif where in ('class', 'module'):
            pkg = uid.package()
            if pkg is not None:
                str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
                str += '<a class="navbar" href="'+`pkg`+'.html">'
                str += 'Package</a>&nbsp;&nbsp;&nbsp;</th>\n'
            else:
                str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
                str += 'Package&nbsp;&nbsp;&nbsp;</th>\n'
        elif where=='package':
            str += I+'<th bgcolor="#70b0f0" class="navselect">'
            str += '&nbsp;&nbsp;&nbsp;'
            str += 'Package&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(self._package, UID):
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'+`self._package`+'.html">'
            str += 'Package</a>&nbsp;&nbsp;&nbsp;</th>\n'
        elif 'multiple' == self._package:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += 'Package&nbsp;&nbsp;&nbsp;</th></b>\n'
        
        # The "Go to Module" link
        if self._module is None: pass
        elif where=='class':
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'+`uid.module()`+'.html">'
            str += 'Module</a>&nbsp;&nbsp;&nbsp;</th>\n'
        elif where=='module':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;' 
            str += '&nbsp;&nbsp;Module&nbsp;&nbsp;&nbsp;</th>\n'
        elif isinstance(self._module, UID):
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'+`self._module`+'.html">'
            str += 'Module</a>&nbsp;&nbsp;&nbsp;</th>\n'
        elif 'multiple' == self._module:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += 'Module&nbsp;&nbsp;&nbsp;</th>\n'
        
        # The "Go to Class" link
        if where == 'class':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Class&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;Class' 
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Tree" link
        if where == 'tree':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Trees&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'
            if self._show_private: str += '../'
            str += 'epydoc-tree.html">Trees</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Index" link
        if where == 'index':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'
            if self._show_private: str += '../'
            str += 'epydoc-index.html">Index</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        # The "Go to Help" link
        if where == 'help':
            str += I+'<th bgcolor="#70b0f0" class="navselect">&nbsp;'
            str += '&nbsp;&nbsp;Help&nbsp;&nbsp;&nbsp;</th>\n'
        else:
            str += I+'<th class="navbar">&nbsp;&nbsp;&nbsp;'
            str += '<a class="navbar" href="'
            if self._show_private: str += '../'
            str += 'epydoc-help.html">Help</a>'
            str += '&nbsp;&nbsp;&nbsp;</th>\n'

        str += '        </tr>\n      </table>\n    </td>\n'
        str += '    <td>\n'
        str += '      <table border="0" cellpadding="0" cellspacing="0">\n'
        str += '        <tr valign="top">\n'
        str += '          <th class="navbar">'
        if self._pkg_name:
            if self._pkg_url:
                str += ('<a class="navbar" href="%s">%s</a>' %
                          (self._pkg_url, self._pkg_name))
            else:
                str += self._pkg_name

        str += '</th>\n        </tr>\n'
        str += '      </table>\n    </td>\n  </tr>\n</table>\n'
        return str

    def _public_private_link(self, uid):
        """
        @return: The HTML code for a link between the public & private
            copies of the documentation.
        @rtype: C{string}
        """
        if self._show_private and self._is_private(uid.name()):
            return ''

        str = '<table width="100%"><tr>\n  <td width="100%"></td>\n'
        if self._show_private:
            str += '  <td><font size="-2">[show&nbsp;private&nbsp;|'
            str += '&nbsp;<a href="../' + self._uid_to_uri(uid)
            str += '">hide&nbsp;private</a>]</font></td>\n'
        else:
            str += '  <td><font size="-2">[<a href="private/'
            str += self._uid_to_uri(uid) + '">show&nbsp;private</a>'
            str += '&nbsp;|&nbsp;hide&nbsp;private]</font></td>\n'
        return str + '</tr></table>\n'
    
    #////////////////////////////////////////////////////////////
    # Base class trees
    #////////////////////////////////////////////////////////////
    
    def _find_tree_width(self, uid):
        """
        @return: The width of a base tree, when drawn
            right-justified.  This is used by L{_base_tree} to
            determine how far to indent lines of the base tree.
        @rtype: C{int}
        """
        width = 2
        if self._docmap.has_key(uid):
            for base in self._docmap[uid].bases():
                width = max(width, len(base.name())+4)
                width = max(width, self._find_tree_width(base.target())+4)

        return width
        
    def _base_tree(self, uid, width=None, postfix=''):
        """
        @return: The HTML code for a class's base tree.  The tree is
            drawn 'upside-down' and right justified, to allow for
            multiple inheritence.
        @rtype: C{string}
        """
        if not self._docmap.has_key(uid): return ''
        if width == None:
            width = self._find_tree_width(uid)
        
        bases = self._docmap[uid].bases()
        
        if postfix == '':
            str = ' '*(width-2) + '<b>'+uid.shortname()+'</b>\n'
        else: str = ''
        for i in range(len(bases)-1, -1, -1):
            base = bases[i]
            str = (' '*(width-4-len(base.name())) +
                   self._link_to_html(base)+' --+'+postfix+'\n' + 
                   ' '*(width-4) +
                   '   |'+postfix+'\n' +
                   str)
            (t,w) = (base.target(), width)
            if i != 0:
                str = (self._base_tree(t, w-4, '   |'+postfix)+str)
            else:
                str = (self._base_tree(t, w-4, '    '+postfix)+str)
        ss = re.sub('<[^<>]+>','',str)
        return str
                
    #////////////////////////////////////////////////////////////
    # Class hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _class_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_class_tree}.
        """
        if uid is not None:
            doc = self._docmap.get(uid, None)
            str = ' '*depth + '<li> <b>' + self._uid_to_href(uid)+'</b>'
            if doc and doc.descr():
                str += ': <i>' + self._summary(doc, uid.module()) + '</i>'
            str += '\n'
            if doc and doc.subclasses():
                str += ' '*depth + '  <ul>\n'
                children = [l.target() for l
                            in self._sort(doc.subclasses())]
                for child in children:
                    str += self._class_tree_item(child, depth+4)
                str += ' '*depth + '  </ul>\n'
        return str

    def _class_tree(self, sortorder=None):
        """
        @return: The HTML code for the class hierarchy tree.  This is
            used by L{_tree_to_html} to construct the hierarchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        docs = self._docmap.items()
        docs.sort(lambda a,b: cmp(a[0], b[0]))
        for (uid, doc) in docs:
            if not isinstance(doc, ClassDoc): continue
            hasbase = 0
            for base in doc.bases():
                if self._docmap.has_key(base.target()):
                    hasbase = 1
            if not hasbase:
                str += self._class_tree_item(uid)
        return str +'</ul>\n'

    #////////////////////////////////////////////////////////////
    # Module hierarchy trees
    #////////////////////////////////////////////////////////////
    
    def _module_tree_item(self, uid=None, depth=0):
        """
        Helper function for L{_module_tree} and L{_module_list}.
        
        @rtype: C{string}
        """
        if uid is None: return ''

        doc = self._docmap.get(uid, None)
        name = `uid`.split('.')[-1]
        str = ' '*depth + '<li> <b>'
        str += self._uid_to_href(uid, name)+'</b>'
        if doc and doc.descr():
            str += ': <i>' + self._summary(doc, uid) + '</i>'
        str += '\n'
        if doc and doc.ispackage() and doc.modules():
            str += ' '*depth + '  <ul>\n'
            modules = [l.target() for l
                       in self._sort(doc.modules(), doc.sortorder())]
            for module in modules:
                str += self._module_tree_item(module, depth+4)
            str += ' '*depth + '  </ul>\n'
        str += ' '*depth+'</li>'
        return str

    def _module_tree(self, sortorder=None):
        """
        @return: The HTML code for the module hierarchy tree.  This is
            used by L{_tree_to_html} to construct the hiearchy page.
        @rtype: C{string}
        """
        str = '<ul>\n'
        docs = self._docmap.items()
        docs.sort(lambda a,b: cmp(a[0], b[0]))
        # Find all top-level packages. (what about top-level
        # modules?)
        for (uid, doc) in docs:
            if not isinstance(doc, ModuleDoc): continue
            if not doc.package():
                str += self._module_tree_item(uid)
        return str +'</ul>\n'

    def _module_list(self, modules, sortorder):
        """
        @return: The HTML code for the module hierarchy tree,
            containing the given modules.  This is used by
            L{_module_to_html} to list the submodules of a package.
        @rtype: C{string}
        """
        if len(modules) == 0: return ''
        str = '<h3>Modules</h3>\n<ul>\n'
        modules = self._sort(modules, sortorder)
        
        for link in modules:
            str += self._module_tree_item(link.target())
        return str + '</ul>\n'

    #////////////////////////////////////////////////////////////
    # Class tables
    #////////////////////////////////////////////////////////////
    
    def _class_summary(self, classes, sortorder, heading='Class Summary'):
        """
        @return: The HTML code for the class summary table.  This is
            used by L{_module_to_html} to list the classes in a
            module.
        @rtype: C{string}
        """
        classes = self._sort(classes, sortorder)
        if len(classes) == 0: return ''
        str = self._table_header(heading, 'summary')

        for link in classes:
            cname = link.name()
            cls = link.target()
            if not self._docmap.has_key(cls): continue
            cdoc = self._docmap[cls]
            csum = self._summary(cdoc, cls.module())
            str += '<tr><td width="15%">\n'
            str += '  <b><i>'+self._link_to_html(link)
            str += '</i></b></td>\n  <td>' + csum + '</td></tr>\n'
        return str + '</table><br>\n\n'

    #////////////////////////////////////////////////////////////
    # Function tables
    #////////////////////////////////////////////////////////////
    
    def _func_summary(self, functions, sortorder, cls,
                      heading='Function Summary'):
        """
        @return: The HTML code for a function summary table.  This
            is used by L{_module_to_html} to list the functions in a
            module; and by L{_class_to_html} to list member
            functions. 
        @rtype: C{string}
        """
        functions = self._sort(functions, sortorder)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'summary')
        
        for link in functions:
            func = link.target()
            fname = link.name()
            if func.is_method():
                container = func.cls()
                inherit = (container != cls.uid())
            else:
                inherit = 0
                try: container = func.module()
                except TypeError: container = None

            if not self._docmap.has_key(func):
                print 'SKIPPING:', func
                continue
            fdoc = self._docmap[func]
            
            # Try to find a documented ancestor.
            while (not fdoc.documented() and
                   fdoc.overrides() and
                   self._docmap.has_key(fdoc.overrides())):
                fdoc = self._docmap[fdoc.overrides()]
                
            rval = fdoc.returns()
            if rval.type():
                rtype = self._dom_to_html(rval.type(), container, 8)
            else:
                rtype = '&nbsp;'

            pstr = '('
            for param in fdoc.parameters():
                pstr += param.name()+', '
            if fdoc.vararg():
                pstr += '*'+fdoc.vararg().name()+', '
            if fdoc.kwarg():
                pstr += '**'+fdoc.kwarg().name()+', '
            if pstr == '(': pstr = '()'
            else: pstr = pstr[:-2]+')'

            descrstr = self._summary(fdoc, container)
            if descrstr != '&nbsp;':
                fsum = '<br>'+descrstr
            else:
                if inherit: fsum = '<br>\n'
                else: fsum = ''
            if inherit:
                fsum += ('    <i>(inherited from %s)</i>\n' %
                         self._uid_to_href(container, container.shortname()))
            str += '<tr><td align="right" valign="top" width="15%">'
            str += '<font size="-1">'+rtype+'</font></td>\n  <td>'
            str += self._func_signature(fname, fdoc, 1, 'summary-sig')
            #str += self._uid_to_href(func, fname)
            #str += '</b>'+pstr+'</code>\n  '
            str += fsum+'</td></tr>\n'
        return str + '</table><br>\n\n'
    
    def _func_details(self, functions, cls, heading='Function Details'):
        """
        @return: The HTML code for a function details table.  This
            is used by L{_module_to_html} to describe the functions in
            a module; and by L{_class_to_html} to describe member
            functions.
        @rtype: C{string}
        """
        functions = self._sort(functions)
        if len(functions) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>\n'

        for link in functions:
            fname = link.name()
            func = link.target()
            if func.is_method():
                container = func.cls()
                inherit = (container != cls.uid())
            else:
                inherit = 0
                try: container = func.module()
                except TypeError: container = None
            if not self._docmap.has_key(func):
                continue

            # Don't document inherited methods; instead, the method
            # summary points to the details description in the parent
            # class's file.
            if inherit: continue
            
            str += '\n<a name="'+fname+'"></a>\n'
            str += '<table width="100%" class="func-details"'
            str += ' bgcolor="#e0e0e0"><tr><td>\n'

            if not self._docmap.has_key(func): continue
            fdoc = self._docmap[func]

            if SPECIAL_METHODS.has_key(fname):
                str += '  <h3 class="func-details"><i>'
                str += SPECIAL_METHODS[fname]+'</i></h3>\n'
            else:
                str += '  <h3 class="func-details">'+fname+'</h3>\n'

            str += '  <p>%s</p>\n' % self._func_signature(fname, fdoc)

            foverrides = fdoc.overrides()

            # Try to find a documented ancestor.
            inheritdoc = 0
            while (not fdoc.documented() and
                   fdoc.overrides() and
                   self._docmap.has_key(fdoc.overrides())):
                fdoc = self._docmap[fdoc.overrides()]
                inheritdoc = 1
                
            fdescr=fdoc.descr()
            fparam = fdoc.parameters()[:]
            if fdoc.vararg(): fparam.append(fdoc.vararg())
            if fdoc.kwarg(): fparam.append(fdoc.kwarg())
            freturn = fdoc.returns()
            fraises = fdoc.raises()
            
            # Don't list parameters that don't have any extra info.
            f = lambda p:p.descr() or p.type()
            fparam = filter(f, fparam)

            # Description
            if fdescr:
                str += self._dom_to_html(fdescr, container, 2)
            str += '  <dl><dt></dt><dd>\n'

            # Parameters
            if fparam:
                str += '    <dl><dt><b>Parameters:</b></dt>\n'
                for param in fparam:
                    pname = param.name()
                    str += '      <dd><code><b>' + pname +'</b></code>'
                    if param.descr():
                        pdescr = self._dom_to_html(param.descr(), container, 8)
                        str += ' -\n %s' % pdescr.rstrip()
                    str += '\n'
                    if param.type():
                        ptype = self._dom_to_html(param.type(), container, 14)
                        str += '        <br><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % ptype.strip()
                    str += '      </dd>\n'
                str += '    </dl>\n'

            # Returns
            if freturn.descr() or freturn.type():
                str += '    <dl><dt><b>Returns:</b></dt>\n      <dd>\n'
                if freturn.descr():
                    str += self._dom_to_html(freturn.descr(), container, 8)
                    if freturn.type():
                        rtype = self._dom_to_html(freturn.type(),container,14)
                        str += '        <br><i>'+('&nbsp;'*10)+'\n'
                        str += ' '*8+'(type=%s)</i>\n' % rtype.strip()
                elif freturn.type():
                    str += self._dom_to_html(freturn.type(), container, 8)
                str += '      </dd>\n    </dl>\n'

            # Raises
            if fraises:
                str += '    <dl><dt><b>Raises:</b></dt>\n'
                for fraise in fraises:
                    str += '      '
                    str += '<dd><code><b>'+fraise.name()+'</b></code> -\n'
                    str += self._dom_to_html(fraise.descr(), container, 8)
                    str +'      </dd>\n'
                str += '    </dl>\n'

            # Overrides
            if foverrides:
                str += '    <dl><dt><b>Overrides:</b></dt>\n'
                if self._docmap.has_key(foverrides.cls()):
                    str += ('      <dd><code><a href="' +
                            self._uid_to_uri(foverrides.cls()) + '#' +
                            foverrides.shortname() +
                            '">' + `foverrides` + '</a></code>')
                else:
                    str += '      <dd><code>'+`func`+'</code>'
                if inheritdoc:
                    str += ' <i>(inherited documentation)</i>\n'
                str += '</dd>\n    </dl>\n'

            str += '  </dd></dl>\n'
            str += '</td></tr></table>\n'

        str += '<br>\n\n'
        return str

    def _func_signature(self, fname, fdoc, link=0, cssclass="sig"):
        """
        @return: The HTML code for the function signature of the
            function with the given name and documentation.
        @param fname: The short name of the function.
        @type fname: C{string}
        @param fdoc: The documentation for the function.
        @type fdoc: L{objdoc.FuncDoc}
        @param link: Whether to create a link from the function's name
            to its details description.
        """
        str = '<code class=%s>' % cssclass
        if link: str += '<a href="%s">' % self._uid_to_uri(fdoc.uid())
        str += '<span class=%s-name>%s</span>' % (cssclass, fname)
        if link: str += '</a>'
        
        str += '('
        PARAM_JOIN = ',\n'+' '*15
        for param in fdoc.parameters():
            str += '<span class=%s-arg>%s</span>' % (cssclass, param.name())
            if param.default() and not link:
                default = param.default()
                if len(default) > 60:
                    default = default[:57]+'...'
                str += '=<span class=%s-default>%s</span>' % (cssclass,
                                                              default)
            str += PARAM_JOIN
        if fdoc.vararg():
            str += ('<span class=%s-vararg>*%s</span>%s' %
                    (cssclass, fdoc.vararg().name(), PARAM_JOIN))
        if fdoc.kwarg():
            str += ('<span class=%s-kwarg>**%s</span>%s' %
                    (cssclass, fdoc.kwarg().name(), PARAM_JOIN))
        if str[-1] != '(': str = str[:-len(PARAM_JOIN)]

        return str + ')</code>'

    #////////////////////////////////////////////////////////////
    # Variable tables
    #////////////////////////////////////////////////////////////
    
    def _var_summary(self, variables, sortorder, container,
                     heading='Variable Summary'):
        """
        @return: The HTML code for a variable summary table.  This
            is used by L{_module_to_html} to list the variables in a
            module; and by L{_class_to_html} to list instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._sort(variables, sortorder)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'summary')

        for var in variables:
            vname = var.name()
            if var.type():
                vtype = self._dom_to_html(var.type(), container, 10).strip()
            else: vtype = '&nbsp;'
            if var.descr():
                vsum = ' - ' +self._summary(var, container)
            else: vsum = ''
            str += '<tr><td align="right" valign="top" '
            str += 'width="15%"><font size="-1">'+vtype+'</font></td>\n'
            str += '  <td><code><b><a href="#'+vname+'">'+vname
            str += '</a></b></code>\n  ' + vsum + '</td></tr>\n'
        return str + '</table><br>\n\n'

    def _var_details(self, variables, container, heading='Variable Details'):
        """
        @return: The HTML code for a variable details table.  This
            is used by L{_module_to_html} to describe the variables in
            a module; and by L{_class_to_html} to describe instance
            variables and class variables.
        @rtype: C{string}
        """
        variables = self._sort(variables)
        if len(variables) == 0: return ''
        str = self._table_header(heading, 'details')+'</table>'

        numvars = 0
        for var in variables:
            # Don't bother if we don't know anything about it.
            if not (var.descr() or var.type()): continue
            numvars += 1
            
            str += ('<table width="100%" class="var-details"'+
                    ' bgcolor="#e0e0e0">'+
                    '<tr><td>\n')
            
            vname = var.name()

            str += '<a name="'+vname+'"></a>\n'
            str += '<h3>'+vname+'</h3>\n'
            str += '<dl>\n'

            if var.descr():
                str += '  <dd>'
                str += self._dom_to_html(var.descr(), container)+'<br>\n'
                
            if var.type():
                str += '  <dl><dt><b>Type:</b>\n' 
                str += '<code>'+self._dom_to_html(var.type(), container)
                str += '</code>'+'</dt></dl>\n'

            #if var.overrides():
            #    str += '  <dl><dt><b>Overrides:</b></dt>\n'
            #    for target in var.overrides():
            #        str += '    <dd>' +\
                  #        self._link_to_html(target.data[0]) + '\n'
            #    str += '  </dl>\n'
            
            str += '</dd></dl></td></tr></table>\n'

        # If we didn't get any variables, don't print anything.
        if numvars == 0: return ''
        return str+'<br>'

    #////////////////////////////////////////////////////////////
    # Index generation
    #////////////////////////////////////////////////////////////
    
    def _get_index_items(self, tree, link, dict=None):
        if tree is None: return
        if dict == None: dict = {}
    
        if isinstance(tree, _Text): return dict
        elif tree.tagName != 'index':
            for child in tree.childNodes:
                self._get_index_items(child, link, dict)
        else:
            children = [self._dom_to_html(c) for c in tree.childNodes]
            key = ''.join(children).lower().strip()
            if dict.has_key(key):
                dict[key].append(link)
            else:
                dict[key] = [link]
        return dict

    def _extract_index(self):
        """
        @return: A dictionary mapping from terms to lists of source
            documents. 
        """
        index = {}
        for (uid, doc) in self._docmap.items():
            if uid.is_function():
                link = Link(`uid`, uid.module())
            elif uid.is_method():
                link = Link(`uid`, uid.cls())
            else:
                link = Link(`uid`, uid)

            # Get index items from standard fields.
            self._get_index_items(doc.descr(), link, index)
            for see in doc.seealsos():
                self._get_index_items(see, link, index)
            if doc.version() is not None: 
                self._get_index_items(doc.version(), link, index)
            for author in doc.authors():
                self._get_index_items(author, link, index)

            # Get index items from object-specific fields.
            if isinstance(doc, ModuleDoc):
                for param in doc.variables():
                    self._get_index_items(param.descr(), link, index)
                    self._get_index_items(param.type(), link, index)
            elif isinstance(doc, ClassDoc):
                for param in doc.ivariables() + doc.cvariables():
                    self._get_index_items(param.descr(), link, index)
                    self._get_index_items(param.type(), link, index)
            elif isinstance(doc, FuncDoc):
                extra_p = [v for v in [doc.vararg(), doc.kwarg(),
                                       doc.returns()] if v is not None]
                for param in doc.parameters()+extra_p:
                    self._get_index_items(param.descr(), link, index)
                    self._get_index_items(param.type(), link, index)
                for fraise in doc.raises():
                    self._get_index_items(fraise.descr(), link, index)
                    
        return index

    #////////////////////////////////////////////////////////////
    # Docstring -> HTML Conversion
    #////////////////////////////////////////////////////////////

    def _index_to_anchor(self, str):
        """
        Given the name of an inline index item, construct a URI anchor.
        These anchors are used to create links from the index page to each
        index item.
        """
        # Include "-" so we don't accidentally collide with the name
        # of a python identifier. 
        return "index-"+re.sub("[^a-zA-Z0-9]", "_", str)
    
    def _dom_to_html(self, tree, container=None, indent=0):
        """
        Given the DOM tree for an epytext string (as returned by
        L{epytext.parse}), return a string encoding it in HTML.  This
        string does not include C{<html>} or C{<body>} tags.
    
        @param tree: The DOM tree for an epytext string.
        @type tree: C{xml.dom.minidom.Element}
        @param container: The container in which to look up objects by name
            (e.g., for link directives).
        @type container: Python module
        """
        if not self._dom_to_html_cache.has_key( (tree,container) ):
            html = self._dom_to_html_helper(tree, container, indent, 0)
            self._dom_to_html_cache[tree, container] = html
        return self._dom_to_html_cache[tree,container]
    
    def _dom_to_html_helper(self, tree, container, indent, seclevel):
        """
        Helper function for L{_dom_to_html}, that does the real work of
        converting a DOM tree for an epytext string to HTML.
    
        @param tree: The DOM tree for an epytext string.
        @type tree: C{xml.dom.minidom.Element}
        @param container: The container in which to look up objects by name
            (e.g., for link directives).
        @type container: Python module
        @param indent: The number of characters indentation that should be
            used for HTML tags.
        @type indent: C{int}
        @param seclevel: The current section level.
        @type seclevel: int
        """
        # This takes care of converting > to &gt;, etc.:
        if isinstance(tree, _Text): return tree.toxml()
    
        if tree.tagName == 'epytext': indent -= 2
        if tree.tagName == 'section': seclevel += 1
    
        # Process the children first.
        children = [self._dom_to_html_helper(c, container, indent+2, seclevel)
                    for c in tree.childNodes]
    
        # Get rid of unnecessary <P>...</P> tags; they introduce extra
        # space on most browsers that we don't want.
        for i in range(len(children)-1):
            if (not isinstance(tree.childNodes[i], _Text) and
                tree.childNodes[i].tagName == 'para' and
                (isinstance(tree.childNodes[i+1], _Text) or
                 tree.childNodes[i+1].tagName != 'para')):
                children[i] = ' '*(indent+2)+children[i][5+indent:-5]+'\n'
        if (tree.hasChildNodes() and
            not isinstance(tree.childNodes[-1], _Text) and
            tree.childNodes[-1].tagName == 'para'):
            children[-1] = ' '*(indent+2)+children[-1][5+indent:-5]+'\n'
    
        # Construct the HTML string for the children.
        childstr = ''.join(children)
    
        # Perform the approriate action for the DOM tree type.
        if tree.tagName == 'para':
            return epytext.wordwrap('<p>%s</p>' % childstr, indent)
        elif tree.tagName == 'code':
            return '<code>%s</code>' % childstr
        elif tree.tagName == 'uri':
            return '<a href="%s">%s</a>' % (children[1], children[0])
        elif tree.tagName == 'link':
            return self._dom_link_to_html(children[1], children[0],
                                          container)
        elif tree.tagName == 'italic':
            return '<i>%s</i>' % childstr
        elif tree.tagName == 'math':
            return '<i class="math">%s</i>' % childstr
        elif tree.tagName == 'index':
            return ('<a name="%s"></a>' % self._index_to_anchor(childstr) +
                    '<i class="indexterm">%s</i>' % childstr)
        elif tree.tagName == 'bold':
            return '<b>%s</b>' % childstr
        elif tree.tagName == 'ulist':
            return '%s<ul>\n%s%s</ul>\n' % (indent*' ', childstr, indent*' ')
        elif tree.tagName == 'olist':
            startAttr = tree.getAttributeNode('start')
            if startAttr: start = ' start="%s"' % startAttr.value
            else: start = ''
            return ('%s<ol%s>\n%s%s</ol>\n' %
                    (indent*' ', start, childstr, indent*' '))
        elif tree.tagName == 'li':
            return indent*' '+'<li>\n%s%s</li>\n' % (childstr, indent*' ')
        elif tree.tagName == 'heading':
            return ('%s<h%s class="heading">%s</h%s>\n' %
                    ((indent-2)*' ', seclevel, childstr, seclevel))
        elif tree.tagName == 'literalblock':
            return '<pre class="literalblock">\n%s\n</pre>\n' % childstr
        elif tree.tagName == 'doctestblock':
            dtb = self._colorize_doctestblock(childstr.strip())
            return '<pre class="doctestblock">\n%s</pre>\n' % dtb
        elif tree.tagName == 'fieldlist':
            raise AssertionError("There should not be any field lists left")
        elif tree.tagName in ('epytext', 'section', 'tag', 'arg',
                              'name', 'target'):
            return childstr
        else:
            print 'Warning: unknown epytext DOM element %r' % tree.tagName
    
    # Construct two regular expressions that are useful for colorizing
    # doctest blocks: _PROMPT_RE and _COLORIZE_RE.
    _KEYWORDS = ["del", "from", "lambda", "return", "and", "or", "is", 
                 "global", "not", "try", "break", "else", "if", "elif", 
                 "while", "class", "except", "import", "pass", "raise",
                 "continue", "finally", "in", "print", "def", "for"]
    _KEYWORD = '|'.join([r'(\b%s\b)' % kw for kw in _KEYWORDS])
    _STRING = '|'.join([r'("""("""|.*?[^\\"]"""))', r'("("|.*?[^\\"]"))',
                        r"('''('''|.*?[^\\']'''))", r"('('|.*?[^\\']'))"])
    _STRING = _STRING.replace('"', '&quot;')
    _COMMENT = '(#.*?$)'
    _PROMPT = r'(^\s*(&gt;&gt;&gt;|\.\.\.)(\s|$))'
    _PROMPT_RE = re.compile(_PROMPT, re.MULTILINE | re.DOTALL)
    _COLORIZE_RE = re.compile('|'.join([_STRING, _COMMENT, _KEYWORD]),
                              re.MULTILINE | re.DOTALL)
    del _KEYWORDS, _KEYWORD, _STRING, _COMMENT
    def _colorize_doctestblock(self, str):
        """
        Do some colorization for a doctest block.  In particular, this
        identifies spans with the following css classes:
          - pysrc: The Python source code
          - pyprompt: The ">>>" and "..." prompts
          - pystring: Strings in the Python source code
          - pycomment: Comments in the Python source code
          - pykeyword: Keywords in the Python source code
          - pyoutput: Python's output (lines without a prompt)
        
        @type str: C{string}
        @param str: The contents of the doctest block to be colorized.
        @rtype: C{string}
        @return: The colorized doctest block.
        """
        PROMPT_RE = HTML_Doc._PROMPT_RE
        COLORIZE_RE = HTML_Doc._COLORIZE_RE
        pysrc = pyout = ''
        outstr = ''
        for line in str.split('\n')+['\n']:
            if PROMPT_RE.match(line):
                if pyout:
                    outstr += ('<span class="pyoutput">%s</span>\n\n' %
                               pyout.strip())
                    pyout = ''
                pysrc += line+'\n'
            else:
                if pysrc:
                    # Prompt over-rides other colors (incl string)
                    pysrc = COLORIZE_RE.sub(self._colorize_match, pysrc)
                    pysrc = PROMPT_RE.sub(r'<span class="pyprompt">'+
                                          r'\1</span>', pysrc)
                    outstr += ('<span class="pysrc">%s</span>\n'
                               % pysrc.strip())
                    pysrc = ''
                pyout += line+'\n'
        if pyout.strip():
            outstr += ('<span class="pyoutput">%s</span>\n' %
                       pyout.strip())
        return outstr.strip()
        
    def _colorize_match(self, match):
        """
        This helper function is used by L{_colorize_doctestblock} to
        add colorization to matching expressions.  It is called by
        C{_COLORIZE_RE.sub} with an expression that matches
        C{_COLORIZE_RE}.

        @return: The HTML code for the colorized expression.
        @rtype: C{string}
        """
        str = match.group()
        if str[:1] == "'" or str[:6] == '&quot;':
            return '<span class="pystring">%s</span>' % str
        elif str[:1] in '#':
            return '<span class="pycomment">%s</span>' % str
        else:
            return '<span class="pykeyword">%s</span>' % str
        
    def _dom_link_to_html(self, target, name, container):
        uid = findUID(target, container, self._docmap)
        if uid is None:
            print ('Warning: could not find UID for %r in %r' %
                   (target, container))
        return self._uid_to_href(uid, name, 'link')
    
    #////////////////////////////////////////////////////////////
    # Helper functions
    #////////////////////////////////////////////////////////////
    
    def _is_private(self, str):
        """
        @return: true if C{str} is the name of a private Python object.
        @rtype: C{boolean}
        """
        str = string.split(str, '.')[-1]
        return (str and str[0]=='_' and str[-1]!='_')
    
    def _find_toplevel(self):
        """
        Try to find a unique module/package for this set of docs.
        Update the member variables L{_package} and L{_module} to
        contain the top-level module/package.
        """
        modules = []
        packages = []
        for (uid, doc) in self._docmap.items():
            if not isinstance(doc, ModuleDoc): continue
            modules.append(uid)
            if doc.ispackage():
                packages.append(uid)

        # Is there a unique module?
        if len(modules) == 0: self._module = None
        elif len(modules) == 1: self._module = modules[0]
        else: self._module = 'multiple'

        # Is there a unique (top-level) package?
        if len(packages) == 0: self._package = None
        else:
            self._package = 'multiple'
            for pkg in packages:
                toplevel = 1
                for p2 in packages:
                    if pkg != p2 and not p2.descendant_of(pkg):
                        toplevel = 0
                if toplevel:
                    self._package = pkg

    def _cmp_name(self, uid1, uid2):
        """
        Compare uid1 and uid2 by their names, using the following rules: 
          - C{'__init__'} < anything.
          - public < private.
          - otherwise, sort alphabetically by name.
    
        @return: -1 if C{uid1<uid2}; 0 if C{uid1==uid2}; and 1 if
            C{uid1>uid2}.
        @rtype: C{int}
        """
        x = uid1.name()
        y = uid2.name()
        if (y == '__init__'): return 1
        if (x == '__init__'): return -1
        if x == y: return 0
        if self._is_private(x) and not self._is_private(y): return 1
        if self._is_private(y) and not self._is_private(x): return -1
        return cmp(x, y)
    
    def _sort(self, docs, sortorder=None):
        """
        Sort and filter a list of C{ObjDoc}s.  In particular, if
        C{sortorder} is not C{None}, then sort according to its
        contents; otherwise, sort using L{_cmp_name}.  If
        L{_show_private} is true, then filter out all private objects;
        otherwise, perform no filtering.

        @param docs: The list of C{ObjDoc}s to be sorted and filtered.
        @type docs: C{list} of L{ObjDoc}
        @param sortorder: A list of object names, typically generated
            from __epydoc__sort__, and returned by {doc.sortorder()},
            where C{doc} is the object that contains the objects
            documented by C{docs}.
        @type sortorder: C{list} of C{string}
        """
        docs = list(docs)

        # First, sort by __epydoc_sort__
        if sortorder is None:
            sortdocs = []
        else:
            sortorder = list(sortorder)
            sortdocs = sortorder[:]
            for doc in docs:
                try: index = sortorder.index(doc.name())
                except ValueError: continue
                sortdocs[index] = doc
            sortdocs = [d for d in sortdocs if type(d) != type('')]
            for doc in sortdocs: docs.remove(doc)
        
        # Then, sort by _cmp_name.
        docs.sort(lambda x,y,s=self: s._cmp_name(x, y))
        if not self._show_private:
            docs = [d for d in docs if not self._is_private(d.name())]

        return sortdocs + docs

    def _header(self, name):
        """
        @return: The HTML code for the header of a page with the given
            name.
        @rtype: C{string}
        """
        return HEADER % (name, self._cssfile)
               
    def _footer(self):
        """
        @return: The HTML code for the footer of a page.
        @rtype: C{string}
        """
        return FOOTER % time.asctime(time.localtime(time.time()))
    
    def _seealso(self, seealso, container):
        """
        @return: The HTML code for the see-also fields.
        """
        if not seealso: return ''
        str = '<dl><dt><b>See also:</b>\n  </dt><dd>'
        for see in seealso:
            str += self._dom_to_html(see, container) + ', '
        return str[:-2] + '</dd>\n</dl>\n\n'

    def _author(self, authors, container):
        """
        @return: The HTML code for the author fields.
        """
        if not authors: return ''
        if len(authors) == 1:
            return ('<p class="author"><b>Author:</b> %s</p>\n\n' %
                    self._dom_to_html(authors[0], container))
        else:
            str = '<p class="author"><b>Authors:</b>\n'
            for author in authors:
                str += '  %s,\n' % self._dom_to_html(author, container)
            return str[:-2] + '\n</p>\n\n'

    def _summary(self, doc, container):
        """
        @return: The HTML code for the summary description of the
            object documented by C{doc}.  A summary description is the
            first sentence of the C{doc}'s 'description' field.  If the
            C{doc} has no 'description' field, but does have a
            'return' field, then the summary is taken from the return
            field instead.
        @rtype: C{string}
        @param doc: The documentation for the object whose summary
            should be returned.
        @type doc: L{objdoc.ObjDoc}
        @param container: The container object for C{doc}, or C{None}
            if there is none.  This container object is used to
            resolve links (E{L}{...}) in the epytext.
        @type container: L{uid.UID}
        """
        descr = doc.descr()

        # Try to find a documented ancestor.
        if isinstance(doc, FuncDoc):
            while (not doc.documented() and
                   doc.overrides() and
                   self._docmap.has_key(doc.overrides())):
                doc = self._docmap[doc.overrides()]

        if descr != None:
            str = self._dom_to_html(epytext.summary(descr), container).strip()
            if str == '': str = '&nbsp;'
            return str
        elif (isinstance(doc, FuncDoc) and
              doc.returns().descr() is not None):
            summary = epytext.summary(doc.returns().descr())
            summary = self._dom_to_html(summary, container).strip()
            summary = summary[:1].lower() + summary[1:]
            return ('Return '+ summary)
        else:
            return '&nbsp;'

    def _link_to_html(self, link):
        """
        @return: The HTML code for the given link.  This code consists
            of an anchor with an href to the page for the link's
            target, and with text taken from the link's name. If the
            target is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type link: L{uid.Link}
        """
        return self._uid_to_href(link.target(), link.name())

    def _uid_to_uri(self, uid):
        """
        @return: a URI that points to the description of the object
            identified by C{uid}.
        @rtype: C{string}
        @param uid: A unique identifier for the object.
        @type uid: L{UID}
        """
        if uid.is_function():
            return '%s.html#%s' % (uid.module(), uid.shortname())
        elif uid.is_method():
            return '%s.html#%s' % (uid.cls(), uid.shortname())
        else:
            return '%s.html' % uid
    
    def _uid_to_href(self, uid, label=None, cls=None):
        """
        @return: The HTML code to link to the given UID.  This code
            consists of an anchor with an href to the page for C{uid}.
            If C{label} is not C{None}, then it is used as the text
            for the link; otherwise, C{uid} is used as the text.  If
            C{uid} is not documented, then the HTML code will just
            contain the name, and no href.
        @rtype: C{string}
        @type uid: L{uid.UID}
        @type label: C{string}
        """
        if label==None: label = `uid`
        parent = '.'.join(`uid`.split('.')[:-1])
        if self._docmap.has_key(uid):
            if cls is None:
                return ('<a href="%s"><code>%s</code></a>' %
                        (self._uid_to_uri(uid), label))
            else:
                return ('<a href="%s" class="%s"><code>%s</code></a>' %
                        (self._uid_to_uri(uid), cls, label))
        elif (uid is not None and uid.object() is None and
              self._docmap.has_key(UID(parent))):
            if cls is None:
                return ('<a href="%s#%s"><code>%s</code></a>' %
                        (self._uid_to_uri(UID(parent)),
                         uid.shortname(), label))
            else:
                return ('<a href="%s#%s" class="%s"><code>%s</code></a>' %
                        (self._uid_to_uri(UID(parent)),
                         uid.shortname(), cls, label))
                         
        else:
            return '<code>%s</code>' % label

    def _start_of(self, heading):
        """
        @return: The HTML code for a 'start-of' comment.  These
            comments are used to deliniate sections of the HTML
            output.
        @rtype: C{string}
        @param heading: The name of the section that is starting.
        @type heading: C{string}
        """
        return '\n<!-- =========== START OF '+string.upper(heading)+\
               ' =========== -->\n'
    
    def _table_header(self, heading, css_class):
        """
        @return: The HTML code for the start of a table.  This is used
            by class tables, function tables, variable tables, etc.
        @rtype: C{string}
        @param heading: The name for the table.
        @type heading: C{string}
        @param css_class: The css class for the table.  This is used
            to allow different tables to be given different styles.
            Currently, the following classes are used: C{'summary'};
            C{'details'}; and C{'index'}.
        """
        return self._start_of(heading)+\
               '<table class="'+css_class+'" border="1" cellpadding="3"' +\
               ' cellspacing="0" width="100%" bgcolor="white">\n' +\
               '<tr bgcolor="#70b0f0" class="'+css_class+'">\n'+\
               '  <th colspan="2">' + heading + '</th></tr>\n'
    
    def _split_classes_and_excepts(self, doc):
        """
        Divide the classes fromt the given module into exceptions and
        non-exceptions.  This is used by L{_module_to_html} to list
        exceptions and non-exceptions separately.

        @param doc: The documentation for the module whose classes
            should be split up.
        @type doc: L{objdoc.ModuleDoc}
        @return: A list C{(I{classes}, I{excepts})}, where
            C{I{classes}} is the list of non-exception classes, and
            C{I{excepts}} is the list of exception classes.
        @rtype: C{pair} of C{list} of C{objdoc.ClassDoc}
        """
        classes = []
        excepts = []
        for link in doc.classes():
            try:
                if (self._docmap.has_key(link.target()) and
                    self._docmap[link.target()].is_exception()):
                    excepts.append(link)
                else:
                    classes.append(link)
            except:
                classes.append(link)
        return (classes, excepts)
        
