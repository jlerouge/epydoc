#
# - warnings & errors?
# - DocstringParser or just module.parse?
#

"""

Markup language support for epydoc.


Each module defines a markup language.
  - name of the module = name of the markup language
  - every module defines a subclass of ParsedDocstring, that handles
    the docstring.
  - every module defines a function parse(docstring)=>ParsedDocstring

Errors & warnings
=================
  - warnings are non-fatal
  - errors are fatal
    - entire docstring is rendered as plaintext

So.. for errors, raise something.
for warnings, just keep in a list?

One error class: ParseError (& subclasses)
  - Error: raise ParseError()
  - Warn: warnings.append(ParseError())

All warnings/errors should be generated by the call to parse()!!
  - xref failure warnings?  resolver handles them, not markup.
"""
__docformat__ = 'epytext en'

##################################################
## Dispatcher
##################################################

def parse(docstring, markup):
    """
    Parse the given docstring, and use it to construct a
    C{ParsedDocstring}.

    @rtype: C{(L{ParsedDocstring}, list of L{ParseError})}
    @return: A tuple C{(M{parsed_docstring}, M{errors})}, where:
      - C{M{parsed_docstring}} is a L{ParsedDocstring} that encodes
        the contents of C{docstring}.
      - C{M{errors}} is a list of L{ParseError}s that lists all of the
        warnings and errors that were encountered when parsing
        C{docstring}.

    @type docstring: C{string}
    @param docstring: The docstring to encode.
    @type markup: C{string}
    @param markup: The name of the markup language that is used by
        the docstring.  If the markup language is not supported, then
        the docstring will be treated as plaintext.  The markup name
        is case-insensitive.
    """
    markup = markup.lower()
    if not re.match(r'\w+', markup):
        return # Bad markup language

    try:
        eval('from %s import parse')
        return parse_docstring(markup)
    except:
        return plaintext.parse_docstring(markup)

##################################################
## Fields
##################################################
class Field:
    """
    The contents of a docstring's field.  Docstring fields are used
    to describe specific aspects of an object, such as a parameter of
    a function or the author of a module.  Each field consists of a
    tag, an optional argument, and a body:
      - The tag specifies the type of information that the field
        encodes.
      - The argument specifies the object that the field describes.
      - The body contains the field's information.
    """
    def __init__(self, tag, arg, body):
        self._tag = tag.lower()
        self._arg = arg
        self._body = body

    def tag(self):
        """
        @return: This field's tag.
        @rtype: C{string}
        """
        return self._tag

    def arg(self):
        """
        @return: This field's argument, or C{None} if this field has
            no argument.
        @rtype: C{string}
        """
        return self._arg

    def body(self):
        """
        @return: This field's body.
        @rtype: L{ParsedDocstring}
        """
        return self._body

##################################################
## ParsedDocstring
##################################################
class ParsedDocstring:
    def split_fields(self):
        """
        Split this docstring into its body and its fields.
        
        @return: A tuple C{(M{body}, M{fields})}, where C{M{body}} is
            the main body of this docstring, and C{M{fields}} is a list
            of its fields.
        @rtype: C{(L{ParsedDocstring}, list of L{Field})}
        """
        raise NotImplementedError, 'ParsedDocstring.split_fields()'

    def summary(self):
        """
        @return: A short summary of this docstring.  Typically, the
            summary consists of the first sentence of the docstring.
        @rtype: L{ParsedDocstring}
        """
        raise NotImplementedError, 'ParsedDocstring.summary()'
        
    def to_html(self, docstring_linker):
        """
        Translate this docstring to HTML.

        @param docstring_linker: An HTML translator for crossreference
            links into and out of the docstring.
        @type docstring_linker: L{DocstringLinker}
        @return: An HTML fragment that encodes this docstring.
        @rtype: C{string}
        """
        return plaintext_to_html(to_plaintext(docstring_linker))

    def to_latex(self, docstring_linker):
        """
        Translate this docstring to LaTeX.
        
        @param docstring_linker: A LaTeX translator for crossreference
            links into and out of the docstring.
        @type docstring_linker: L{DocstringLinker}
        @return: A LaTeX fragment that encodes this docstring.
        @rtype: C{string}
        """
        return plaintext_to_latex(to_plaintext(docstring_linker))

    def to_plaintext(self, docstring_linker):
        """
        Translate this docstring to plaintext.
        
        @param docstring_linker: A plaintext translator for
            crossreference links into and out of the docstring.
        @type docstring_linker: L{DocstringLinker}
        @return: A plaintext fragment that encodes this docstring.
        @rtype: C{string}
        """
        raise NotImplementedError, 'ParsedDocstring.to_plaintext()'

    def warnings(self):
        """
        @return: A list of all warnings that have been
            generated when processing this docstring. 
        """

##################################################
## Docstring Linker (resolves crossreferences)
##################################################
class DocstringLinker: 
    """
    A translator for crossreference links into and out of a
    C{ParsedDocstring}.  C{DocstringLinker} is used by
    C{ParsedDocstring} to convert these crossreference links into
    appropriate output formats.  For example,
    C{DocstringLinker.to_html} expects a C{DocstringLinker} that
    converts crossreference links to HTML.
    """
    def translate_indexterm(self, indexterm):
        """
        Translate an index term to the appropriate output format.  The
        output will typically include a crossreference anchor.

        @type indexterm: C{string}
        @param indexterm: The index term to translate.
        @rtype: C{string}
        @return: The translated index term.
        """
        raise NotImplementedError, 'DocstringLinker.translate_indexterm()'

    def translate_identifier_xref(self, identifier, label=None):
        """
        Translate a crossreference link to a Python identifier to the
        appropriate output format.  The output will typically include
        a reference or pointer to the crossreference target.

        @type identifier: C{string}
        @param identifier: The name of the Python identifier that
            should be linked to.
        @type identifier: C{string} or C{None}
        @param name: The label that should be used for the identifier,
            if it's different from the name of the identifier.
        @rtype: C{string}
        @return: The translated crossreference link.
        """
        raise NotImplementedError, 'DocstringLinker.translate_xref()'

##################################################
## Misc helpers
##################################################
# These are used by multiple markup parsers

def wordwrap(str, indent=0, right=SCRWIDTH, startindex=0):
    """
    Word-wrap the given string.  All sequences of whitespace are
    converted into spaces, and the string is broken up into lines,
    where each line begins with C{indent} spaces, followed by one or
    more (space-deliniated) words whose length is less than
    C{right-indent}.  If a word is longer than C{right-indent}
    characters, then it is put on its own line.

    @param str: The string that should be word-wrapped.
    @type str: C{int}
    @param indent: The left margin of the string.  C{indent} spaces
        will be inserted at the beginning of every line.
    @type indent: C{int}
    @param right: The right margin of the string.
    @type right: C{int}
    @type startindex: C{int}
    @param startindex: The index at which the first line starts.  This
        is useful if you want to include other contents on the first
        line. 
    @return: A word-wrapped version of C{str}.
    @rtype: C{string}
    """
    words = str.split()
    out_str = ' '*(indent-startindex)
    charindex = max(indent, startindex)
    for word in words:
        if charindex+len(word) > right and charindex > 0:
            out_str += '\n' + ' '*indent
            charindex = indent
        out_str += word+' '
        charindex += len(word)+1
    return out_str.rstrip()+'\n'

def plaintext_to_html(str):
    str = str.replace('&', '&amp;')
    str = str.replace('<', '&lt')
    str = str.replace('>', '&gt')
    str = str.replace('"', '&quot')
    return str

def plaintext_to_latex(str, nbsp=0, breakany=0):
    """
    @param breakany: Insert hyphenation marks, so that LaTeX can
    break the resulting string at any point.  This is useful for
    small boxes (e.g., the type box in the variable list table).
    """
    # These get converted to hyphenation points later
    if breakany: str = re.sub('(.)', '\\1\1', str)

    # These get converted to \textbackslash later.
    str = str.replace('\\', '\0')

    # Expand tabs
    str = str.expandtabs()

    # These elements need to be backslashed.
    str = re.sub(r'([#$&%_\${}])', r'\\\1', str)

    # These elements have special names.
    str = str.replace('|', '{\\textbar}')
    str = str.replace('<', '{\\textless}')
    str = str.replace('>', '{\\textgreater}')
    str = str.replace('^', '{\\textasciicircum}')
    str = str.replace('~', '{\\textasciitilde}')
    str = str.replace('\0', r'{\textbackslash}')

    # replace spaces with non-breaking spaces
    if nbsp: str = str.replace(' ', '~')

    # Convert \1's to hyphenation points.
    if breakany: str = str.replace('\1', r'\-')
    
    return str

##################################################
## Foo
##################################################
# For html...
class HTMLDocstringLinker:
    _failed_xrefs = {}
    
    def __init__(self, docformatter, container):
        self._container = container
        self._docformatter = docformatter
        self._docmap = docformatter._docmap

    def translate_identifier_xref(self, identifier, label=None):
        if label is None: label = identifier
        uid = findUID(identifier, container, self._docmap)
        if uid is None:
            self._failed_xrefs[identifier] = 1
        return self._docformatter._uid_to_href(uid, label, 'link')

    def translate_indexterm(self, indexterm):
        anchor = self._docformatter._term_index_to_anchor(indexterm)
        return ('<a name="%s"></a><i class="indexterm">%s</i>' %
                (anchor, childstr))
    
    def report_failed_xrefs(self):
        failed_xrefs = self._failed_xrefs.keys()
        if failed_xrefs:
            if sys.stderr.softspace: print >>sys.stderr

            if len(failed_xrefs) == 1:
                estr = 'could not find a UID for: ' + failed_xrefs[0]
            else:
                estr = 'could not find UIDs for: ' + ', '.join(failed_xrefs)
            print >>sys.stderr, estr
