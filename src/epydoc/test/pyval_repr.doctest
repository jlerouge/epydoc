Regression Testing for epydoc.markup.pyval_repr
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    >>> from epydoc.markup.pyval_repr import *
    >>> colorizer = PyvalColorizer(linelen=40)
    >>> def color(s): print colorizer.colorize(s).to_html(None).rstrip()

Simple Types
============
Integers, floats, None, and complex numbers get printed using str,
with no syntax highlighting:

    >>> color(10)
    <code class="pyval">10</code>
    >>> color(1./4)
    <code class="pyval">0.25</code>
    >>> color(None)
    <code class="pyval">None</code>
    >>> color(100)
    <code class="pyval">100</code>

Long ints will get wrapped if they're big enough:
    
    >>> color(10000000)
    <code class="pyval">10000000</code>
    >>> color(10**90)
    <code class="pyval">1000000000000000000000000000000000000000&crarr;
    0000000000000000000000000000000000000000&crarr;
    00000000000</code>
    >>> print '-'*40+'\n'+colorizer.colorize(10**90).to_plaintext(None)
    ----------------------------------------
    1000000000000000000000000000000000000000\
    0000000000000000000000000000000000000000\
    00000000000

Strings
=======
Strings have their quotation marks tagged as 'quote'.  Characters are
escaped using the 'string-escape' encoding.  

    >>> color(''.join(chr(i) for i in range(256)))
    <code class="pyval"><code class="val-quote">'''</code><code class="val-string">\x00\x01\x02\x03\x04\x05\x06\x07\x08\</code>&crarr;
    <code class="val-string">t</code>
    <code class="val-string">\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x</code>&crarr;
    <code class="val-string">15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x</code>&crarr;
    <code class="val-string">1f !&quot;#$%&amp;\'()*+,-./0123456789:;&lt;=&gt;?@ABCD</code>&crarr;
    <code class="ellipsis">...</code></code>
    
Currently, the "'" quote is always used, because that's what the
'string-escape' encoding expects.

    >>> color('Hello')
    <code class="pyval"><code class="val-quote">'</code><code class="val-string">Hello</code><code class="val-quote">'</code></code>
    >>> color('"Hello"')
    <code class="pyval"><code class="val-quote">'</code><code class="val-string">&quot;Hello&quot;</code><code class="val-quote">'</code></code>
    >>> color("'Hello'")
    <code class="pyval"><code class="val-quote">'</code><code class="val-string">\'Hello\'</code><code class="val-quote">'</code></code>

Strings containing newlines are automatically rendered as multiline
strings.

    >>> color("This\n  is a multiline\n string!")
    <code class="pyval"><code class="val-quote">'''</code><code class="val-string">This</code>
    <code class="val-string">  is a multiline</code>
    <code class="val-string"> string!</code><code class="val-quote">'''</code></code>

Unicode strings are handled properly.

    >>> color(u"Hello world")
    <code class="pyval"><code class="val-quote">u'</code><code class="val-string">Hello world</code><code class="val-quote">'</code></code>
    >>> color(u"\uaaaa And \ubbbb")
    <code class="pyval"><code class="val-quote">u'</code><code class="val-string">\uaaaa And \ubbbb</code><code class="val-quote">'</code></code>

Lists, Tuples, etc.
===================
Lists, tuples, and sets are all colorized using the same method.  The
braces and commas are tagged with "op".  If the value can fit on the
current line, it is displayed on one line.  Otherwise, each value is
listed on a separate line, indented by the size of the open-bracket.
    
    >>> color(range(10))
    <code class="pyval"><code class="val-group">[</code>0<code class="val-op">, </code>1<code class="val-op">, </code>2<code class="val-op">, </code>3<code class="val-op">, </code>4<code class="val-op">, </code>5<code class="val-op">, </code>6<code class="val-op">, </code>7<code class="val-op">, </code>8<code class="val-op">, </code>9<code class="val-group">]</code></code>
    >>> color(range(100))
    <code class="pyval"><code class="val-group">[</code>0<code class="val-op">,</code>
     1<code class="val-op">,</code>
     2<code class="val-op">,</code>
     3<code class="val-op">,</code>
     4<code class="val-op">,</code>
    <code class="ellipsis">...</code></code>
    >>> color([1,2,[5,6,[(11,22,33),9],10],11]+[99,98,97,96,95])
    <code class="pyval"><code class="val-group">[</code>1<code class="val-op">,</code>
     2<code class="val-op">,</code>
     <code class="val-group">[</code>5<code class="val-op">, </code>6<code class="val-op">, </code><code class="val-group">[</code><code class="val-group">(</code>11<code class="val-op">, </code>22<code class="val-op">, </code>33<code class="val-group">)</code><code class="val-op">, </code>9<code class="val-group">]</code><code class="val-op">, </code>10<code class="val-group">]</code><code class="val-op">,</code>
     11<code class="val-op">,</code>
     99<code class="val-op">,</code>
    <code class="ellipsis">...</code></code>
    >>> color(set(range(20)))
    <code class="pyval"><code class="val-group">set([</code>0<code class="val-op">,</code>
         1<code class="val-op">,</code>
         2<code class="val-op">,</code>
         3<code class="val-op">,</code>
         4<code class="val-op">,</code>
    <code class="ellipsis">...</code></code>

Dictionaries
============
Dicts are treated just like lists, except that the ":" is also tagged as
"op".

    >>> color({1:33, 2:[1,2,3,{7:'oo'*20}]})
    <code class="pyval"><code class="val-group">{</code>1<code class="val-op">: </code>33<code class="val-op">,</code>
     2<code class="val-op">: </code><code class="val-group">[</code>1<code class="val-op">,</code>
         2<code class="val-op">,</code>
         3<code class="val-op">,</code>
         <code class="val-group">{</code>7<code class="val-op">: </code><code class="val-quote">'</code><code class="val-string">oooooooooooooooooooooooooooooo</code>&crarr; 
    <code class="ellipsis">...</code></code>

Regular Expressions
===================

    >>> def textcontent(elt):
    ...     if isinstance(elt, basestring): return elt
    ...     else: return ''.join(textcontent(c) for c in elt.children)

    >>> import re
    >>> def color_re(s, check_roundtrip=True):
    ...     val = colorizer.colorize(re.compile(s))
    ...     if check_roundtrip:
    ...         assert textcontent(val._tree) == s, val._tree
    ...     print val.to_html(None).rstrip()

    >>> # Literal characters
    >>> color_re(u'abc \t\r\n\f\v \xff \uffff \U000fffff', False)
    <code class="pyval">abc \t\r\n\f\v \xff \uffff \U000fffff</code>
    >>> color_re(r'\.\^\$\\\*\+\?\{\}\[\]\|\(\)')
    <code class="pyval">\.\^\$\\\*\+\?\{\}\[\]\|\(\)</code>

    >>> # Any character & character classes
    >>> color_re(r".\d\D\s\S\w\W\A^$\b\B\Z")
    <code class="pyval">.\d\D\s\S\w\W\A^$\b\B\Z</code>

    >>> # Branching
    >>> color_re(r"foo|bar")
    <code class="pyval">foo<code class="re-op">|</code>bar</code>

    >>> # Character classes
    >>> color_re(r"[abcd]")
    <code class="pyval"><code class="re-group">[</code>abcd<code class="re-group">]</code></code>

    >>> # Repeats
    >>> color_re(r"a*b+c{4,}d{,5}e{3,9}f?")
    <code class="pyval">a<code class="re-op">*</code>b<code class="re-op">+</code>c<code class="re-op">{4,}</code>d<code class="re-op">{,5}</code>e<code class="re-op">{3,9}</code>f<code class="re-op">?</code></code>
    >>> color_re(r"a*?b+?c{4,}?d{,5}?e{3,9}?f??")
    <code class="pyval">a<code class="re-op">*?</code>b<code class="re-op">+?</code>c<code class="re-op">{4,}?</code>d<code class="re-op">{,5}?</code>e<code class="re-op">{3,9}?</code>f<code class="re-op">??</code></code>
    
    >>> # Subpatterns
    >>> color_re(r"(foo (bar) | (baz))")
    <code class="pyval"><code class="re-group">(</code>foo <code class="re-group">(</code>bar<code class="re-group">)</code> <code class="re-op">|</code> <code class="re-group">(</code>baz<code class="re-group">)</code><code class="re-group">)</code></code>
    >>> color_re(r"(?:foo (?:bar) | (?:baz))")
    <code class="pyval"><code class="re-group">(?:</code>foo <code class="re-group">(?:</code>bar<code class="re-group">)</code> <code class="re-op">|</code> <code class="re-group">(?:</code>baz<code class="re-group">)</code><code class="re-group">)</code></code>
    >>> color_re("(foo (?P<a>bar) | (?P<boop>baz))")
    <code class="pyval"><code class="re-group">(</code>foo <code class="re-group">(?P&lt;</code><code class="re-ref">a</code><code class="re-group">&gt;</code>bar<code class="re-group">)</code> <code class="re-op">|</code> <code class="re-group">(?P&lt;</code><code class="re-ref">boop</code><code class="re-group">&gt;</code>baz<code class="re-group">)</code><code class="re-group">)</code></code>

    >>> # Group References
    >>> color_re(r"(...) and (\1)")
    <code class="pyval"><code class="re-group">(</code>...<code class="re-group">)</code> and <code class="re-group">(</code><code class="re-ref">\1</code><code class="re-group">)</code></code>

    >>> # Ranges
    >>> color_re(r"[a-bp-z]")
    <code class="pyval"><code class="re-group">[</code>a<code class="re-op">-</code>bp<code class="re-op">-</code>z<code class="re-group">]</code></code>
    >>> color_re(r"[^a-bp-z]")
    <code class="pyval"><code class="re-group">[</code><code class="re-op">^</code>a<code class="re-op">-</code>bp<code class="re-op">-</code>z<code class="re-group">]</code></code>
    >>> color_re(r"[^abc]")
    <code class="pyval"><code class="re-group">[</code><code class="re-op">^</code>abc<code class="re-group">]</code></code>

    >>> # Lookahead/behinds
    >>> color_re(r"foo(?=bar)")
    <code class="pyval">foo<code class="re-group">(?=</code>bar<code class="re-group">)</code></code>
    >>> color_re(r"foo(?!bar)")
    <code class="pyval">foo<code class="re-group">(?!</code>bar<code class="re-group">)</code></code>
    >>> color_re(r"(?<=bar)foo")
    <code class="pyval"><code class="re-group">(?&lt;=</code>bar<code class="re-group">)</code>foo</code>
    >>> color_re(r"(?<!bar)foo")
    <code class="pyval"><code class="re-group">(?&lt;!</code>bar<code class="re-group">)</code>foo</code>

    >>> # Flags
    >>> color_re(r"(?im)^Food")
    <code class="pyval"><code class="re-flags">(?im)</code>^Food</code>
    >>> color_re(r"(?Limsx)^Food")
    <code class="pyval"><code class="re-flags">(?Limsx)</code>^Food</code>
    >>> color_re(r"(?Limstux)^Food")
    <code class="pyval"><code class="re-flags">(?Limstux)</code>^Food</code>
    >>> color_re(r"(?x)This   is   verbose", False)
    <code class="pyval"><code class="re-flags">(?x)</code>Thisisverbose</code>

Representation Scores
=====================
When colorized representations are built, a score is computed
evaluating how helpful the repr is.  E.g., unhelpful values like `<Foo
instance at 0x12345>` get low scores.  Currently, the scoring
algorithm is:

- [+1] for each object colorized.  When the colorizer recurses into
  a structure, this will add one for each element contained.
- [-5] when repr(obj) looks like <xyz instance at ...>, for any
  colorized object (including objects in structures).
- [-100] if repr(obj) raises an exception, for any colorized object
  (including objects in structures).

The `min_score` arg to colorize can be used to set a cutoff-point for
scores; if the score is too low, then `colorize` will return `None`.

    >>> def color2(v):
    ...     pds, score = colorizer.colorize_and_score(v)
    ...     print 'repr: %s' % pds.to_plaintext(None)
    ...     print 'score: %s (%s)' % (score, score>0 and 'ok' or 'bad')

    >>> class A: pass

    >>> color2('hello')
    repr: 'hello'
    score: 1 (ok)

    >>> color2(["hello", 123])
    repr: ['hello', 123]
    score: 3 (ok)

    >>> color2(A())
    repr: <__builtin__.A instance at ...>
    score: -4 (bad)

    >>> color2([A()])
    repr: [<__builtin__.A instance at ...>]
    score: -3 (bad)

    >>> color2([A(),1,2,3,4,5,6])
    repr: [<__builtin__.A instance at ...>,
     1,
     2,
     3,
     4,
    ...
    score: 1 (ok)

