# epydoc -- API documentation merging
#
# Copyright (C) 2005 Edward Loper
# Author: Edward Loper <edloper@loper.org>
# URL: <http://epydoc.sf.net>
#
# $Id$

"""
Merge API documentation information that was obtained from inspection
with information that was obtained from parsing.

L{DocMerger} is a processing class that takes two C{APIDoc} objects
that describe the same value or variable, and returns an C{APIDoc}
object that combines the information that they contain.

C{DocMerger} can be subclassed to change the way that it combines API
documentation information.
"""

######################################################################
## Imports
######################################################################

# API documentation encoding:
from epydoc.apidoc import *
from epydoc import log
from sets import Set

######################################################################
## Doc Merger
######################################################################

class DocMerger:
    """
    A processing class that merges API documentation information that
    was obtained from inspection with information that was obtained
    from parsing.  The L{merge()} method takes two C{APIDoc} objects
    that describe the same value or variable (one generated by parsing
    and one generated by inspection); and returns an C{APIDoc} object
    that combines the information that they contain.

    Subclassing
    ===========
    C{DocMerger} can be subclassed to change the way that it combines
    API documentation information.  C{DocMerger} can be extended in
    several different ways:

      - The variables L{PRECEDENCE} and L{DEFAULT_PRECEDENCE} can
        be overridden to change the precedence given to different
        API documentation attributes.
        
      - Special handlers can be defined for merging specific
        attributes by defining methods named C{merge_M{name}}, where
        C{M{name}} is the name of the attribute.
    """
    PRECEDENCE = {
        'repr': 'parse',
        'canonical_name': 'inspect', # hmm.. change this? [xx]
        'is_imported': 'parse',
        'is_alias': 'parse',
        'docformat': 'parse',
        'is_package': 'parse',
        'sort_spec': 'parse',
        'subpackages': 'inspect',
        'filename': 'parse',
        }
    DEFAULT_PRECEDENCE = 'inspect'

    def merge(self, inspect_doc, parse_doc):
        if inspect_doc.canonical_name not in (None, UNKNOWN):
            path = '%s' % inspect_doc.canonical_name
        elif parse_doc.canonical_name not in (None, UNKNOWN):
            path = '%s' % parse_doc.canonical_name
        else:
            path = '??'
        return self._merge(inspect_doc, parse_doc, Set(), path)

#     def _merge(self, inspect_doc, parse_doc, cyclecheck, path):
#         print '%-50s>>%r %r' % (path, inspect_doc, parse_doc)
#         val = self.__merge(inspect_doc, parse_doc, cyclecheck, path)
#         print '%-50s<<%r' % (path, val)
#         return val
        
    def _merge(self, inspect_doc, parse_doc, cyclecheck, path):
        assert isinstance(inspect_doc, APIDoc)
        assert isinstance(parse_doc, APIDoc)

        # If we've already examined this pair, then there's nothing
        # more to do.  The reason that we check id's here is that we
        # want to avoid hashing the APIDoc objects for now, so we can
        # use APIDoc.merge_and_overwrite() later.
        if (id(inspect_doc), id(parse_doc)) in cyclecheck:
            return inspect_doc
        cyclecheck.add( (id(inspect_doc), id(parse_doc)) )

        # If these two are already merged, then we're done.  (Two
        # APIDoc's compare equal iff they are identical or have been
        # merged.)
        if inspect_doc == parse_doc:
            return inspect_doc

        # Perform several sanity checks here -- if we accidentally
        # merge values that shouldn't get merged, then bad things can
        # happen.
        mismatch = None
        if (inspect_doc.__class__ != parse_doc.__class__ and
            not (issubclass(inspect_doc.__class__, parse_doc.__class__) or
                 issubclass(parse_doc.__class__, inspect_doc.__class__))):
            mismatch = ("value types don't match -- i=%r, p=%r." %
                        (inspect_doc.__class__, parse_doc.__class__))
        if (isinstance(inspect_doc, ValueDoc) and
            isinstance(parse_doc, ValueDoc)):
            if (inspect_doc.pyval is not UNKNOWN and
                parse_doc.pyval is not UNKNOWN and
                inspect_doc.pyval is not parse_doc.pyval):
                mismatch = "values don't match."
            elif (inspect_doc.canonical_name not in (None, UNKNOWN) and
                parse_doc.canonical_name not in (None, UNKNOWN) and
                inspect_doc.canonical_name != parse_doc.canonical_name):
                mismatch = "canonical names don't match."
        if mismatch is not None:
            log.info("Not merging the parsed & inspected values of %s, "
                     "since their %s" % (path, mismatch))
            if self.DEFAULT_PRECEDENCE == 'inspect':
                return inspect_doc
            else:
                return parse_doc

        # If one apidoc's class is a superclass of the other's, then
        # specialize it to the more specific class.
        if inspect_doc.__class__ is not parse_doc.__class__:
            if issubclass(inspect_doc.__class__, parse_doc.__class__):
                parse_doc.specialize_to(inspect_doc.__class__)
            if issubclass(parse_doc.__class__, inspect_doc.__class__):
                inspect_doc.specialize_to(parse_doc.__class__)
        assert inspect_doc.__class__ is parse_doc.__class__

        # The posargs and defaults are tied together -- if we merge
        # the posargs one way, then we need to merge the defaults the
        # same way.  So check them first.  (This is a minor hack)
        if (isinstance(inspect_doc, RoutineDoc) and
            isinstance(parse_doc, RoutineDoc)):
            self._merge_posargs_and_defaults(inspect_doc, parse_doc, path)
        
        # Merge the two api_doc's attributes.
        for attrib in Set(inspect_doc.__dict__.keys() +
                          parse_doc.__dict__.keys()):
            # Be sure not to merge any private attributes (especially
            # __mergeset or __has_been_hashed!)
            if attrib.startswith('_'): continue
            self.merge_attribute(attrib, inspect_doc, parse_doc,
                                 cyclecheck, path)

        # Set the dictionaries to be shared.
        return inspect_doc.merge_and_overwrite(parse_doc)

    def merge_attribute(self, attrib, inspect_doc, parse_doc,
                        cyclecheck, path):
        precedence = self.PRECEDENCE.get(attrib, self.DEFAULT_PRECEDENCE)
        if precedence not in ('parse', 'inspect'):
            raise ValueError('Bad precedence value %r' % precedence)
        
        if (getattr(inspect_doc, attrib) is UNKNOWN and
            getattr(parse_doc, attrib) is not UNKNOWN):
            setattr(inspect_doc, attrib, getattr(parse_doc, attrib))
        elif (getattr(inspect_doc, attrib) is not UNKNOWN and
              getattr(parse_doc, attrib) is UNKNOWN):
            setattr(parse_doc, attrib, getattr(inspect_doc, attrib))
        elif (getattr(inspect_doc, attrib) is UNKNOWN and
              getattr(parse_doc, attrib) is UNKNOWN):
            pass
        else:
            # Both APIDoc objects have values; we need to merge them.
            inspect_val = getattr(inspect_doc, attrib)
            parse_val = getattr(parse_doc, attrib)
            if hasattr(self, 'merge_%s' % attrib):
                handler = getattr(self, 'merge_%s' % attrib)
                merged_val = handler(inspect_val, parse_val, precedence,
                                     cyclecheck, path)
            elif precedence == 'inspect':
                merged_val = inspect_val
            elif precedence == 'parse':
                merged_val = parse_val

            setattr(inspect_doc, attrib, merged_val)
            setattr(parse_doc, attrib, merged_val)

    def merge_variables(self, varlist1, varlist2, precedence,
                        cyclecheck, path):
        # Merge all variables that are in both sets.
        for varname, var1 in varlist1.items():
            if varname in varlist2:
                var2 = varlist2[varname]
                var = self._merge(var1, var2, cyclecheck, path+'.'+varname)
                varlist1[varname] = var
                varlist2[varname] = var

        # Copy any variables that are not in varlist1 over.
        for varname, var in varlist2.items():
            varlist1.setdefault(varname, var)

        return varlist1

    def merge_value(self, value1, value2, precedence, cyclecheck, path):
        if value1 is None and value2 is None:
            return None
        elif value1 is None or value2 is None:
            if precedence == 'inspect': return value1
            else: return value2
        elif value1 is UNKNOWN:
            return value2
        elif value2 is UNKNOWN:
            if precedence == 'inspect': return value1
            else: return value2
        else:
            return self._merge(value1, value2, cyclecheck, path)

    # [xx] are these really necessary or useful??
#     def merge_package(self, v1, v2, precedence, cyclecheck, path):
#         return self.merge_value(v1, v2, precedence, cyclecheck,
#                                 path+'.<package>')
#     def merge_container(self, v1, v2, precedence, cyclecheck, path):
#         return self.merge_value(v1, v2, precedence, cyclecheck,
#                                 path+'.<container>')
    def merge_overrides(self, v1, v2, precedence, cyclecheck, path):
        return self.merge_value(v1, v2, precedence, cyclecheck,
                                path+'.<overrides>')
    def merge_fget(self, v1, v2, precedence, cyclecheck, path):
        return self.merge_value(v1, v2, precedence, cyclecheck,
                                path+'.fget')
    def merge_fset(self, v1, v2, precedence, cyclecheck, path):
        return self.merge_value(v1, v2, precedence, cyclecheck,
                                path+'.fset')
    def merge_fdel(self, v1, v2, precedence, cyclecheck, path):
        return self.merge_value(v1, v2, precedence, cyclecheck,
                                path+'.fdel')

    def _merge_posargs_and_defaults(self, inspect_doc, parse_doc, path):
        # If either is unknown, then let merge_attrib handle it.
        if inspect_doc.posargs == UNKNOWN or parse_doc.posargs == UNKNOWN:
            return 
            
        # If the inspected doc just has '...', then trust the parsed doc.
        if inspect_doc.posargs == ['...'] and parse_doc.posargs != ['...']:
            inspect_doc.posargs = parse_doc.posargs
            inspect_doc.posarg_defaults = parse_doc.posarg_defaults

        # If they are incompatible, then check the precedence.
        elif inspect_doc.posargs != parse_doc.posargs:
            log.info("Warning: Not merging the parsed & inspected arg "
                     "lists for %s, since they don't match (%s vs %s)"
                      % (path, inspect_doc.posargs, parse_doc.posargs))
            if (self.PRECEDENCE.get('posargs', self.DEFAULT_PRECEDENCE) ==
                'inspect'):
                parse_doc.posargs = inspect_doc.posargs
                parse_doc.posarg_defaults = inspect_doc.posarg_defaults
            else:
                inspect_doc.posargs = parse_doc.posargs
                inspect_doc.posarg_defaults = parse_doc.posarg_defaults

    def merge_imported_from(self, v1, v2, precedence, cyclecheck, path):
        # Anything we got from inspection shouldn't have an imported_from
        # attribute -- it should be the actual object's documentation.
        assert v1 is None
        return None

    def merge_bases(self, baselist1, baselist2, precedence, cyclecheck, path):
        # Be careful here -- if we get it wrong, then we could end up
        # merging two unrelated classes, which could lead to bad
        # things (e.g., a class that's its own subclass).  So only
        # merge two bases if we're quite sure they're the same class.
        # (In particular, if they have the same canonical name.)

        # If the lengths don't match up, then give up.  This is most
        # often caused by __metaclass__.
        if len(baselist1) != len(baselist2):
            log.info("Warning: Not merging the inspected & parsed base lists "
                     "for %s, since their lengths don't match (%s vs %s)" %
                     (path, len(baselist1), len(baselist2)))
            if precedence == 'inspect': return baselist1
            else: return baselist2

        # If any names disagree, then give up.
        for base1, base2 in zip(baselist1, baselist2):
            if ((base1.canonical_name not in (None, UNKNOWN) and
                 base2.canonical_name not in (None, UNKNOWN)) and
                base1.canonical_name != base2.canonical_name):
                log.info("Warning: Not merging the parsed & inspected base "
                         "lists for %s, since the bases' names don't match "
                         "(%s vs %s)" % (path, base1.canonical_name,
                                         base2.canonical_name))
                if precedence == 'inspect': return baselist1
                else: return baselist2

        for i, (base1, base2) in enumerate(zip(baselist1, baselist2)):
            base = self._merge(base1, base2, cyclecheck,
                               '%s.__bases__[%d]' % (path, i))
            baselist1[i] = baselist2[i] = base

        return baselist1

    def merge_posarg_defaults(self, defaults1, defaults2, precedence,
                              cyclecheck, path):
        if len(defaults1) != len(defaults2):
            if precedence == 'inspect': return defaults1
            else: return defaults2
        defaults = []
        for i, (d1, d2) in enumerate(zip(defaults1, defaults2)):
            if d1 is not None and d2 is not None:
                d_path = '%s.<default-arg-val>[%d]' % (path, i)
                defaults.append(self._merge(d1, d2, cyclecheck, d_path))
            elif precedence == 'inspect':
                defaults.append(d1)
            else:
                defaults.append(d2)
        return defaults

    
