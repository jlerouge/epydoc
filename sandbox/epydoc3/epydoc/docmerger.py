# epydoc -- API documentation merging
#
# Copyright (C) 2005 Edward Loper
# Author: Edward Loper <edloper@loper.org>
# URL: <http://epydoc.sf.net>
#
# $Id$

"""
Merge API documentation information that was obtained from inspection
with information that was obtained from parsing.

L{DocMerger} is a processing class that takes two C{APIDoc} objects
that describe the same value or variable, and returns an C{APIDoc}
object that combines the information that they contain.

C{DocMerger} can be subclassed to change the way that it combines API
documentation information.
"""

######################################################################
## Imports
######################################################################

# API documentation encoding:
from epydoc.apidoc import *
from sets import Set

######################################################################
## Doc Merger
######################################################################

class DocMerger:
    """
    A processing class that merges API documentation information that
    was obtained from inspection with information that was obtained
    from parsing.  The L{merge()} method takes two C{APIDoc} objects
    that describe the same value or variable (one generated by parsing
    and one generated by inspection); and returns an C{APIDoc} object
    that combines the information that they contain.

    Subclassing
    ===========
    C{DocMerger} can be subclassed to change the way that it combines
    API documentation information.  C{DocMerger} can be extended in
    several different ways:

      - The variables L{PRECEDENCE} and L{DEFAULT_PRECEDENCE} can
        be overridden to change the precedence given to different
        API documentation attributes.
        
      - Special handlers can be defined for merging specific
        attributes by defining methods named C{merge_M{name}}, where
        C{M{name}} is the name of the attribute.
    """
    PRECEDENCE = {
        'repr': 'parse',
        'canonical_name': 'inspect',
        'is_imported': 'parse',
        'is_alias': 'parse',
        'docformat': 'parse',
        'is_package': 'parse',
        'sorted_variables': 'parse',
        }
    DEFAULT_PRECEDENCE = 'inspect'

    def merge(self, inspect_doc, parse_doc):
        return self._merge(inspect_doc, parse_doc, Set())

    def _merge(self, inspect_doc, parse_doc, cyclecheck):
        assert isinstance(inspect_doc, APIDoc)
        assert isinstance(parse_doc, APIDoc)

        if (inspect_doc, parse_doc) in cyclecheck:
            return inspect_doc
        cyclecheck.add( (inspect_doc, parse_doc) )

        # If the types don't match, then discard whichever APIDoc is
        # disfavored by DEFAULT_PRECEDENCE.
        if inspect_doc.__class__ is not parse_doc.__class__:
            # They can't be coerced; throw away whatever is
            # disfavored by DEFAULT_PRECEDENCE.
            if self.DEFAULT_PRECEDENCE == 'inspect':
                parse_doc.__class__ = inspect_doc.__class__
                parse_doc.__dict__ = inspect_doc.__dict__
                return inspect_doc
            else:
                inspect_doc.__class__ = parse_doc.__class__
                inspect_doc.__dict__ = parse_doc.__dict__
                return inspect_doc

        # If these two are already merged, then we're done.  We can
        # tell if they're merged by checking if they share a __dict__.
        if inspect_doc.__dict__ is parse_doc.__dict__:
            return inspect_doc

        # Merge the two apidoc's attributes.
        for attrib in Set(inspect_doc.__dict__.keys() +
                          parse_doc.__dict__.keys()):
            self.merge_attribute(attrib, inspect_doc, parse_doc, cyclecheck)
            
        # Set the dictionaries to be shared
        parse_doc.__dict__ = inspect_doc.__dict__
        return inspect_doc

    def merge_attribute(self, attrib, inspect_doc, parse_doc, cyclecheck):
        precedence = self.PRECEDENCE.get(attrib, self.DEFAULT_PRECEDENCE)
        if precedence not in ('parse', 'inspect'):
            raise ValueError('Bad precedence value %r' % precedence)
        
        if (getattr(inspect_doc, attrib) is UNKNOWN and
            getattr(parse_doc, attrib) is not UNKNOWN):
            setattr(inspect_doc, attrib, getattr(parse_doc, attrib))
        elif (getattr(inspect_doc, attrib) is not UNKNOWN and
              getattr(parse_doc, attrib) is UNKNOWN):
            pass
        else:
            # Both APIDoc objects have values; we need to merge them.
            inspect_val = getattr(inspect_doc, attrib)
            parse_val = getattr(parse_doc, attrib)
            if hasattr(self, 'merge_%s' % attrib):
                handler = getattr(self, 'merge_%s' % attrib)
                merged_val = handler(inspect_val, parse_val, precedence,
                                     cyclecheck)
            elif precedence == 'inspect':
                merged_val = inspect_val
            elif precedence == 'parse':
                merged_val = parse_val

            setattr(inspect_doc, attrib, merged_val)
            setattr(parse_doc, attrib, merged_val)

    def merge_variables(self, varlist1, varlist2, precedence, cyclecheck):
        # Merge all variables that are in both sets.
        for varname, var1 in varlist1.items():
            if varname in varlist2:
                var2 = varlist2[varname]
                self._merge(var1, var2, cyclecheck)

        # Copy any variables that are not in varlist1 over.
        for varname, var in varlist2.items():
            varlist1.setdefault(varname, var)

        return varlist1
    merge_local_variables = merge_variables

    def merge_value(self, value1, value2, precedence, cyclecheck):
        if value1 is None and value2 is None:
            return None
        elif value1 is None or value2 is None:
            if precedence == 'inspect': return value1
            else: return value2
        elif value1 is UNKNOWN:
            return value2
        elif value2 is UNKNOWN:
            if precedence == 'inspect': return value1
            else: return value2
        else:
            self._merge(value1, value2, cyclecheck)
            return value1
    merge_package = merge_value
    merge_container = merge_value
    merge_overrides = merge_value
    merge_fget = merge_value
    merge_fset = merge_value
    merge_fdel = merge_value

    def merge_bases(self, baselist1, baselist2, precedence, cyclecheck):
        if len(baselist1) != len(baselist2):
            print 'Warning: base list length mismatch'
            if precedence == 'inspect': return baselist1
            else: return baselist2
        for base1, base2 in zip(baselist1, baselist2):
            self._merge(base1, base2, cyclecheck)
        return baselist1

    def merge_posargs(self, args1, args2, precedence, cyclecheck):
        if len(args1) != len(args2):
            print 'Warning: arg list mismatch'
        if precedence == 'inspect': return args1
        else: return args2

    def merge_posarg_defaults(self, defaults1, defaults2, precedence,
                              cyclecheck):
        if len(defaults1) != len(defaults2):
            print 'Warning: arg list mismatch'
            if precedence == 'inspect': return defaults1
            else: return defaults2
        defaults = []
        for d1, d2 in zip(defaults1, defaults2):
            if d1 is not None and d2 is not None:
                defaults.append(self._merge(d1, d2, cyclecheck))
            elif precedence == 'inspect':
                defaults.append(d1)
            else:
                defaults.append(d2)
        return defaults

    
