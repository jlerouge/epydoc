                 Regression Testing for epydoc.docinspector
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DocInspector is a processing class that extracts API documentation by
inspecting Python objects directy.  Its primary interface is
`inspect()`, which takes a Python object, and returns a `ValueDoc`
describing that value.

Test Function
=============
This test function takes a string containing the contents of a module.
It writes the string contents to a file, imports the file as a module,
and uses a DocInspector to inspect it, and pretty prints the resulting
ModuleDoc object.  The `attribs` argument specifies which attributes
of the `APIDoc`s should be displayed.  The `inspect` argument gives the
name of a variable in the module whose value should be inspected,
instead of inspecting the whole module.

    >>> import tempfile, re, os, os.path, textwrap, sys
    >>> from epydoc.docinspector import DocInspector
    >>> def runinspector(s, attribs='', doc_inspector=None, inspect=None):
    ...     if doc_inspector is None:
    ...         doc_inspector = DocInspector()
    ...     # Write it to a temp file.
    ...     tmp_dir = tempfile.mkdtemp()
    ...     out = open(os.path.join(tmp_dir, 'epydoc_test.py'), 'w')
    ...     out.write(textwrap.dedent(s))
    ...     out.close()
    ...     # Import it.
    ...     sys.path.insert(0, tmp_dir)
    ...     if inspect is None:
    ...         import epydoc_test as val
    ...     else:
    ...         exec("from epydoc_test import %s as val" % inspect)
    ...     del sys.path[0]
    ...     # Inspect it.
    ...     val_doc = doc_inspector.inspect(val)
    ...     # Display it.
    ...     s = val_doc.pp(include=attribs.split())
    ...     s = re.sub(r"(filename = ).*", r"\1...", s)
    ...     s = re.sub(r"(<module 'epydoc_test' from ).*", r'\1...', s)
    ...     s = re.sub(r"(<function \w+ at )0x\w+>", r"\1...>", s)
    ...     s = re.sub(r"(<\w+ object at )0x\w+>", r"\1...>", s)
    ...     print s
    ...     # Clean up.
    ...     os.unlink(os.path.join(tmp_dir, 'epydoc_test.py'))
    ...     try: os.unlink(os.path.join(tmp_dir, 'epydoc_test.pyc'))
    ...     except OSError: pass
    ...     os.rmdir(tmp_dir)
    ...     del sys.modules['epydoc_test']

Module Variables
================
Each variable defined by a module is encoded as a `VariableDoc`, whose
value contains information about the variable's value.  This includes
any classes, functions, imported variables, and anything else that has
an entry in a module's dictionary.

    >>> runinspector(s="""
    ...     x = 12
    ...     def f(x): pass
    ...     class A: pass
    ...     from os import listdir, mkdir
    ...     exec("y = 22")
    ...     """, attribs="variables")
    ModuleDoc for epydoc_test [0]
     +- variables
        +- A => VariableDoc for epydoc_test.A [1]
        +- f => VariableDoc for epydoc_test.f [2]
        +- listdir => VariableDoc for epydoc_test.listdir [3]
        +- mkdir => VariableDoc for epydoc_test.mkdir [4]
        +- x => VariableDoc for epydoc_test.x [5]
        +- y => VariableDoc for epydoc_test.y [6]

If two variables share the same value, then their `VariableDoc`s will
share a `ValueDoc`:

    >>> runinspector(s="""
    ...     def f(x): pass
    ...     alias = f
    ...     """, attribs="variables value")
    ModuleDoc for epydoc_test [0]
     +- variables
        +- alias => VariableDoc for epydoc_test.alias [1]
        |  +- value
        |     +- RoutineDoc for epydoc_test.f [2]
        +- f => VariableDoc for epydoc_test.f [3]
           +- value
              +- RoutineDoc for epydoc_test.f [2] (defined above)

Importing a dotted name creates a variable for the top-level component
of the dotted name:

    >>> runinspector(s="""
    ...     import os.path
    ...     """, attribs="variables")
    ModuleDoc for epydoc_test [0]
     +- variables
        +- os => VariableDoc for epydoc_test.os [1]

Since variables are extracted by inspection, only those variables that
exist when the module finishes running will be seen.  (This is
potentially different from `epydoc.docparser`, which has to guess
about which code paths are taken).

    >>> runinspector(s="""
    ...     x = 22
    ...     if x<13: y = 32
    ...     else: z = 14
    ...     del x
    ...     """, attribs="variables")
    ModuleDoc for epydoc_test [0]
     +- variables
        +- z => VariableDoc for epydoc_test.z [1]

Unlike the parser, arbitrary computed values can be extracted:

    >>> runinspector(s="""
    ...     def f(x):
    ...         if x>100: return x
    ...         else: return f((x+2)*8/7)
    ...     x = f(12)
    ...     """, attribs="variables value repr")
    ModuleDoc for epydoc_test [0]
     +- repr = u"<module 'epydoc_test' from ...
     +- variables
        +- f => VariableDoc for epydoc_test.f [1]
        |  +- value
        |     +- RoutineDoc for epydoc_test.f [2]
        |        +- repr = u'<function f at ...>'
        +- x => VariableDoc for epydoc_test.x [3]
           +- value
              +- ValueDoc [4]
                 +- repr = u'112'

The inspector is unable to determine when variables are aliases for
other variables, so it always sets `is_alias` to `UNKNOWN`:

    >>> runinspector(s="""
    ...     x = 22
    ...     y = x
    ...     """, attribs="variables is_alias")
    ModuleDoc for epydoc_test [0]
     +- variables
        +- x => VariableDoc for epydoc_test.x [1]
        |  +- is_alias = <UNKNOWN>
        +- y => VariableDoc for epydoc_test.y [2]
           +- is_alias = <UNKNOWN>

Similarly, the inspector can't always tell if a variable was imported
or not, so it sets `is_imported` to `UNKNOWN` when it can't decide:

    >>> runinspector(s="""
    ...     from re import match       # definitely imported
    ...     from re import error       # definitely imported
    ...     from re import MULTILINE   # might be imported
    ...     class A: pass              # definitely not imported
    ...     def f(x): pass             # definitely not imported
    ...     """, attribs="variables is_imported")
    ModuleDoc for epydoc_test [0]
     +- variables
        +- A => VariableDoc for epydoc_test.A [1]
        |  +- is_imported = False
        +- MULTILINE => VariableDoc for epydoc_test.MULTILINE [2]
        |  +- is_imported = <UNKNOWN>
        +- error => VariableDoc for epydoc_test.error [3]
        |  +- is_imported = True
        +- f => VariableDoc for epydoc_test.f [4]
        |  +- is_imported = False
        +- match => VariableDoc for epydoc_test.match [5]
           +- is_imported = True

Variable Docstrings
===================
The DocInspector is unable extract docstrings for variables.  These
docstrings can only be detected if the DocParser is used.

    >>> runinspector(s="""
    ...     x = 12
    ...     '''docstring for x.
    ...     (can be multiline)'''""",
    ...     attribs="variables name docstring")
    ModuleDoc for epydoc_test [0]
     +- docstring = None
     +- variables
        +- x => VariableDoc for epydoc_test.x [1]
           +- docstring = <UNKNOWN>
           +- name = 'x'

    >>> runinspector(s="""
    ...     x = 12 #: comment docstring for x""",
    ...     attribs="variables name docstring")
    ModuleDoc for epydoc_test [0]
     +- docstring = None
     +- variables
        +- x => VariableDoc for epydoc_test.x [1]
           +- docstring = <UNKNOWN>
           +- name = 'x'

Functions
=========
Inspected functions are represented by `RoutineDoc` objects:

    >>> runinspector(s="""
    ...     def f(x):
    ...         'docstring for f'
    ...         print 'inside f'
    ...     """, inspect="f")
    RoutineDoc for epydoc_test.f [0]
     +- canonical_name = DottedName('epydoc_test', 'f')
     +- docstring = u'docstring for f'
     +- kwarg = None
     +- posarg_defaults = [None]
     +- posargs = ['x']
     +- pyval = <function f at ...>
     +- repr = u'<function f at ...>'
     +- vararg = None

The function's arguments are described by the properties `posargs`,
`posarg_defaults`, `kwarg`, and `vararg`.  `posargs` is a list of
argument names (or nested tuples of names, for tuple-unpacking args).
`posarg_defaults` is a list of `ValueDoc`s for default values,
corresponding 1:1 with `posargs`.  `posarg_defaults` is None for
arguments with no default value.  `vararg` and `kwarg` are the names
of the variable argument and keyword argument, respectively:

    >>> runinspector(s="""
    ...     def f(x, y=22, z=(1,), *v, **kw):
    ...         'docstring for f'
    ...         print 'inside f'
    ...     """, inspect="f")
    RoutineDoc for epydoc_test.f [0]
     +- canonical_name = DottedName('epydoc_test', 'f')
     +- docstring = u'docstring for f'
     +- kwarg = 'kw'
     +- posarg_defaults = [None, <ValueDoc 22>, <ValueDoc 1>]
     +- posargs = ['x', 'y', 'z']
     +- pyval = <function f at ...>
     +- repr = u'<function f at ...>'
     +- vararg = 'v'

Tuple arguments are encoded as a single ArgDoc with a complex name:

    >>> runinspector(s="""
    ...     def f( (x, (y,z)) ): pass""",
    ...     attribs='variables value posargs posarg_defaults vararg kwarg')
    ModuleDoc for epydoc_test [0]
     +- variables
        +- f => VariableDoc for epydoc_test.f [1]
           +- value
              +- RoutineDoc for epydoc_test.f [2]
                 +- kwarg = None
                 +- posarg_defaults = [None]
                 +- posargs = [['x', ['y', 'z']]]
                 +- vararg = None

Decorators & Wrapper Assignments
================================

    >>> runinspector(s="""
    ...     @classmethod
    ...     def f(cls, x): 'docstring for f'
    ...     """, inspect="f")
    ClassMethodDoc [0]
     +- docstring = u'docstring for f'
     +- kwarg = None
     +- posarg_defaults = [None, None]
     +- posargs = ['cls', 'x']
     +- pyval = <classmethod object at ...>
     +- repr = u'<classmethod object at ...>'
     +- vararg = None

Classes
=======

    >>> runinspector(s="""
    ...     class A:
    ...         "no bases"
    ...         class Nested: "nested class"
    ...     class B(A): "single base"
    ...     class C(A,B): "multiple bases"
    ...     class D( ((A)) ): "extra parens around base"
    ...     class E(A.Nested): "dotted name"
    ...     class F(((A).Nested)): "parens with dotted name"
    ...     class Z(B.__bases__[0]): "calculated base" # not handled!
    ...     """,
    ...     attribs='variables value bases docstring')
    ModuleDoc for epydoc_test [0]
     +- docstring = None
     +- variables
        +- A => VariableDoc for epydoc_test.A [1]
        |  +- docstring = <UNKNOWN>
        |  +- value
        |     +- ClassDoc for epydoc_test.A [2]
        |        +- bases = []
        |        +- docstring = u'no bases'
        |        +- variables
        |           +- Nested => VariableDoc for epydoc_test.A.Nested [3]
        |              +- docstring = <UNKNOWN>
        |              +- value
        |                 +- ClassDoc [4]
        |                    +- bases = []
        |                    +- docstring = u'nested class'
        |                    +- variables = {}
        +- B => VariableDoc for epydoc_test.B [5]
        |  +- docstring = <UNKNOWN>
        |  +- value
        |     +- ClassDoc for epydoc_test.B [6]
        |        +- bases
        |        |  +- ClassDoc for epydoc_test.A [2] (defined above)
        |        +- docstring = u'single base'
        |        +- variables = {}
        +- C => VariableDoc for epydoc_test.C [7]
        |  +- docstring = <UNKNOWN>
        |  +- value
        |     +- ClassDoc for epydoc_test.C [8]
        |        +- bases
        |        |  +- ClassDoc for epydoc_test.A [2] (defined above)
        |        |  +- ClassDoc for epydoc_test.B [6] (defined above)
        |        +- docstring = u'multiple bases'
        |        +- variables = {}
        +- D => VariableDoc for epydoc_test.D [9]
        |  +- docstring = <UNKNOWN>
        |  +- value
        |     +- ClassDoc for epydoc_test.D [10]
        |        +- bases
        |        |  +- ClassDoc for epydoc_test.A [2] (defined above)
        |        +- docstring = u'extra parens around base'
        |        +- variables = {}
        +- E => VariableDoc for epydoc_test.E [11]
        |  +- docstring = <UNKNOWN>
        |  +- value
        |     +- ClassDoc for epydoc_test.E [12]
        |        +- bases
        |        |  +- ClassDoc [4] (defined above)
        |        +- docstring = u'dotted name'
        |        +- variables = {}
        +- F => VariableDoc for epydoc_test.F [13]
        |  +- docstring = <UNKNOWN>
        |  +- value
        |     +- ClassDoc for epydoc_test.F [14]
        |        +- bases
        |        |  +- ClassDoc [4] (defined above)
        |        +- docstring = u'parens with dotted name'
        |        +- variables = {}
        +- Z => VariableDoc for epydoc_test.Z [15]
           +- docstring = <UNKNOWN>
           +- value
              +- ClassDoc for epydoc_test.Z [16]
                 +- bases
                 |  +- ClassDoc for epydoc_test.A [2] (defined above)
                 +- docstring = u'calculated base'
                 +- variables = {}


Delete Statements
=================

Deleting variables:

    >>> runinspector(s="""
    ...     x = y = 12
    ...     del y
    ...     """,
    ...     attribs='variables value repr is_alias')
    ModuleDoc for epydoc_test [0]
     +- repr = u"<module 'epydoc_test' from ...
     +- variables
        +- x => VariableDoc for epydoc_test.x [1]
           +- is_alias = <UNKNOWN>
           +- value
              +- ValueDoc [2]
                 +- repr = u'12'

The right-hand side of a `del` statement may contain a nested
combination of lists, tuples, and parenthases.  All variables found
anywhere in this nested structure should be deleted:
    
    >>> runinspector(s="""
    ...     a=b=c=d=e=f=g=1
    ...     del a
    ...     del (b)
    ...     del [c]
    ...     del (d,)
    ...     del (((e,)),)
    ...     del [[[[f]]]]
    ...     """,
    ...     attribs='variables')
    ModuleDoc for epydoc_test [0]
     +- variables
        +- g => VariableDoc for epydoc_test.g [1]
    >>> runinspector(s="""
    ...     a=b=c=d=e=f=g=1
    ...     del a,b
    ...     del (c,d)
    ...     del [e,f]
    ...     """,
    ...     attribs='variables')
    ModuleDoc for epydoc_test [0]
     +- variables
        +- g => VariableDoc for epydoc_test.g [1]
    >>> runinspector(s="""
    ...     a=b=c=d=e=f=g=1
    ...     del ((a, (((((b, c)), d), [e]))), f)
    ...     """,
    ...     attribs='variables')
    ModuleDoc for epydoc_test [0]
     +- variables
        +- g => VariableDoc for epydoc_test.g [1]

The right-hand side of a `del` statement may contain a dotted name, in
which case the named variable should be deleted from its containing
namespace.

    >>> runinspector(s="""
    ...     class A: a = b = 1
    ...     del A.a
    ...     """,
    ...     attribs='variables value local_variables')
    ModuleDoc for epydoc_test [0]
     +- variables
        +- A => VariableDoc for epydoc_test.A [1]
           +- value
              +- ClassDoc for epydoc_test.A [2]
                 +- variables
                    +- b => VariableDoc for epydoc_test.A.b [3]
                       +- value
                          +- ValueDoc [4]

Slice deletes:

    >>> runinspector(s="""
    ...     a = b = [1,2,3,4]
    ...     del a[2]
    ...     del a[2:]
    ...     del ([b], a[1])
    ...     """,
    ...     attribs='variables')
    ModuleDoc for epydoc_test [0]
     +- variables
        +- a => VariableDoc for epydoc_test.a [1]

Single-Line Blocks
==================

    >>> runinspector(s="""
    ...     class A: 'docstring for A'
    ...     
    ... 
    ...     """,
    ...     attribs='variables value docstring')
    ModuleDoc for epydoc_test [0]
     +- docstring = None
     +- variables
        +- A => VariableDoc for epydoc_test.A [1]
           +- docstring = <UNKNOWN>
           +- value
              +- ClassDoc for epydoc_test.A [2]
                 +- docstring = u'docstring for A'
                 +- variables = {}

Imports
=======

    >>> runinspector(s="""
    ...     import re
    ...     from re import match
    ...     """,
    ...     attribs='variables value is_imported')
    ModuleDoc for epydoc_test [0]
     +- variables
        +- match => VariableDoc for epydoc_test.match [1]
        |  +- is_imported = True
        |  +- value
        |     +- ValueDoc for sre.match [2]
        +- re => VariableDoc for epydoc_test.re [3]
           +- is_imported = True
           +- value
              +- ValueDoc for re [4]


Unicode
=======

    >>> runinspector(s="""
    ...     def f(x):
    ...         u"unicode in docstring: \u1000"
    ...     """, inspect="f", attribs="docstring")
    RoutineDoc for epydoc_test.f [0]
     +- docstring = u'unicode in docstring: \u1000'

Instance Variables
==================

DocInspector is unable to discover instance variables:

    >>> runinspector(s="""
    ...     class A:
    ...         def __init__(self, x, y):
    ...             self.x = 10
    ...             
    ...             self.y = 20 #: docstring for y
    ...             
    ...             self.z = 30
    ...             '''docstring for z'''
    ...     
    ...     """, inspect="A", attribs="variables")
    ClassDoc for epydoc_test.A [0]
     +- variables
        +- __init__ => VariableDoc for epydoc_test.A.__init__ [1]

Assignments Into Namespaces
===========================

    >>> runinspector(s="""
    ...     class A: pass
    ...     A.x = 22
    ...     """, inspect="A", attribs='variables value local_variables')
    ClassDoc for epydoc_test.A [0]
     +- variables
        +- x => VariableDoc for epydoc_test.A.x [1]
           +- value
              +- ValueDoc [2]




