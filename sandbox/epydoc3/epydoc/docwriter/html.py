#
# epydoc.py: epydoc HTML output generator
# Edward Loper
#
# Created [01/30/01 05:18 PM]
# $Id$
#

"""
Use css/javascript to hide/show private elements.


Forms of output:

  - summary table
  - details list

I could potentially add:
  # pos = mark_pos(out)
  # rollback(out, pos)

But I doubt it's worth it.

"""
import re, os
from epydoc.apidoc import *
from epydoc.docstringparser import DocstringParser
import time, epydoc, epydoc.markup
from epydoc.docwriter.html_colorize import colorize_re
from epydoc.docwriter.html_css import STYLESHEETS
from epydoc.docwriter.html_help import HTML_HELP

######################################################################
## Template Compiler
######################################################################

def strip_indent(s):
    # Strip indentation from the template.
    minindent = 10000
    lines = s.split('\n')
    for line in lines:
        stripline = line.lstrip()
        if stripline:
            minindent = min(minindent, len(line)-len(stripline))
    return '\n'.join([l[minindent:] for l in lines])

# consider using psp-style tags instead?
#   <%= foo %>
#   <% foo %>
# look up psp/php?
def compile_template(docstring, template_string,
                     output_function='out', debug=False):
    """
    Given a template string containing inline python source code,
    return a python function that will fill in the template, and
    output the result.  The signature for this function is taken from
    the first line of C{docstring}.  Output is generated by making
    repeated calls to the output function with the given name (which
    is typically one of the function's parameters).

    The templating language used by this function passes through all
    text as-is, with three exceptions:

      - If every line in the template string is indented by at least
        M{x} spaces, then the first M{x} spaces are stripped from each
        line.

      - Any line that begins with '#' (with no indentation)
        should contain python code, and will be inserted as-is into
        the template-filling function.  If the line begins a control
        block (such as 'if' or 'for'), then the control block will
        be closed by the first '#'-marked line whose indentation is
        less than or equal to the line's own indentation (including
        lines that only contain comments.)

      - In any other line, any expression between two '$' signs will
        be evaluated and inserted into the line (using C{str()} to
        convert the result to a string).

    Here is a simple example:

        >>> TEMPLATE = '''
        ... <book>
        ...   <title>$book.title$</title>
        ...   <pages>$book.count_pages()$</pages>
        ... # for chapter in book.chapters:
        ...     <chaptername>$chapter.name$</chaptername>
        ... # #endfor
        ... </book>
        >>> write_book = compile_template('write_book(out, book)', TEMPLATE)

    @acknowledgements: The syntax used by C{compile_template} is
    loosely based on Cheetah.
    """
    # Extract signature from the docstring:
    signature = docstring.lstrip().split('\n',1)[0].strip()
    func_name = signature.split('(',1)[0].strip()
    
    INLINE = re.compile(r'\$([^\$]+)\$')
    COMMAND = re.compile(r'(^#.*)\n?', re.MULTILINE)

    # Strip indentation from the template.
    template_string = strip_indent(template_string)

    if debug:
        signature = re.sub(r'\)\s*$', ', pysrc=pysrc)', signature)

    # Funciton declaration line
    pysrc = ['def %s:' % signature]
    indents = [-1]

    if debug:
        pysrc.append('    try:')
        indents.append(-1)

    commands = COMMAND.split(template_string.strip()+'\n')
    for i, command in enumerate(commands):
        if command == '': continue

        # String literal segment:
        if i%2 == 0:
            pieces = INLINE.split(command)
            for j, piece in enumerate(pieces):
                if j%2 == 0:
                    pysrc.append('    '*len(indents)+
                                 '%s(%r)' % (output_function, piece))
                else:
                    pysrc.append('    '*len(indents)+
                                 '%s(str(%s))' % (output_function, piece))

        # Python command:
        else:
            srcline = command[1:].lstrip()
            # Update indentation
            indent = len(command)-len(srcline)
            while indent <= indents[-1]: indents.pop()
            # Add on the line.
            pysrc.append('    '*len(indents)+srcline)
            if srcline.endswith(':'):
                indents.append(indent)
        
    if debug:
        pysrc.append('    except Exception,e:')
        pysrc.append('        print "Exception in template code:"')
        pysrc.append('        print "="*70')
        pysrc.append('        print pysrc')
        pysrc.append('        print "="*70')
        pysrc.append('        raise')
        
    pysrc = '\n'.join(pysrc)+'\n'
    if debug: localdict = {'pysrc': pysrc}
    else: localdict = {}
    try: exec pysrc in globals(), localdict
    except SyntaxError:
        print 'Error in script:'
        print pysrc
        raise
    template_func = localdict[func_name]
    template_func.__doc__ = docstring
    return template_func
    
######################################################################
## HTML Writer
######################################################################

class HTMLWriter:
    #////////////////////////////////////////////////////////////
    # Table of Contents
    #////////////////////////////////////////////////////////////
    # 1. Interface Methods
    # 2. Page Generation -- write complete web pages
    #   2.1. Module Page
    #   2.2. Class Page
    # 3. Page Element Generation -- write pieces of a web page
    #   3.1. Page Header
    #   3.2. Page Footer
    #   3.3. Navigation Bar
    #   3.4. Breadcrumbs
    #   3.5. Summary Tables

    def __init__(self, docindex, **kwargs):
        self.docindex = docindex
        self.docset = Set(docindex.values())

        # Process keyword arguments.
        self._prj_name = kwargs.get('prj_name', None)
        self._prj_url = kwargs.get('prj_url', None)
        self._prj_link = kwargs.get('prj_link', None)
        self._create_private_docs = kwargs.get('private', 1)
        self._top_page = self._find_top_page(kwargs.get('top', None))
        self._css = kwargs.get('css')
        self._private_css = kwargs.get('private_css') or self._css
        self._helpfile = kwargs.get('help', None)
        self._frames_index = kwargs.get('frames', 1)
        self._show_imports = kwargs.get('show_imports', 0)
        self._index_parameters = kwargs.get('index_parameters', 0)
        self._propfunc_linelen = kwargs.get('property_function_linelength', 40)
        self._variable_maxlines = kwargs.get('variable_maxlines', 8)
        self._variable_linelen = kwargs.get('variable_linelength', 70)
        self._variable_summary_linelen = \
                         kwargs.get('variable_summary_linelength', 55)
        self._variable_tooltip_linelen = \
                         kwargs.get('variable_tooltip_linelength', 600)
        self._inheritance = kwargs.get('inheritance', 'grouped')

        # Create the project homepage link, if it was not specified.
        if (self._prj_name or self._prj_url) and not self._prj_link:
            name = self._prj_name or 'Project Homepage'
            name = name.replace('&', '&amp;')
            name = name.replace('<', '&lt;')
            name = name.replace('>', '&gt;')
            name = name.replace(' ', '&nbsp;')
            self._prj_link = name

        # Add a hyperlink to _prj_url, if _prj_link doesn't already
        # contain any hyperlinks.
        if (self._prj_link and self._prj_url and
            not re.search(r'<a[^>]*\shref', self._prj_link)):
            self._prj_link = ('<a class="navbar" target="_top" href="'+
                              self._prj_url+'">'+self._prj_link+'</a>')

    def _find_top_page(self, pagename):
        return 'trees.html'
    
    #////////////////////////////////////////////////////////////
    # 1. Interface Methods
    #////////////////////////////////////////////////////////////

    def write(self, directory=None, progress_callback=None):
        """
        Write the documentation to the given directory.

        @type directory: C{string}
        @param directory: The directory to which output should be
            written.  If no directory is specified, output will be
            written to the current directory.  If the directory does
            not exist, it will be created.
        @type progress_callback: C{function}
        @param progress_callback: A callback function that is called
            before each file is written, with the name of the created
            file.
        @rtype: C{None}
        @raise OSError: If C{directory} cannot be created,
        @raise OSError: If any file cannot be created or written to.
        """        
        # Keep track of failed xrefs, and report them at the end.
        self._failed_xrefs = {}

        # Create destination directories, if necessary
        if not directory: directory = os.curdir
        self._mkdir(directory)

        # Write the CSS files.
        if progress_callback: progress_callback('epydoc.css')
        self.write_css(directory, self._css)

        # Write the object documentation.
        for doc in self.docset:
            if not isinstance(doc, (ModuleDoc, ClassDoc)): continue
            filename = self.url(doc)
            if isinstance(doc, ModuleDoc):
                self._write(self.write_module, directory, filename,
                            progress_callback, doc)
            else:
                self._write(self.write_class, directory, filename,
                            progress_callback, doc)
        
        # Write the term & identifier indices
        self._write(self.write_indices, directory,
                    'indices.html', progress_callback)
        
        # Write the trees file (package & class hierarchies)
        self._write(self.write_trees, directory,
                    'trees.html', progress_callback)
        
        # Write the help file.
        self._write(self.write_help, directory,
                    'help.html', progress_callback)
        
        # Write the frames-based table of contents.
        self._write(self.write_frames_index, directory, 'frames.html',
                     progress_callback)
        self._write(self.write_toc, directory, 'toc.html',
                     progress_callback)
        self._write(self.write_project_toc, directory,
                    'toc-everything.html', progress_callback)
        for doc in self.docset:
            if isinstance(doc, ModuleDoc):
                filename = 'toc-%s' % self.url(doc)
                self._write(self.write_module_toc, directory, filename,
                             progress_callback, doc)
        
        # Write the index.html files.
        if progress_callback: progress_callback('index.html')
        self.write_homepage(directory)

        # Report any failed crossreferences
        if self._failed_xrefs:
            estr = 'Warning: Failed identifier crossreference targets:\n'
            failed_identifiers = self._failed_xrefs.keys()
            failed_identifiers.sort()
            for identifier in failed_identifiers:
                names = self._failed_xrefs[identifier].keys()
                names.sort()
                estr += '    - %s' % identifier
                if len(names)==1 and len(identifier)+len(str(name))+14 < 70:
                    estr += ' (from %s)\n' % names[0].name()
                else:
                    estr += '\n'
                    for name in names:
                        estr += '      (from %s)\n' % name
            if sys.stderr.softspace: print >>sys.stderr
            print >>sys.stderr, estr

    def _write(self, write_func, directory, filename,
               progress_callback, *args):
        # Display our progress.
        if progress_callback: progress_callback(filename)
        
        path = os.path.join(directory, filename)
        f = open(path, 'w')
        write_func(f.write, *args)
        f.close()

    def _mkdir(self, directory):
        """
        If the given directory does not exist, then attempt to create it.
        @rtype: C{None}
        """
        if not os.path.isdir(directory):
            if os.path.exists(directory):
                raise OSError('%r is not a directory' % directory)
            os.mkdir(directory)
        
    #////////////////////////////////////////////////////////////
    # 2.1. Module Page
    #////////////////////////////////////////////////////////////

    def write_module(self, out, doc):
        """
        Write an HTML page containing the API documentation for the
        given module to C{out}.
        
        @param doc: A L{ModuleDoc} containing the API documentation
        for the module that should be described.
        """
        longname = doc.canonical_name
        shortname = doc.canonical_name[-1]

        # Write the page header (incl. navigation bar & breadcrumbs)
        self.write_header(out, str(longname))
        self.write_navbar(out, doc)
        self.write_breadcrumbs(out, doc)

        # Write the name of the module we're describing.
        if doc.is_package is True: typ = 'Package'
        else: typ = 'Module'
        out('<!-- ==================== %s ' % typ.upper() +
            'DESCRIPTION ==================== -->\n')
        out('<h2 class="%s">%s %s</h2>\n' % (typ.lower(), typ, shortname))
            

        # If the module has a description, then list it.
        if doc.descr not in (None, UNKNOWN):
            out(self.description(doc.descr, longname, 2)+'\n<hr />\n\n')

        # Write any standarad metadata (todo, author, etc.)
        self.write_standard_fields(out, doc)

        # If it's a package, then list the modules it contains.
        if doc.is_package is True:
            self.write_module_list(out, doc)

        # Write summary tables describing the variables that the
        # module defines.
        self.write_summary_table(out, "Classes", doc, "class")
        self.write_summary_table(out, "Functions", doc, "function")
        self.write_summary_table(out, "Variables", doc, "other")

        # Write a list of all imported objects.
        # [xx] imports?

        # Write detailed descriptions of functions & variables defined
        # in this module.
        self.write_details_list(out, "Function Details", doc, "function")
        self.write_details_list(out, "Variables Details", doc, "other")

        # Write the page footer (including navigation bar)
        self.write_navbar(out, doc)
        self.write_footer(out)

    #////////////////////////////////////////////////////////////
    # 2.2. Class Page
    #////////////////////////////////////////////////////////////

    def write_class(self, out, doc):
        """
        Write an HTML page containing the API documentation for the
        given class to C{out}.
        
        @param doc: A L{ClassDoc} containing the API documentation
        for the class that should be described.
        """
        longname = doc.canonical_name
        shortname = doc.canonical_name[-1]

        # Write the page header (incl. navigation bar & breadcrumbs)
        self.write_header(out, str(longname))
        self.write_navbar(out, doc)
        self.write_breadcrumbs(out, doc)

        # Write the name of the module we're describing.
        if doc.is_type(): typ = 'Type'
        elif doc.is_exception(): typ = 'Exception'
        else: typ = 'Class'
        out('<!-- ==================== %s ' % typ.upper() +
            'DESCRIPTION ==================== -->\n')
        out('<h2 class="%s">%s %s</h2>\n' %
            (typ.lower(), typ, shortname))

        # Write the base class tree.
        if doc.bases not in (UNKNOWN, None) and len(doc.bases) > 0:
            out('<pre class="base-tree">\n%s</pre>\n\n' %
                self.base_tree(doc))

        # Write the known subclasses
        if doc.subclasses not in (UNKNOWN, None) and len(doc.subclasses) > 0:
            out('<dl><dt>Known Subclasses:</dt>\n<dd>\n    ')
            out(',\n    '.join([self.href(c, c.canonical_name[-1])
                                for c in doc.subclasses]))
            out('\n</dd></dl>\n\n')

        if ((doc.bases not in (UNKNOWN, None) and len(doc.bases) > 0) or
            (doc.subclasses not in (UNKNOWN,None) and len(doc.subclasses)>0)):
            out('<hr />\n')
        
        # If the class has a description, then list it.
        if doc.descr not in (None, UNKNOWN):
            out(self.description(doc.descr, longname, 2)+'\n<hr />\n\n')

        # Write any standarad metadata (todo, author, etc.)
        self.write_standard_fields(out, doc)

        # Write summary tables describing the variables that the
        # module defines.
        self.write_summary_table(out, "Nested Classes", doc, "class")
        self.write_summary_table(out, "Methods", doc, "instancemethod")
        self.write_summary_table(out, "Class Methods", doc, "classmethod")
        self.write_summary_table(out, "Static Methods", doc, "staticmethod")
        self.write_summary_table(out, "Class Variables", doc,
                                 "classvariable")
        self.write_summary_table(out, "Instance Variables", doc,
                                 "instancevariable")
        self.write_summary_table(out, "Properties", doc, "property")

        # Write detailed descriptions of functions & variables defined
        # in this module.
        self.write_details_list(out, "Method Details", doc, "method")
        self.write_details_list(out, "Class Variable Details", doc,
                                "classvariable")
        self.write_details_list(out, "Instance Variable Details", doc,
                                "instancevariable")
        self.write_details_list(out, "Property Details", doc, "property")

        # Write the page footer (including navigation bar)
        self.write_navbar(out, doc)
        self.write_footer(out)

    #////////////////////////////////////////////////////////////
    # 2.3. Stylesheet (epydoc.css)
    #////////////////////////////////////////////////////////////

    def write_css(self, directory, cssname):
        """
        Write the CSS stylesheet in the given directory.  If
        C{cssname} contains a stylesheet file or name (from
        L{epydoc.css}), then use that stylesheet; otherwise, if a
        stylesheet file already exists, use that stylesheet.
        Otherwise, use the default stylesheet.

        @rtype: C{None}
        """
        filename = os.path.join(directory, 'epydoc.css')
        
        # Get the contents for the stylesheet file.  If none was
        # specified, and a stylesheet is already present, then don't
        # do anything.
        if cssname is None:
            if os.path.exists(filename):
                return
            else: css = STYLESHEETS['default'][0]
        else:
            if os.path.exists(cssname):
                try: css = open(cssname).read()
                except: raise IOError("Can't open CSS file: %r" % cssname)
            elif STYLESHEETS.has_key(cssname):
                css = STYLESHEETS[cssname][0]
            else:
                raise IOError("Can't find CSS file: %r" % cssname)

        # Write the stylesheet.
        cssfile = open(filename, 'w')
        cssfile.write(css)
        cssfile.close()

    #////////////////////////////////////////////////////////////
    # 2.4. Project homepage (index.html)
    #////////////////////////////////////////////////////////////

    def write_homepage(self, directory):
        """
        Write an C{index.html} file in the given directory.  The
        contents of this file are copied or linked from an existing
        page.  The page used is determined by L{_frames_index} and
        L{_top_page}:
            - If L{_frames_index} is true, then C{frames.html} is
              copied.
            - Otherwise, the page specified by L{_top_page} is
              copied.
        """
        filename = os.path.join(directory, 'index.html')
        if self._frames_index: top = 'frames.html'
        else: top = self._top_page

        # Copy the non-frames index file from top, if it's internal.
        if top[:5] != 'http:' and '/' not in top:
            try:
                # Read top into `s`.
                topfile = os.path.join(directory, top)
                s = open(topfile, 'r').read()

                # Write the output file.
                open(filename, 'w').write(s)
                return
            except:
                if sys.stderr.softspace: print >>sys.stderr
                estr = 'Warning: error copying index; using a redirect page'
                print >>sys.stderr, estr

        # Use a redirect if top is external, or if we faild to copy.
        
        name = self._prj_name or 'this project'
        f = open(filename, 'w')
        self.write_redirect_index(f.write, top, name)
        f.close()

    write_redirect_index = compile_template(
        """
        write_redirect_index(self, out, top, name)
        """,
        '''
        <?xml version="1.0" encoding="iso-8859-1"?>
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                  "DTD/xhtml1-strict.dtd">
        <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
        <head>
          <title> Redirect </title>
          <meta http-equiv="refresh" content="1;url=$top$" />
          <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
        </head>
        <body>
          <p>Redirecting to the API documentation for
            <a href="$top$">$self._prj_name or "this project"$</a>...</p>
        </body>
        </html>
        ''')

    #////////////////////////////////////////////////////////////
    # 2.5. Help Page
    #////////////////////////////////////////////////////////////

    def write_help(self, out):
        """
        Write an HTML help file to the given streams.  If
        C{self._helpfile} contains a help file, then use it;
        otherwise, use the default helpfile from L{epydoc.help}.
        @param public: The output stream for the public version of the page.
        @param private: The output stream for the private version of the page.
        """
        # todo: optionally parse .rst etc help files?
        
        # Get the contents of the help file.
        if self._helpfile:
            if os.path.exists(self._helpfile):
                try: help = open(self._helpfile).read()
                except: raise IOError("Can't open help file: %r" %
                                      self._helpfile)
            else:
                raise IOError("Can't find help file: %r" % self._helpfile)
        else:
            if self._prj_name: thisprj = self._prj_name
            else: thisprj = 'this project'
            help = HTML_HELP % {'this_project':thisprj}

        # Insert the help contents into a webpage.
        self.write_header(out, 'Help')
        self.write_navbar(out, 'help')
        self.write_breadcrumbs(out, 'help')
        out(help)
        self.write_navbar(out, 'help')
        self.write_footer(out, 'Help')

    #////////////////////////////////////////////////////////////
    # 2.6. Trees page.
    #////////////////////////////////////////////////////////////

    def write_trees(self, out):
        """
        Write an HTML page containing the module and class hierarchies
        to the given streams.
        @param public: The output stream for the public version of the page.
        @param private: The output stream for the private version of the page.
        """
        # Header material.
        self.write_header(out, 'Trees')
        self.write_navbar(out, 'trees')
        self.write_breadcrumbs(out, 'trees')

        # Write the module hierarchy
        out('<!-- ==================== ' 
            'MODULE HIERARCHY ==================== -->\n')
        out('<h2>Module Hierarchy</h2>\n')
        self.write_module_tree(out)

        # Does the project define any classes?
        defines_classes = False
        for doc in self.docset:
            if isinstance(doc, ClassDoc): defines_classes = True; break

        # Write the class hierarchy
        if defines_classes:
            out('<!-- ==================== '
                'CLASS HIERARCHY ==================== -->\n')
            out('<h2>Class Hierarchy</h2>\n')
            self.write_class_tree(out)

        # Footer material.
        self.write_navbar(out, 'trees')
        self.write_footer(out, 'Trees')

    #////////////////////////////////////////////////////////////
    # 2.n. Frames
    #////////////////////////////////////////////////////////////
    
    write_frames_index = compile_template(
        """
        write_frames_index(self, out)

        Write the frames index file for the frames-based table of
        contents to the given streams.
        """,
        '''
        <?xml version="1.0" encoding="iso-8859-1"?>
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"
                  "DTD/xhtml1-frameset.dtd">
        <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
        <head>
          <title> $self._prj_name or "API Documentation"$ </title>
        </head>
        <frameset cols="20%,80%">
          <frameset rows="30%,70%">
            <frame src="toc.html" name="moduleListFrame"
                   id="moduleListFrame" />
            <frame src="toc-everything.html" name="moduleFrame"
                   id="moduleFrame" />
          </frameset>
          <frame src="$self._top_page$" name="mainFrame" id="mainFrame" />
        </frameset>
        </html>
        ''')
        

    #////////////////////////////////////////////////////////////
    # 2.2. Indices
    #////////////////////////////////////////////////////////////

    def write_indices(self, out):
        """
        Write an HTML page containing the term and identifier indices
        to the given streams.
        @bug: If there are private indexed terms, but no public
            indexed terms, then this function will still write a
            header for the Term Index to the public stream.
        @param public: The output stream for the public version of the page.
        @param private: The output stream for the private version of the page.
        """
        # Header material.
        self.write_header(out, 'Index')
        self.write_navbar(out, 'indices')
        self.write_breadcrumbs(out, 'indices')
        out('<br />\n')

        terms = self._extract_term_index()
        if terms:
            self.write_term_index(out)

        identifiers = []
        for doc in self.docset:
            name = doc.canonical_name
            if self.url(doc) is None: continue
            identifiers.append( (str(name).lower(), name, doc) )
        identifiers.sort()
        if identifiers:
            self.write_identifier_index(out, identifiers)

        # Footer material.
        self.write_navbar(out, 'indices')
        self.write_footer(out, 'Index')
        
    write_identifier_index = compile_template(
        """
        write_identifier_index(self, out, index)
        """,
        '''
        # self.write_table_header(out, "index", "Identifier Index")
        # for sortkey, name, doc in index:
          <tr><td width="15%">
        #   if isinstance(doc, ModuleDoc) and doc.is_package:
                Package $self.href(doc, name[-1])$
        #   elif isinstance(doc, ModuleDoc):
                Module $self.href(doc, name[-1])$
        #   elif isinstance(doc, ClassDoc):
                Class $self.href(doc, name[-1])$
        #   elif isinstance(doc, MethodDoc):
                Method $self.href(doc, name[-1])$
        #   elif isinstance(doc, FunctionDoc):
                Function $self.href(doc, name[-1])$
        #   else:
                Variable $self.href(doc, name[-1])$
        #   #endif
        #   container_name = name.container()
        #   container = self.docindex.get(container_name)
        #   if isinstance(container, ModuleDoc) and container.is_package:
                in package $self.href(container, container_name)$
        #   elif isinstance(container, ModuleDoc):
                in module $self.href(container, container_name)$
        #   elif isinstance(container, ClassDoc):
                in class $self.href(container, container_name)$
        #   #endif
              </td>
              <td>
        #   if doc.summary not in (None, UNKNOWN):
                $self.description(doc.summary, doc, 8)$
        #   else:
                &nbsp;
        #   #endif
              </td>
          </tr>
        # #endfor
        </table><br />
        ''')

    write_term_index = compile_template(
        """
        write_term_index(self, out, index)
        """,
        '''
        # if not index: return
        # self.write_table_header(out, "index", "Term Index")
        # for (key, term, links) in index:
          <tr><td width="15%">$term.to_plaintext(None)$</td>
              <td>
        #     for link in links[:-1]:
                <em>$self.href(link)$</em>,
        #     #endfor
                <em>$self.href(links[-1])$</em>
              </td>
          </tr>
        # #endfor
        </table>
        <br />
        ''')

    #////////////////////////////////////////////////////////////
    # 2.2. Table of contents
    #////////////////////////////////////////////////////////////
    
    write_toc = compile_template(
        """
        write_toc(self, out)
        """,
        '''
        # self.write_header(out, "Table of Contents")
        <h1 class="tocheading">Table&nbsp;of&nbsp;Contents</h1>
        <hr />
        <p class="toc">
          <a target="moduleFrame" href="toc-everything.html">Everything</a>
        </p>
        # packages = [d for d in self.docset if
        #             isinstance(d, ModuleDoc) and d.is_package]
        # self.write_toc_section(out, "Packages", packages)
        # modules = [d for d in self.docset if
        #            isinstance(d, ModuleDoc) and not d.is_package]
        # self.write_toc_section(out, "Modules", modules)
        <hr />
        $self.PRIVATE_LINK$
        # self.write_footer(out, short=True)
        ''')

    write_toc_section = compile_template(
        """
        write_toc_section(self, out, name, docs)
        """,
        '''
        # if not docs: return
          <h2 class="tocheading">$name$</h2>
        # # sort by name:
        # decorated = [(str(d.canonical_name),d) for d in docs]
        # decorated.sort()
        # for sortkey, doc in decorated:
        #   doc_url = self.url(doc)
        #   if not doc_url: continue #[xx] hmmm!
        #   toc_url = "toc-"+doc_url
        #   #if not doc.is_public: #[xx] vars are public not val!
        #   #     <div class="private">
        #   # endif
            <p class="toc">
              <a target="moduleFrame" href="$toc_url$"
                 onclick="setFrame(\'$toc_url$\',\'$doc_url$\');"
              >$doc.canonical_name$</a></p>
        #   #if not doc.is_public: #[xx] vars are public not val!
        #   #     </div>
        #   # endif
        # #endfor
        ''')

    def write_project_toc(self, out):
        self.write_header(out, "Everything")
        out('<h1 class="tocheading">Everything</h1>\n')
        out('<hr />\n')

        # List the classes.
        classes = [d for d in self.docset if isinstance(d, ClassDoc)]
        self.write_toc_section(out, "All Classes", classes)

        # List the functions.
        funcs = [d for d in self.docset if isinstance(d, FunctionDoc)]
        self.write_toc_section(out, "All Functions", funcs)

        # List the variables.
        vars = []
        for doc in self.docset:
            if isinstance(doc, ModuleDoc):
                vars += doc.select_variables(value_type='other',
                                             imported=False)
        self.write_toc_section(out, "All Variables", vars)

        # Footer material.
        out('<hr />\n')
        out(self.PRIVATE_LINK)
        self.write_footer(out, short=True)

    PRIVATE_LINK = '''
    <span class="options">[<a href="javascript: void(0);" class="privatelink"
    onclick="toggle_private();">hide private</a>]</span>
    '''.strip()+'\n'
        
    def write_module_toc(self, out, doc):
        """
        Write an HTML page containing the table of contents page for
        the given module to the given streams.  This page lists the
        modules, classes, exceptions, functions, and variables defined
        by the module.
        @param public: The output stream for the public version of the page.
        @param private: The output stream for the private version of the page.
        """
        name = doc.canonical_name[-1]
        self.write_header(out, name)
        out('<h1 class="tocheading">Module %s</h1>\n' % name)
        out('<hr />\n')

        
        # Footer material.
        out('<hr />\n')
        out(self.PRIVATE_LINK)
        self.write_footer(out, short=True)

        return # [XX]
        # Split classes into classes & exceptions.
        doc = self._docmap[uid]
        (classes,excepts) = self._split_classes(doc.classes())

        # Write the header.
        str = self._header(uid.name())
        str += (('<h1 class="tocheading"><a target="mainFrame" '+
                'href="%s">%s</a></h1>\n<hr />\n')
                % (self._dotted_name_to_uri(uid), uid[-1]))
        public.write(str); private.write(str)
        
        # Write the lists of objects.
        if uid.is_package():
            self._write_toc_section(public, private, 'Modules', doc.modules())
        self._write_toc_section(public, private, 'Classes', classes)
        self._write_toc_section(public, private, 'Exceptions', excepts)
        self._write_toc_section(public, private, 'Functions', doc.functions())
        self._write_toc_section(public, private, 'Variables', doc.variables())
                                 
        # Write the private/public link.
        if self._create_private_docs:
            str = '\n<hr />\n'
            public.write(str); private.write(str)
            public.write(self._public_private_link(uid, toc=1,
                                                   from_private=0))
            private.write(self._public_private_link(uid, toc=1,
                                                    from_private=1))

        # Write the footer.
        str = '\n</body>\n</html>\n'
        public.write(str); private.write(str)
    
    #////////////////////////////////////////////////////////////
    # 3.1. Page Header
    #////////////////////////////////////////////////////////////

    write_header = compile_template(
        """
        write_header(self, out, title)

        Generate HTML code for the standard page header, and write it
        to C{out}.  C{title} is a string containing the page title.
        It should be appropriately escaped/encoded.
        """,
        # /------------------------- Template -------------------------\
        '''
        <?xml version="1.0" encoding="iso-8859-1"?>
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                  "DTD/xhtml1-transitional.dtd">
        <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
        <head>
          <title>$title$</title>
          <link rel="stylesheet" href="epydoc.css" type="text/css" />
        <script type="text/javascript">
          <!--
              $self.TOGGLE_PRIVATE_JS$
              $self.GET_COOKIE_JS$
              $self.SET_FRAME_JS$
          // -->
        </script>
        </head>
        
        <body bgcolor="white" text="black" link="blue" vlink="#204080"
              alink="#204080">
        ''')
        # \------------------------------------------------------------/

    # [xx] put the javascripts in a single file?

    #: A javascript that is used to show or hide the API documentation
    #: for private objects.  In order for this to work correctly, all
    #: documentation for private objects should be enclosed in 
    #: C{<div class="private">...</div>} elements.
    TOGGLE_PRIVATE_JS = '''
      function toggle_private() {
        // Search for any private/public links on this page.  Store
        // their old text in "cmd," so we will know what action to
        // take; and change their text to the opposite action.
        var cmd = "?";
        var elts = document.getElementsByTagName("a");
        for(var i=0; i<elts.length; i++) {
          if (elts[i].className == "privatelink") {
            cmd = elts[i].innerHTML;
            elts[i].innerHTML = ((cmd=="show private")?"hide private":
                                                       "show private");
          }
        }
        // Update all DIVs containing private objects.
        var elts = document.getElementsByTagName("div");
        for(var i=0; i<elts.length; i++) {
          if (elts[i].className == "private") {
            elts[i].style.display = ((cmd=="hide private")?"none":"block");
          }
        }
        // Set a cookie to remember the current option.
        document.cookie = "EpydocPrivate="+cmd;
      }
      '''

    GET_COOKIE_JS = '''
      function getCookie(name) {
        var dc = document.cookie;
        var prefix = name + "=";
        var begin = dc.indexOf("; " + prefix);
        if (begin == -1) {
          begin = dc.indexOf(prefix);
          if (begin != 0) return null;
        } else
        { begin += 2; }
        var end = document.cookie.indexOf(";", begin);
        if (end == -1)
        { end = dc.length; }
        return unescape(dc.substring(begin + prefix.length, end));
      }
      '''

    HIDE_PRIVATE_JS = '''
    var cmd=getCookie("EpydocPrivate");
    if (cmd!="show private") {toggle_private();}
    '''

    #: A javascript that is used to set the contents of two frames at
    #: once.  This is used by the project table-of-contents frame to
    #: set both the module table-of-contents frame and the main frame
    #: when the user clicks on a module.
    SET_FRAME_JS = '''
      function setFrame(url1, url2) {
          parent.frames[1].location.href = url1;
          parent.frames[2].location.href = url2;
      }
    '''.strip()
    
    #////////////////////////////////////////////////////////////
    # 3.2. Page Footer
    #////////////////////////////////////////////////////////////

    write_footer = compile_template(
        """
        write_footer(self, out, short=False)

        Generate HTML code for the standard page footer, and write it
        to C{out}.
        """,
        # /------------------------- Template -------------------------\
        '''
        # if not short:
        <table border="0" cellpadding="0" cellspacing="0" width="100%%">
          <tr>
            <td align="left" class="footer">Generated by Epydoc $epydoc.__version__$ on $time.asctime()$</td>
            <td align="right" class="footer">
              <a href="http://epydoc.sourceforge.net">http://epydoc.sf.net</a>
            </td>
          </tr>
        </table>
        # #endif

        <script type="text/javascript">
          <!--
          // Private objects are initially displayed (because if
          // javascript is turned off then we want them to be
          // visible); but by default, we want to hide them.  So hide
          // them unless we have a cookie that says to show them.
          $self.HIDE_PRIVATE_JS$
          // -->
        </script>
          
        </body>
        </html>
        ''')
        # \------------------------------------------------------------/

    #////////////////////////////////////////////////////////////
    # 3.3. Navigation Bar
    #////////////////////////////////////////////////////////////

    write_navbar = compile_template(
        """
        write_navbar(self, out, context)

        Generate HTML code for the navigation bar, and write it to
        C{out}.  The navigation bar typically looks like::

             [ Home Trees Index Help             Project ]

        @param context: A value indicating what page we're generating
        a navigation bar for.  If we're generating an API
        documentation page for an object, then C{context} is a
        L{ValueDoc} containing the documentation for that object;
        otherwise, C{context} is a string name for the page.  The
        following string names are recognized: C{'tree'}, C{'index'},
        and C{'help'}.
        """,
        # /------------------------- Template -------------------------\
        '''
        <!-- ==================== NAVIGATION BAR ==================== -->
        <table class="navbar" border="0" width="100%" cellpadding="0"
               bgcolor="#a0c0ff" cellspacing="0">
          <tr valign="middle">
        # if self._top_page not in ("trees.html", "indices.html", "help.html"):
          <!-- Home link -->
        #   if (isinstance(context, ValueDoc) and
        #       self._top_page == self.url(context.dotted_name)):
              <th bgcolor="#70b0f0" class="navselect"
                  >&nbsp;&nbsp;&nbsp;Home&nbsp;&nbsp;&nbsp;</th>
        #   else:
              <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar"
                href="$self._top_page$">Home</a>&nbsp;&nbsp;&nbsp;</th>
        # #endif
        
          <!-- Tree link -->
        # if context == "trees":
              <th bgcolor="#70b0f0" class="navselect"
                  >&nbsp;&nbsp;&nbsp;Trees&nbsp;&nbsp;&nbsp;</th>
        # else:
              <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar"
                href="trees.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>
        # #endif
        
          <!-- Index link -->
        # if context == "indices":
              <th bgcolor="#70b0f0" class="navselect"
                  >&nbsp;&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;</th>
        # else:
              <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar"
                href="indices.html">Index</a>&nbsp;&nbsp;&nbsp;</th>
        # #endif
        
          <!-- Help link -->
        # if context == "help":
              <th bgcolor="#70b0f0" class="navselect"
                  >&nbsp;&nbsp;&nbsp;Help&nbsp;&nbsp;&nbsp;</th>
        # else:
              <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar"
                href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>
        # #endif
        
        # if self._prj_link:
          <!-- Project homepage -->
              <th class="navbar" align="right" width="100%">
                <table border="0" cellpadding="0" cellspacing="0">
                  <tr><th class="navbar" align="center">
                    <p class="nomargin">
                      $self._prj_link$
              </p></th></tr></table></th>
        # else:
              <th class="navbar" width="100%"></th>
        # #endif
          </tr>
        </table>
        ''')
        # \------------------------------------------------------------/

    #////////////////////////////////////////////////////////////
    # 3.4. Breadcrumbs
    #////////////////////////////////////////////////////////////

    write_breadcrumbs = compile_template(
        """
        write_breadcrumbs(self, out, context)

        Generate HTML for the breadcrumbs line, and write it to
        C{out}.  The breadcrumbs line is an invisible table with a
        list of pointers to the current object's ancestors on the
        left; and the show/hide private selector and the
        frames/noframes selector on the right.

        @param context: The API documentation for the object whose
        breadcrumbs we should generate.
        @type context: L{ValueDoc}
        """,
        # /------------------------- Template -------------------------\
        '''
        <table width="100%" cellpadding="0" cellspacing="0">
          <tr valign="top">
        # if isinstance(context, APIDoc):
            <td width="100%">
              <span class="breadcrumbs">
        #   crumbs = self.breadcrumbs(context)
        #   for crumb in crumbs[:-1]:
                $crumb$ ::
        #   #endfor
                $crumbs[-1]$
              </span><br />
            </td>
        # else:
            <td width="100%">&nbsp;</td>
        # #endif
            <td>
              <table cellpadding="0" cellspacing="0">
                <!-- hide/show private -->
                <tr><td align="right">
                  $self.PRIVATE_LINK$
                </td></tr>
                <tr><td align="right">
                  <span class="options"
                    >[<a href="frames.html" target="_top">frames</a
                    >]&nbsp;|&nbsp;<a href="$self.url(context)$"
                    target="_top">no&nbsp;frames</a>]</span>
                </td></tr>
              </table>
            </td>
          </tr>
        </table>
        ''')
        # \------------------------------------------------------------/

    def breadcrumbs(self, doc):
        crumbs = [self._crumb(doc)]

        # Generate the crumbs for uid's ancestors.
        while True:
            if doc.canonical_container is None:
                return crumbs
            doc = doc.canonical_container
            label = self._crumb(doc)
            name = doc.canonical_name
            crumbs.insert(0, self.href(doc, label)) # [xx] code=0??
            #crumbs.insert(0, self._dotted_name_to_href(name, label, code=0))
        
    def _crumb(self, doc):
        name = doc.canonical_name
        if isinstance(doc, ModuleDoc) and doc.is_package is True:
            return 'Package&nbsp;%s' % name[-1]
        elif isinstance(doc, ModuleDoc):
            return 'Module&nbsp;%s' % name[-1]
        elif isinstance(doc, ClassDoc):
            return 'Class&nbsp;%s' % name[-1]
        else:
            return name[-1]

    #////////////////////////////////////////////////////////////
    # 3.5. Summary Tables
    #////////////////////////////////////////////////////////////

    def write_summary_table(self, out, heading, doc, value_type):
        """
        Generate HTML code for a summary table, and write it to
        C{out}.  A summary table is a table that includes a one-row
        description for each variable (of a given type) in a module or
        class.

        @param heading: The heading for the summary table; typically,
            this indicates what kind of value the table describes
            (e.g., functions or classes).
        @param doc: A L{ValueDoc} object containing the API
            documentation for the module or class whose variables
            we should summarize.
        @param value_type: A string indicating what type of value
            should be listed in this summary table.  This value
            is passed on to C{doc}'s C{select_variables()} method.
        """
        # [xx] Deal with imports!
        # [xx] Deal with inheritance!

        # Divide all public variables of the given type into groups.
        groups = [(g,doc.select_variables(group=g, value_type=value_type,
                                          public=True, imported=False))
                  for g in doc.group_names]

        # Discard any empty groups [xx] necessary?
        groups = [(g,vars) for (g,vars) in groups if vars]
        if not groups: return

        # Write a header
        self.write_table_header(out, "summary", heading)

        # Write a section for each group.
        for name, var_docs in groups:
            if name != '':
                name = name.replace('&','&amp;').replace('<','&lt;')
                self.write_group_header(out, name)
            for var_doc in var_docs:
                if not var_doc.is_public: raise ValueError
                self.write_summary_line(out, var_doc, doc)

        # Write a footer for the table.
        out(self.TABLE_FOOTER)

        # If there are also private variables, then add on a table
        # containing thier summary.  We need to put them in a separate
        # table, in its own <div>, to make the show/hide private
        # functionality work across different browsers.
        private_var_docs = doc.select_variables(group=None, imported=False,
                                                value_type=value_type,
                                                public=False)
        if private_var_docs:
            out('<div class="private">\n')
            self.write_table_header(out, "summary continue")
            self.write_group_header(out, 'Private %s' % heading,
                                    "group continue")
            self.write_summary_line(out, private_var_docs[0], doc)
            for var_doc in private_var_docs[1:]:
                self.write_summary_line(out, var_doc, doc)
            out(self.TABLE_FOOTER)
            out('</div>\n')

        out('<br />\n')

    def write_summary_line(self, out, var_doc, container):
        """
        Generate HTML code for a single line of a summary table, and
        write it to C{out}.  See L{write_summary_table} for more
        information.
        
        @param var_doc: The API documentation for the variable that
            should be described by this line of the summary table.
        @param container: The API documentation for the class or
            module whose summary table we're writing.
        """
        if isinstance(var_doc.value, ClassDoc):
            self.write_class_summary_line(out, var_doc)
        elif isinstance(var_doc.value, RoutineDoc):
            self.write_function_summary_line(out, var_doc, container)
        else:
            self.write_variable_summary_line(out, var_doc)

    write_function_summary_line = compile_template(
        """
        write_variable_summary_line(self, out, var_doc, container)

        Generate HTML code for a single line of a summary table,
        describing a variable whose value is a function, and write
        it to C{out}.
        
        @param var_doc: The API documentation for the variable that
            should be described by this line of the summary table.
        @param container: The API documentation for the class or
            module whose summary table we're writing.
        """,
        # /------------------------- Template -------------------------\
        '''
        # func_doc = var_doc.value
          <tr>
            <td width="15%" align="right" valign="top" class="rtype">
        # if func_doc.return_type not in (None, UNKNOWN):
              $self.description(func_doc.return_type, func_doc, 6)$
        # else:
              &nbsp;
        # #endif
            </td>
            <td>
              $self.function_signature(var_doc, link_name=True)$
        #     if var_doc.is_inherited or func_doc.summary != None:
                <br />
        #       if func_doc.summary != None:
                  $self.description(func_doc.summary, func_doc, 6)$
        #       #endif
        #       if var_doc.is_inherited:
                  <em>(Inherited from
                    $var_doc.value.canonical_name.container()$)</em>
        #       #endif
        #     #endif
            </td>
          </tr>
        ''')
        # \------------------------------------------------------------/

    write_variable_summary_line = compile_template(
        '''
        write_variable_summary_line(self, out, var_doc)
        ''',
        # /------------------------- Template -------------------------\
        '''
          <tr>
            <td width="15%">
              <strong>$self.href(var_doc)$</strong></td>
        #     if var_doc.summary not in (None, UNKNOWN):
            <td>$self.description(var_doc.summary, var_doc, 6)$</td>
        #     elif var_doc.descr not in (None, UNKNOWN):
            <td>$self.description(var_doc.descr.summary(), var_doc, 6)$</td>
        #     else:
            <td>&nbsp;</td>
        #     #endif
          </tr>
        ''')
        # \------------------------------------------------------------/

    write_class_summary_line = compile_template(
        '''
        write_class_summary_line(self, out, var_doc)
        ''',
        # /------------------------- Template -------------------------\
        '''
          <tr>
            <td width="15%">
              <strong>$self.href(var_doc)$</strong></td>
        #     if var_doc.value.summary not in (None, UNKNOWN):
            <td>
              $self.description(var_doc.value.summary, var_doc.value, 6)$
            </td>
        #     else:
            <td>&nbsp;</td>
        #     #endif
          </tr>
        ''')
        # \------------------------------------------------------------/

    #////////////////////////////////////////////////////////////
    # 3.6. Details Lists
    #////////////////////////////////////////////////////////////

    def write_details_list(self, out, heading, doc, value_type):
        var_docs = doc.select_variables(value_type=value_type, imported=False)

        # Filter out inherited variables (they are listed under the
        # class that defines them).
        var_docs = [v for v in var_docs if not v.is_inherited]
        if not var_docs: return

        # Write a header
        self.write_table_header(out, "details", heading)
        out(self.TABLE_FOOTER)
        out('<br />\n')

        for var_doc in var_docs:
            self.write_details_entry(out, var_doc)

    def write_details_entry(self, out, var_doc):
        if isinstance(var_doc.value, RoutineDoc):
            self.write_function_details_entry(out, var_doc)
        else:
            self.write_variable_details_entry(out, var_doc)

    write_function_details_entry = compile_template(
        '''
        write_function_details_entry(self, out, var_doc)
        ''',
        # /------------------------- Template -------------------------\
        '''
        # func_doc = var_doc.value
        # name = var_doc.name
        <a name="$name$"></a>
        # if var_doc.is_public:
        <div>
        # else:
        <div class="private">
        # #endif
        <table width="100%" class="func-details" bgcolor="#e0e0e0"><tr><td>
          <h3>$self.function_signature(var_doc)$
        # if name in self.SPECIAL_METHODS:
            <br /><em class="fname">($self.SPECIAL_METHODS[name]$)</em>
        # #endif
          </h3>
        # if func_doc.descr not in (None, UNKNOWN):
          $self.description(func_doc.descr, func_doc, 2)$
        # #endif
          <dl><dt></dt><dd>

        # #[XX] note -- I am ignoring arg_types
        
        # if func_doc.arg_descrs not in (None, UNKNOWN, [], ()):
            <dl><dt>Parameters:</dt>
        #   for (names, descr) in func_doc.arg_descrs:
        #     names = ", ".join(["<code>%s</code>" % n for n in names])
              <dd><strong class="pname">$names$</strong>
                - $self.description(descr, func_doc, 10)$
              </dd>
        #   #endfor
            </dl>
        # #endif

        # if func_doc.return_descr not in (None, UNKNOWN):
            <dl><dt>Returns:</dt>
              <dd>$self.description(func_doc.return_descr, func_doc, 10)$
        #   if func_doc.return_type not in (None, UNKNOWN):
                  <br />
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(type=$self.description(func_doc.return_type, func_doc, 10)$)
        #   #endif
              </dd>
            </dl>
        # elif func_doc.return_type not in (None, UNKNOWN):
            <dl><dt>Return Type:</dt>
              <dd>$self.description(func_doc.return_type, func_doc, 10)$
              </dd>
            </dl>
        # #endif

        # if func_doc.exception_descrs not in (None, UNKNOWN, (), []):
            <dl><dt>Raises:</dt>
        #   for name, descr in func_doc.exception_descrs:
              <dd>
                <code><strong class="fraise">$self.href(name)$</strong></code>
              </dd> - $self.description(descr, func_doc, 8)$
        #   #endfor
            </dl>
        # #endif

        # if var_doc.overrides not in (None, UNKNOWN):
            <dl><dt>Overrides:</dt>
              <dd>$self.href(var_doc.overrides)$
                <em class="note">(inherited documentation)</em></dd>
            </dl>
        # #endif

        # self.write_standard_fields(out, func_doc)
          </dd></dl>
        </td></tr></table><br /></div>
        ''')
        # \------------------------------------------------------------/

    # Names for the __special__ methods.
    SPECIAL_METHODS ={
    '__init__': 'Constructor',
    '__del__': 'Destructor',
    '__add__': 'Addition operator',
    '__sub__': 'Subtraction operator',
    '__and__': 'And operator',
    '__or__': 'Or operator',
    '__repr__': 'Representation operator',
    '__call__': 'Call operator',
    '__getattr__': 'Qualification operator',
    '__getitem__': 'Indexing operator',
    '__setitem__': 'Index assignment operator',
    '__delitem__': 'Index deletion operator',
    '__delslice__': 'Slice deletion operator',
    '__setslice__': 'Slice assignment operator',
    '__getslice__': 'Slicling operator',
    '__len__': 'Length operator',
    '__cmp__': 'Comparison operator',
    '__eq__': 'Equality operator',
    '__in__': 'Containership operator',
    '__gt__': 'Greater-than operator',
    '__lt__': 'Less-than operator',
    '__ge__': 'Greater-than-or-equals operator',
    '__le__': 'Less-than-or-equals operator',
    '__radd__': 'Right-side addition operator',
    '__hash__': 'Hashing function',
    '__contains__': 'In operator',
    '__nonzero__': 'Boolean test operator',
    '__str__': 'Informal representation operator',
    }
        
    write_variable_details_entry = compile_template(
        '''
        write_variable_details_entry(self, out, var_doc)
        ''',
        # /------------------------- Template -------------------------\
        '''
        <a name="$var_doc.name$"></a>
        # if var_doc.is_public:
        <div>
        # else:
        <div class="private">
        # #endif
        <table width="100%" class="var-details" bgcolor="#e0e0e0"><tr><td>
          <h3>$var_doc.name$</h3>

        # if var_doc.descr not in (None, UNKNOWN):
          $self.description(var_doc.descr, var_doc, 2)$
        # #endif

          <dl><dt></dt><dd>

        # if var_doc.type_descr not in (None, UNKNOWN):
            <dl><dt>Type:</dt>
              <dd>$self.description(var_doc.type_descr, var_doc, 6)$</dd></dl>
        # #endif
        # if (var_doc.value not in (None, UNKNOWN) and
        #     var_doc.value.repr not in (None, UNKNOWN)):
        #        tooltip = self.variable_tooltip(var_doc.value.repr)
            <dl><dt title="$tooltip$">Value:</dt>
              <dd title="$tooltip$"><table><tr><td><pre class="variable">
        $self.pprint_value(var_doc.value)$
              </pre></td></tr></table></dd>
            </dl>
        # #endif
          </dd></dl>
        </td></tr></table><br /></div>
        ''')
        # \------------------------------------------------------------/

    _variable_linelen = 70
    _variable_maxlines = 3
    _variable_tooltip_linelen = 70
    def variable_tooltip(self, s):
        if len(s) > self._variable_tooltip_linelen:
            s = s[:self._variable_tooltip_linelen-3]+'...'
        s = s.replace('&', '&amp;').replace('"', '&quot;')
        s = s.replace('<', '&lt;').replace('>', '&gt;')
        return s

    def pprint_value(self, val_doc, multiline=True, summary_linelen=0):
        # word-wrap, quote, etc?
        if (val_doc.pyval is not UNKNOWN and
            type(val_doc.pyval).__name__ == 'SRE_Pattern'):
            s = colorize_re(val_doc.pyval)
        else:
            s = val_doc.repr.replace('&', '&amp;').replace('<', '&lt;')
        return self._linewrap_html(s, self._variable_linelen,
                                   self._variable_maxlines)

    def pprint_pyval(self, pyval, multiline=True, summary_linelen=0):
        # Handle the most common cases first.  The following types
        # will never need any line wrapping, etc; and they cover most
        # variable values (esp int, for constants).  I leave out
        # LongType on purpose, since long values may need line-
        # wrapping.
        if (type(pyval) is types.IntType or type(pyval) is types.FloatType or
            type(pyval) is types.NoneType or type(pyval) is types.ComplexType):
            # none of these should contain '&', '<' or '>'.
            vstr = repr(pyval)
            return vstr + '&nbsp;' * (self._variable_linelen-len(vstr))

        # For strings, use repr.  Use tripple-quoted-strings where
        # appropriate.
        elif type(pyval) is types.StringType:
            vstr = repr(pyval)
            if vstr.find(r'\n') >= 0 and multiline:
                body = vstr[1:-1].replace(r'\n', '\n')
                vstr = ('<span class="variable-quote">'+vstr[0]*3+'</span>'+
                        markup.plaintext_to_html(body) +
                       '<span class="variable-quote">'+vstr[0]*3+'</span>')
                     
            else:
                vstr = ('<span class="variable-quote">'+vstr[0]+'</span>'+
                        markup.plaintext_to_html(vstr[1:-1])+
                       '<span class="variable-quote">'+vstr[0]+'</span>')

        # For lists, tuples, and dicts, use pprint.  When possible,
        # restrict the amount of stuff that pprint needs to look at,
        # since pprint is surprisingly slow.
        elif type(pyval) is types.TupleType or type(pyval) is types.ListType:
            try: vstr = repr(pyval)
            except: vstr = '...'
            if multiline and len(vstr) > self._variable_linelen:
                vstr = pprint.pformat(pyval[:self._variable_maxlines+1])
            vstr = markup.plaintext_to_html(vstr)
        elif type(pyval) is type({}):
            try: vstr = repr(pyval)
            except: vstr = '...'
            if multiline and len(vstr) > self._variable_linelen:
                if len(pyval) < self._variable_maxlines+50:
                    vstr = pprint.pformat(pyval)
                else:
                    shortval = {}
                    for (k,v) in pyval.items()[:self._variable_maxlines+1]:
                        shortval[k]=v
                    vstr = pprint.pformat(shortval)
            vstr = markup.plaintext_to_html(vstr)

        # For regexps, use colorize_re.
        elif type(pyval).__name__ == 'SRE_Pattern':
            vstr = colorize_re(pyval)
           
        # For other objects, use repr to generate a representation.
        else:
            try: vstr = markup.plaintext_to_html(repr(pyval))
            except: vstr = '...'

        # For the summary table, just return the value; don't
        # bother to word-wrap.
        if not multiline:
            vstr = vstr.replace('\n', '')
            # Change spaces to &nbsp; (except spaces in html tags)
            vstr = vstr.replace(' ', '&nbsp;')
            vstr = vstr.replace('<span&nbsp;', '<span ')
            vstr = self._linewrap_html(vstr, summary_linelen, 1)
            return '<code>%s</code>\n' % vstr

        # Do line-wrapping.
        return self._linewrap_html(vstr, self._variable_linelen,
                                   self._variable_maxlines)

    def _linewrap_html(self, s, linelen, maxlines):
        """
        Add line-wrapping to the HTML string C{s}.  Line length is
        determined by C{linelen}; and the maximum number of
        lines to display is determined by C{maxlines}.  This
        function treats HTML entities (e.g., C{&amp;}) as single
        characters; and ignores HTML tags (e.g., C{<p>}).
        """
        LINEWRAP_MARKER = r'<span class="variable-linewrap">\</span>'
        ELLIPSIS_MARKER = r'<span class="variable-ellipsis">...</span>'
       
        open_elements = [] # tag stack
        lines = []
        start = end = cnum = 0
        while len(lines) <= maxlines and end < len(s):
            # Skip over HTML tags.
            if s[end] == '<':
                newend = s.find('>', end)
                tag = s[end+1:newend]
                if tag[-1]!="/":
                    # non-empty tag
                    tagname = tag.split(None,1)[0]
                    if tagname[0] == "/":
                        open_elements.pop()
                    else:
                        open_elements.append(tagname)
                end = newend
                cnum -= 1

            # HTML entities just count as 1 char.
            elif s[end] == '&':
                end = s.find(';', end)

            # Go on to the next character.
            cnum += 1
            end += 1

            # Check for end-of-line.
            if s[end-1] == '\n':
                lines.append(s[start:end-1])
                cnum = 0
                start = end

            # Check for line-wrap
            if cnum == linelen and end<len(s) and s[end] != '\n':
                if maxlines == 1:
                    closing_tags = ""
                    for tag in open_elements:
                        closing_tags += "</%s>" % (tag,)
                    return s[start:end]+closing_tags+ELLIPSIS_MARKER
                lines.append(s[start:end]+LINEWRAP_MARKER)
                cnum = 0
                start = end

        # Add on anything that's left.
        if end == len(s):
            lines.append(s[start:end])

        # Use the ellipsis marker if the string is too long.
        if len(lines) > maxlines:
            closing_tags = ""
            for tag in open_elements:
                closing_tags += "</%s>" % (tag,)
            lines[-1] = closing_tags+ELLIPSIS_MARKER
            cnum = 3

        # Pad the last line to linelen.
        lines[-1] += ' '*(linelen-cnum+1)

        return ('\n').join(lines)
            
        








    #////////////////////////////////////////////////////////////
    # Base Tree
    #////////////////////////////////////////////////////////////

    def base_tree(self, doc, width=None, postfix=''):
        """
        @return: The HTML code for a class's base tree.  The tree is
            drawn 'upside-down' and right justified, to allow for
            multiple inheritance.
        @rtype: C{string}
        """
        if width == None: width = self.find_tree_width(doc)
        bases = doc.bases
        
        if postfix == '':
            # [XX] use var name instead of canonical name?
            s = (' '*(width-2) + '<strong class="uidshort">'+
                   doc.canonical_name[-1]+'</strong>\n')
        else: s = ''
        for i in range(len(bases)-1, -1, -1):
            base = bases[i]
            s = (' '*(width-4-len(str(base.canonical_name))) +
                   self.href(base.canonical_name)
                   +' --+'+postfix+'\n' + 
                   ' '*(width-4) +
                   '   |'+postfix+'\n' +
                   s)
            if i != 0:
                s = (self.base_tree(base, width-4, '   |'+postfix)+s)
            else:
                s = (self.base_tree(base, width-4, '    '+postfix)+s)
        ss = re.sub('<[^<>]+>','',s) # [XX] ????
        return s

    def find_tree_width(self, doc):
        """
        Helper function for L{_base_tree}.
        @return: The width of a base tree, when drawn
            right-justified.  This is used by L{_base_tree} to
            determine how far to indent lines of the base tree.
        @rtype: C{int}
        """
        width = 2
        for base in doc.bases:
            width = max(width, len(str(base.canonical_name))+4,
                        self.find_tree_width(base)+4)
        return width
    
    #////////////////////////////////////////////////////////////
    # Function Signatures
    #////////////////////////////////////////////////////////////

    def function_signature(self, var_doc, css_class='sig',
                           link_name=False):
        # This should never happen, but just in case:
        if var_doc.value in (None, UNKNOWN):
            return (('<span class="%s"><span class="%s-name">%s</span>'+
                     '(...)</span>') % (css_class, css_class, var_doc.name))

        # Get the function's name.
        if link_name:
            name = self.href(var_doc.value, var_doc.name,
                             css_class=css_class+'-name')
        else:
            name = ('<span class="%s-name">%s</span>' %
                    (css_class, var_doc.name))
        
        func_doc = var_doc.value
        args = [self.func_arg(n, d, css_class) for (n, d)
                in zip(func_doc.posargs, func_doc.posarg_defaults)]
        if func_doc.vararg:
            args.append('<span class="%s-arg">*%s</span>' %
                        (css_class, func_doc.vararg))
        if func_doc.kwarg:
            args.append('<span class="%s-arg">**%s</span>' %
                        (css_class, func_doc.kwarg))

        return ('<span class="%s">%s(%s)</span>' %
                (css_class, name, ',\n        '.join(args)))

    def func_arg(self, name, default, css_class):
        s = '<span class="%s-arg">%s</span>' % (css_class, name)
        if default is not None:
            if default.repr is not UNKNOWN:
                s += ('=<span class="%s-default">%s</span>' %
                      (css_class, default.repr))
            else:
                s += '=<span class="%s-default">??</span>' % css_class
        return s


    

    

    #////////////////////////////////////////////////////////////
    # Function Attributes
    #////////////////////////////////////////////////////////////
        
    #////////////////////////////////////////////////////////////
    # Module Trees
    #////////////////////////////////////////////////////////////

    write_module_list = compile_template(
        '''
        write_module_list(self, out, doc)
        ''',
        '''
        # if len(doc.submodules) == 0: return
        # self.write_table_header(out, "details", "Submodules")
        # for submodule in doc.submodules:
          <tr><td><ul>
        #   self.write_module_tree_item(out, submodule)
          </ul></td></tr>
        $self.TABLE_FOOTER$
        <br />
        ''')

    def write_module_tree(self, out):
        return # [xx]

    def write_class_tree(self, out):
        return # [xx]

    write_module_tree_item = compile_template(
        '''
        write_module_tree_item(self, out, doc)
        ''',
        '''
        # if doc.summary in (None, UNKNOWN):
            <li> <strong class="udlink">$self.href(doc)$</strong>
        # else:
            <li> <strong class="udlink">$self.href(doc)$</strong>:
                $self.description(doc.summary, doc, 8)$
        # # endif
        # if doc.submodules:
            <ul>
        #   for submodule in doc.submodules:
        #     self.write_module_tree_item(out, submodule)
        #   #endfor
            </ul>
        # #endif
            </li>
        ''')

    
    #////////////////////////////////////////////////////////////
    # Standard Fields
    #////////////////////////////////////////////////////////////

    write_standard_fields = compile_template(
        """
        write_standard_fields(self, out, doc)
        
        Write HTML code containing descriptions of any standard markup
        fields that are defined by the given L{APIDoc} object (such as
        C{@author} and C{@todo} fields).

        @param doc: The L{APIDoc} object containing the API documentation
            for the object whose standard markup fields should be
            described.
        """,
        """
        # for field in DocstringParser.STANDARD_FIELDS:
        #   vals = doc.metadata.get(field.tags[0])
        #   if vals is None: continue
        #   if len(vals) == 1:
              <p><strong>$field.singular$:</strong>
                $self.description(vals[0], doc, 8)$
              </p>
        #   elif field.short:
              <dl><dt>$field.plural$:</dt>
                <dd>
        #     for val in vals[:-1]:
                  $self.description(val, doc, 10)$,
        #     # end for
                  $self.description(vals[-1], doc, 10)$
                </dd>
              </dl>
        #   else:
              <p><strong>$field.plural$:</strong>
              <ul>
        #     for val in vals:
                <li>
                $self.description(val, doc, 8)$
                </li>
              # end for
              </ul>
        #   # end else
        # # end for
        """)

    #////////////////////////////////////////////////////////////
    # Term index generation
    #////////////////////////////////////////////////////////////
    
    def _get_index_terms(self, parsed_docstring, link, terms, links):
        """
        A helper function for L{_extract_term_index}.
        
        For each index term M{t} with key M{k} in C{parsed_docstring},
        modify C{terms} and C{links} as follows:
          - Set C{terms[M{k}] = t} (if C{terms[M{k}]} doesn't exist).
          - Append C{link} to C{links[M{k}]}.
        """
        if parsed_docstring in (None, UNKNOWN): return
        for term in parsed_docstring.index_terms():
            key = self._term_index_to_anchor(term)
            if not terms.has_key(key):
                terms[key] = term
                links[key] = []
            links[key].append(link)

    def _term_index_to_anchor(self, term):
        """
        Given the name of an inline index item, construct a URI anchor.
        These anchors are used to create links from the index page to each
        index item.
        """
        # Include "-" so we don't accidentally collide with the name
        # of a python identifier.
        s = re.sub(r'\s\s+', '-', term.to_plaintext(None))
        return "index-"+re.sub("[^a-zA-Z0-9]", "_", s)

    def _extract_term_index(self):
        """
        Extract the set of terms that should be indexed from all
        documented docstrings.  Return the extracted set as a
        list of tuples of the form C{(key, term, [links])}.
        This list is used by L{_write_indices} to construct the
        term index.
        @rtype: C{list} of C{(string, ParsedDocstring, list of ValueDoc)}
        """
        terms = {}
        links = {}
        for doc in self.docset:
            self._get_index_terms(doc.descr, doc, terms, links)
            if doc.metadata not in (None, UNKNOWN):
                for descrlist in doc.metadata.values():
                    for descr in descrlist:
                        self._get_index_terms(descr, doc, terms, links)
            # summary?
            if isinstance(doc, ClassDoc):
                for var in doc.local_variables.items():
                    pass
            elif isinstance(doc, NamespaceDoc):
                for var in doc.variables.items():
                    pass
            elif isinstance(doc, RoutineDoc):
                self._get_index_terms(doc.return_descr, doc, terms, links)
                self._get_index_terms(doc.return_type, doc, terms, links)
                if doc.arg_descrs not in (None, UNKNOWN):
                    for arg, descr in doc.arg_descrs:
                        self._get_index_terms(descr, doc, terms, links)
                if doc.arg_types not in (None, UNKNOWN):
                    for arg, descr in doc.arg_types.items():
                        self._get_index_terms(descr, doc, terms, links)
                if doc.exception_descrs not in (None, UNKNOWN):
                    for excname, descr in doc.exception_descrs:
                        self._get_index_terms(descr, doc, terms, links)
            elif isinstance(doc, PropertyDoc):
                self._get_index_terms(doc.type_descr, doc, terms, links)
                    
        # Combine terms & links into one list
        keys = terms.keys()
        keys.sort()
        return [(k, terms[k], links[k]) for k in keys]
                    
    #////////////////////////////////////////////////////////////
    # Helper functions
    #////////////////////////////////////////////////////////////

    write_table_header = compile_template(
        '''
        write_table_header(self, out, css_class, heading=None)
        ''',
        '''
        # if heading is not None:
        <!-- ==================== $heading.upper()$ ==================== -->
        # #endif
        <table class="$css_class$" border="1" cellpadding="3"
               cellspacing="0" width="100%" bgcolor="white">
        # if heading is not None:
        <tr bgcolor="#70b0f0" class="$css_class$">
          <th colspan="2">$heading$</th></tr>
        # #endif
        ''')

    TABLE_FOOTER = '</table>\n'

    write_group_header = compile_template(
        '''
        write_group_header(self, out, group, css_class="group")
        ''',
        '''
        <tr bgcolor="#e8f0f8" class="$css_class$">
          <th colspan="2" class="$css_class$"
            >&nbsp;&nbsp;&nbsp;&nbsp;$group$</th></tr>
        ''')

    def url(self, obj):
        """
        Return the URL for the given object, which can be a
        C{VariableDoc}, a C{ValueDoc}, or a C{DottedName}.
        """
        if isinstance(obj, ModuleDoc):
            return '%s-module.html' % obj.canonical_name
        elif isinstance(obj, ClassDoc):
            return '%s-class.html' % obj.canonical_name
        elif isinstance(obj, VariableDoc):
            val_doc = obj.value
            if isinstance(val_doc, (ModuleDoc, ClassDoc)):
                return self.url(val_doc)
            elif obj.container in (None, UNKNOWN):
                return self.url(val_doc)
            else:
                return '%s#%s' % (self.url(obj.container), obj.name)
        elif isinstance(obj, ValueDoc):
            if obj.canonical_container in (None, UNKNOWN):
                return None # [xx] hmm...
            else:
                return '%s#%s' % (self.url(obj.canonical_container),
                                  obj.canonical_name[-1])
        elif isinstance(obj, DottedName):
            if obj in self.docindex:
                return self.url(self.docindex[obj])
            else:
                return None # [xx] hmm...
        elif obj == 'indices':
            return 'indices.html'
        elif obj == 'help':
            return 'help.html'
        elif obj == 'trees':
            return 'trees.html'
        else:
            raise ValueError, "Don't know what to do with %r" % obj

    def href(self, target, label=None, css_class=None):
        """
        Return the HTML code for an HREF link to the given target
        (which can be a C{VariableDoc}, a C{ValueDoc}, or a
        C{DottedName}.
        """
        assert isinstance(target, (APIDoc, DottedName))

        # Pick a label, if none was given.
        if label is None:
            if isinstance(target, VariableDoc):
                label = str(target.name)
            elif isinstance(target, ValueDoc):
                label = str(target.canonical_name)
            elif isinstance(target, DottedName):
                label = str(target)
            else:
                raise ValueError, "bad label"

        # Get the url for the target.
        url = self.url(target)
        if url is None: return label

        # Construct a string for the class attribute.
        if css_class is None:
            css = ''
        else:
            css = ' class="%s"' % css_class

        return '<a href="%s"%s>%s</a>' % (url, css, label)

    def description(self, parsed_docstring, where=None, indent=0):
        if parsed_docstring in (None, UNKNOWN): return ''
        linker = _HTMLDocstringLinker(self, where)
        return parsed_docstring.to_html(linker, indent=indent).strip()
    

class _HTMLDocstringLinker(epydoc.markup.DocstringLinker):
    def __init__(self, foo, where):
        self.where = where
    def translate_indexterm(self, indexterm):
        return '???'
    def translate_identifier_xref(self, identifier, label=None):
        return '???'
